Out-of-bounds Write in bfabiszewski/libmobi,CVE-2021-3751,CWE-787: Out-of-bounds Write,"        }
        source += aoffset;
    } else {
        if ( (buf->offset < aoffset) || (buf->offset + len > buf->maxlen) ) {
            debug_print(""%s"", ""Beyond start/end of buffer\n"");
            buf->error = MOBI_BUFFER_END;
            return;
        }
"
Heap-based Buffer Overflow in hoene/libmysofa,CVE-2021-3756,CWE-122: Heap-based Buffer Overflow,"      store = ftell(reader->fhd);
      if (fseek(reader->fhd, data_address, SEEK_SET) < 0)
        return errno; // LCOV_EXCL_LINE
      if (data->data) {
        free(data->data);
        data->data = NULL;




      }
      if (data_size > 0x10000000)
        return MYSOFA_INVALID_FORMAT;
      data->data_len = data_size;
      data->data = calloc(1, data_size);
      if (!data->data)
        return MYSOFA_NO_MEMORY; // LCOV_EXCL_LINE

      err = fread(data->data, 1, data_size, reader->fhd);
      if (err != data_size)
        return MYSOFA_READ_ERROR; // LCOV_EXCL_LINE
"
Heap-based Buffer Overflow in vim/vim,CVE-2021-3770,CWE-122: Heap-based Buffer Overflow,"/*
 * Set the integer values corresponding to the string setting of 'vartabstop'.
 * ""array"" will be set, caller must free it if needed.
 * Return FAIL for an error.
 */
    int
tabstop_set(char_u *var, int **array)
{
    int     valcount = 1;
    int     t;
    char_u  *cp;

    if (var[0] == NUL || (var[0] == '0' && var[1] == NUL))
    {
 *array = NULL;
 return OK;
    }

    for (cp = var; *cp != NUL; ++cp)
  if (cp != end)
      emsg(_(e_positive));
  else
      semsg(_(e_invarg2), cp);
  return FAIL;
     }
 }

     ++valcount;
     continue;
 }
 semsg(_(e_invarg2), var);
 return FAIL;
    }

    *array = ALLOC_MULT(int, valcount + 1);
    if (*array == NULL)
 return FAIL;
    (*array)[0] = valcount;

    t = 1;
    for (cp = var; *cp != NUL;)
    {
 int n = atoi((char *)cp);

 if (n < 0 || n > 9999)
 {
     semsg(_(e_invarg2), cp);
     return FAIL;
 }
 (*array)[t++] = n;
 while (*cp != NUL && *cp != ',')
     ++cp;
 if (*cp != NUL)
     ++cp;
    }

    return OK;
}

/*

#ifdef FEAT_VARTABS
    new_ts_str = eap->arg;
    if (tabstop_set(eap->arg, &new_vts_array) == FAIL)
 return;
    while (vim_isdigit(*(eap->arg)) || *(eap->arg) == ',')
 ++(eap->arg);
#endif
#ifdef FEAT_VARTABS
    vim_free(curbuf->b_p_vsts_array);
    (void)tabstop_set(curbuf->b_p_vsts, &curbuf->b_p_vsts_array);
    vim_free(curbuf->b_p_vts_array);
    (void)tabstop_set(curbuf->b_p_vts,  &curbuf->b_p_vts_array);
#endif
}

     buf->b_p_vsts = vim_strsave(p_vsts);
     COPY_OPT_SCTX(buf, BV_VSTS);
     if (p_vsts && p_vsts != empty_option)
  (void)tabstop_set(p_vsts, &buf->b_p_vsts_array);
     else
  buf->b_p_vsts_array = 0;
     buf->b_p_vsts_nopaste = p_vsts_nopaste
  buf->b_p_isk = save_p_isk;
#ifdef FEAT_VARTABS
  if (p_vts && p_vts != empty_option && !buf->b_p_vts_array)
      (void)tabstop_set(p_vts, &buf->b_p_vts_array);
  else
      buf->b_p_vts_array = NULL;
#endif
  buf->b_p_vts = vim_strsave(p_vts);
  COPY_OPT_SCTX(buf, BV_VTS);
  if (p_vts && p_vts != empty_option && !buf->b_p_vts_array)
      (void)tabstop_set(p_vts, &buf->b_p_vts_array);
  else
      buf->b_p_vts_array = NULL;
#endif
     if (buf->b_p_vsts_array)
  vim_free(buf->b_p_vsts_array);
     if (buf->b_p_vsts && buf->b_p_vsts != empty_option)
  (void)tabstop_set(buf->b_p_vsts, &buf->b_p_vsts_array);
     else
  buf->b_p_vsts_array = 0;
#endif
     if (errmsg == NULL)
     {
  int *oldarray = curbuf->b_p_vsts_array;
  if (tabstop_set(*varp, &(curbuf->b_p_vsts_array)) == OK)
  {
      if (oldarray)
   vim_free(oldarray);
     {
  int *oldarray = curbuf->b_p_vts_array;

  if (tabstop_set(*varp, &(curbuf->b_p_vts_array)) == OK)
  {
      vim_free(oldarray);
#ifdef FEAT_FOLDING
func Test_retab_error()
  call assert_fails('retab -1',  'E487:')
  call assert_fails('retab! -1', 'E487:')
  call assert_fails('ret -1000', 'E487:')
  call assert_fails('ret 10000', 'E475:')
  call assert_fails('ret 80000000000000000000', 'E475:')
endfunc

"" vim: shiftwidth=2 sts=2 expandtab

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    3402,
/**/
    3401,
/**/
"
Heap-based Buffer Overflow in vim/vim,CVE-2021-3778,CWE-122: Heap-based Buffer Overflow,"  match = FALSE;
  break;
     }
     len2 += enc_utf8 ? utf_ptr2len(rex.line + col + len2)
            : MB_CHAR2LEN(c2);
 }
 if (match
  // check that no composing char follows
  bwipe!
endfunc

func Test_match_invalid_byte()
  call writefile(0z630a.765d30aa0a.2e0a.790a.4030, 'Xinvalid')
  new
  source Xinvalid
  bwipe!
  call delete('Xinvalid')
endfunc

"" vim: shiftwidth=2 sts=2 expandtab

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    3409,
/**/
    3408,
/**/
"
Use After Free in vim/vim,CVE-2021-3796,CWE-416: Use After Free,"     {
  /*
   * Get ptr again, because u_save and/or showmatch() will have
   * released the line.  This may also happen in ins_copychar().
   * At the same time we let know that the line will be changed.
   */

  if (cap->nchar == Ctrl_E || cap->nchar == Ctrl_Y)
  {
    int c = ins_copychar(curwin->w_cursor.lnum
        + (cap->nchar == Ctrl_Y ? -1 : 1));

    ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE);
    if (c != NUL)
      ptr[curwin->w_cursor.col] = c;
  }
  else
  {
      ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE);
      ptr[curwin->w_cursor.col] = cap->nchar;
  }
  if (p_sm && msg_silent == 0)
      showmatch(cap->nchar);
  ++curwin->w_cursor.col;
  bw!
endfunc

"" Test for getting the character of the line below after ""p""
func Test_edit_put_CTRL_E()
  set encoding=latin1
  new
  let @"" = ''
  sil! norm orggRx
  sil! norm pr
  call assert_equal(['r', 'r'], getline(1, 2))
  bwipe!
  set encoding=utf-8
endfunc

"" vim: shiftwidth=2 sts=2 expandtab

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    3428,
/**/
    3427,
/**/
"
Heap-based Buffer Overflow in vim/vim,CVE-2021-3872,CWE-122: Heap-based Buffer Overflow,"     *(p + len++) = ' ';
 if (bt_help(wp->w_buffer))
 {
     vim_snprintf((char *)p + len, MAXPATHL - len, ""%s"", _(""[Help]""));
     len += (int)STRLEN(p + len);
 }
#ifdef FEAT_QUICKFIX
 if (wp->w_p_pvw)
 {
     vim_snprintf((char *)p + len, MAXPATHL - len, ""%s"", _(""[Preview]""));
     len += (int)STRLEN(p + len);
 }
#endif
#endif
  )
 {
     vim_snprintf((char *)p + len, MAXPATHL - len, ""%s"", ""[+]"");
     len += (int)STRLEN(p + len);
 }
 if (wp->w_buffer->b_p_ro)
 {
     vim_snprintf((char *)p + len, MAXPATHL - len, ""%s"", _(""[RO]""));
     len += (int)STRLEN(p + len);
 }

  %bw!
endfunc

"" Used to write beyond allocated memory.  This assumes MAXPATHL is 4096 bytes.
func Test_statusline_verylong_filename()
  let fname = repeat('x', 4090)
  exe ""new "" .. fname
  set buftype=help
  set previewwindow
  redraw
  bwipe!
endfunc

"" vim: shiftwidth=2 sts=2 expandtab

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    3487,
/**/
    3486,
/**/
"
Heap-based Buffer Overflow in vim/vim,CVE-2021-3875,CWE-122: Heap-based Buffer Overflow,"
      // When '/' or '?' follows another address, start from
      // there.
      if (lnum > 0 && lnum != MAXLNUM)
   curwin->w_cursor.lnum =
    lnum > curbuf->b_ml.ml_line_count
        ? curbuf->b_ml.ml_line_count : lnum;

      // Start a forward search at the end of the line (unless
      // before the first line).
  call feedkeys(""??\<C-T>"", 'xt')
endfunc

func Test_search_with_invalid_range()
  new
  let lines =<< trim END
    /\%.v
    5/
    c
  END
  call writefile(lines, 'Xrangesearch')
  source Xrangesearch

  bwipe!
  call delete('Xrangesearch')
endfunc


"" vim: shiftwidth=2 sts=2 expandtab

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    3489,
/**/
    3488,
/**/
"
Out-of-bounds Read in bfabiszewski/libmobi,CVE-2021-3881,CWE-125: Out-of-bounds Read,"        if (!(t1 & 0x80)) {
            /* get offset from mincode, maxcode tables */
            while (code < huffcdic->mincode_table[code_length]) {
                if (++code_length >= HUFF_CODETABLE_SIZE) {
                    debug_print(""Wrong offset to mincode table: %hhu\n"", code_length);
                    return MOBI_DATA_CORRUPT;
                }
            }
            maxcode = huffcdic->maxcode_table[code_length];
        }

/* FIXME: what is the reasonable value? */
#define MOBI_HUFFMAN_MAXDEPTH 20 /**< Maximal recursion level for huffman decompression routine */
#define HUFF_CODETABLE_SIZE 33 /**< Size of min- and maxcode tables */


/**
    size_t index_read; /**< Number of indices parsed, used by parser */
    size_t code_length; /**< Code length value stored in CDIC record header */
    uint32_t table1[256]; /**< Table of big-endian indices from HUFF record data1 */
    uint32_t mincode_table[HUFF_CODETABLE_SIZE]; /**< Table of big-endian mincodes from HUFF record data2 */
    uint32_t maxcode_table[HUFF_CODETABLE_SIZE]; /**< Table of big-endian maxcodes from HUFF record data2 */
    uint16_t *symbol_offsets; /**< Index of symbol offsets parsed from CDIC records (index_count entries) */
    unsigned char **symbols; /**< Array of pointers to start of symbols data in each CDIC record (index = number of CDIC record) */
} MOBIHuffCdic;
    /* read 32 mincode-maxcode pairs from data2 big-endian */
    huffcdic->mincode_table[0] = 0;
    huffcdic->maxcode_table[0] = 0xFFFFFFFF;
    for (int i = 1; i < HUFF_CODETABLE_SIZE; i++) {
        const uint32_t mincode = mobi_buffer_get32(buf);
        const uint32_t maxcode = mobi_buffer_get32(buf);
        huffcdic->mincode_table[i] =  mincode << (32 - i);
"
Use of Out-of-range Pointer Offset in bfabiszewski/libmobi,CVE-2021-3888,CWE-823: Use of Out-of-range Pointer Offset,"        }
        curr = curr->next;
    }
    if (huffcdic->index_count != huffcdic->index_read) {
        debug_print(""CDIC: wrong read index count: %zu, total: %zu\n"", huffcdic->index_read, huffcdic->index_count);
        return MOBI_DATA_CORRUPT;
    }
    return MOBI_SUCCESS;
}

"
Use of Out-of-range Pointer Offset in bfabiszewski/libmobi,CVE-2021-3889,CWE-823: Use of Out-of-range Pointer Offset,"        if (!(t1 & 0x80)) {
            /* get offset from mincode, maxcode tables */
            while (code < huffcdic->mincode_table[code_length]) {
                if (++code_length >= HUFF_CODETABLE_SIZE) {
                    debug_print(""Wrong offset to mincode table: %hhu\n"", code_length);
                    return MOBI_DATA_CORRUPT;
                }
            }
            maxcode = huffcdic->maxcode_table[code_length];
        }

/* FIXME: what is the reasonable value? */
#define MOBI_HUFFMAN_MAXDEPTH 20 /**< Maximal recursion level for huffman decompression routine */
#define HUFF_CODETABLE_SIZE 33 /**< Size of min- and maxcode tables */


/**
    size_t index_read; /**< Number of indices parsed, used by parser */
    size_t code_length; /**< Code length value stored in CDIC record header */
    uint32_t table1[256]; /**< Table of big-endian indices from HUFF record data1 */
    uint32_t mincode_table[HUFF_CODETABLE_SIZE]; /**< Table of big-endian mincodes from HUFF record data2 */
    uint32_t maxcode_table[HUFF_CODETABLE_SIZE]; /**< Table of big-endian maxcodes from HUFF record data2 */
    uint16_t *symbol_offsets; /**< Index of symbol offsets parsed from CDIC records (index_count entries) */
    unsigned char **symbols; /**< Array of pointers to start of symbols data in each CDIC record (index = number of CDIC record) */
} MOBIHuffCdic;
    /* read 32 mincode-maxcode pairs from data2 big-endian */
    huffcdic->mincode_table[0] = 0;
    huffcdic->maxcode_table[0] = 0xFFFFFFFF;
    for (int i = 1; i < HUFF_CODETABLE_SIZE; i++) {
        const uint32_t mincode = mobi_buffer_get32(buf);
        const uint32_t maxcode = mobi_buffer_get32(buf);
        huffcdic->mincode_table[i] =  mincode << (32 - i);
"
Heap-based Buffer Overflow in vim/vim,CVE-2021-3903,CWE-122: Heap-based Buffer Overflow," check_cursor_lnum();
 curwin->w_topline = curwin->w_cursor.lnum;
 curwin->w_botline = curwin->w_topline;

 curwin->w_scbind_pos = 1;
 return;
    }
  else
    silent exe ""normal! `[v`]y""
  endif
  let g:a = strlen(substitute(@@, '[^ ]', '', 'g'))
  let &selection = sel_save
  let @@ = reg_save
endfunc

func OpfuncDummy(type, ...)
  "" for testing operatorfunc
  let g:opt = &linebreak

  if a:0  "" Invoked from Visual mode, use gv command.
    silent exe ""normal! gvy""
  endif
  "" Create a new dummy window
  new
  let g:bufnr = bufnr('%')
endfunc

func Test_normal00_optrans()
  close!
endfunc

func Test_scroll_in_ex_mode()
  "" This was using invalid memory because w_botline was invalid.
  let lines =<< trim END
      diffsplit
      norm os00(
      call writefile(['done'], 'Xdone')
      qa!
  END
  call writefile(lines, 'Xscript')
  call assert_equal(1, RunVim([], [], '--clean -X -Z -e -s -S Xscript'))
  call assert_equal(['done'], readfile('Xdone'))

  call delete('Xscript')
  call delete('Xdone')
endfunc

"" Test for the 'sidescroll' option
func Test_sidescroll_opt()
  new

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    3564,
/**/
    3563,
/**/
"
Heap-based Buffer Overflow in vim/vim,CVE-2021-3927,CWE-122: Heap-based Buffer Overflow," eap->forceit = TRUE;
    }
    curwin->w_cursor.lnum = eap->line2;
    check_cursor_col();
    do_put(eap->regname, NULL, eap->forceit ? BACKWARD : FORWARD, 1L,
             PUT_LINE|PUT_CURSLINE);
}
  bwipe!
endfunc

func Test_put_above_first_line()
  new
  let @"" = 'text'
  silent! normal 0o00
  0put
  call assert_equal('text', getline(1))
  bwipe!
endfunc


"" vim: shiftwidth=2 sts=2 expandtab

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    3581,
/**/
    3580,
/**/
"
Use of Uninitialized Variable in vim/vim,CVE-2021-3928,CWE-457: Use of Uninitialized Variable,"      // char, e.g., ""thes,"" -> ""these"".
      p = fword + sp->ts_fidx;
      MB_PTR_BACK(fword, p);
      if (!spell_iswordp(p, curwin) && *preword != NUL)
      {
   p = preword + STRLEN(preword);
   MB_PTR_BACK(preword, p);
  call delete('XtestSpell')
endfunc

func Test_spell_single_word()
  new
  silent! norm 0R00
  spell! ßÂ
  silent 0norm 0r$ Dvz=
  bwipe!
endfunc

let g:test_data_aff1 = [
      \""SET ISO8859-1"",
      \""TRY esianrtolcdugmphbyfvkwjkqxz-\xEB\xE9\xE8\xEA\xEF\xEE\xE4\xE0\xE2\xF6\xFC\xFB'ESIANRTOLCDUGMPHBYFVKWJKQXZ"",

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    3582,
/**/
    3581,
/**/
"
Heap-based Buffer Overflow in vim/vim,CVE-2021-3968,CWE-122: Heap-based Buffer Overflow,"    VIsual_mode = c;
    VIsual_active = TRUE;
    VIsual_reselect = TRUE;


    // Corner case: the 0 position in a tab may change when going into
    // virtualedit.  Recalculate curwin->w_cursor to avoid bad highlighting.
    foldAdjustVisual();
#endif

    trigger_modechanged();
    setmouse();
#ifdef FEAT_CONCEAL
    // Check if redraw is needed after changing the state.
func Test_recursive_ModeChanged()
  au! ModeChanged * norm 0u
  sil! norm 
  au! ModeChanged
endfunc

func Test_ModeChanged_starts_visual()
  "" This was triggering ModeChanged before setting VIsual, causing a crash.
  au! ModeChanged * norm 0u
  sil! norm 

  au! ModeChanged
endfunc

"" Test toggling of input method. See :help i_CTRL-^

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    3610,
/**/
    3609,
/**/
"
Heap-based Buffer Overflow in vim/vim,CVE-2021-3973,CWE-122: Heap-based Buffer Overflow,"    proc->pr_WindowPtr = (APTR)-1L;
# endif

    if (len == 0)
 return NULL;

    if (first == TRUE)
    {
 // copy file name into NameBuff, expanding environment variables
    int  c;
# if defined(FEAT_FIND_ID) && defined(FEAT_EVAL)
    char_u *tofree = NULL;
# endif

    if (len == 0)
 return NULL;

# if defined(FEAT_FIND_ID) && defined(FEAT_EVAL)
    if ((options & FNAME_INCL) && *curbuf->b_p_inex != NUL)
    {
 tofree = eval_includeexpr(ptr, len);
     *pp = ml_get_pos(&VIsual);
     *lenp = curwin->w_cursor.col - VIsual.col + 1;
 }
 if (**pp == NUL)
     *lenp = 0;
 if (has_mbyte && *lenp > 0)
     // Correct the length to include all bytes of the last character.
     *lenp += (*mb_ptr2len)(*pp + (*lenp - 1)) - 1;
    }
    reset_VIsual_and_resel();
  call delete('XTest_block')
endfunc

func Test_visual_block_ctrl_w_f()
  "" Emtpy block selected in new buffer should not result in an error.
  au! BufNew foo sil norm f
  edit foo

  au! BufNew
endfunc

func Test_visual_reselect_with_count()
  "" this was causing an illegal memory access
  let lines =<< trim END

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    3611,
/**/
    3610,
/**/
"
Use After Free in vim/vim,CVE-2021-3974,CWE-416: Use After Free,"    // The current match-position is stord in these variables:
    linenr_T lnum;  // line number, relative to first line
    char_u *line;  // start of current line
    char_u *input;  // current input, points into ""line""

    int need_clear_subexpr; // subexpressions still need to be cleared
#ifdef FEAT_SYN_HL
     case NFA_MARK_GT:
     case NFA_MARK_LT:
       {
  size_t col = rex.input - rex.line;
  pos_T *pos = getmark_buf(rex.reg_buf, t->state->val, FALSE);

  // Line may have been freed, get it again.
  if (REG_MULTI)
  {
      rex.line = reg_getline(rex.lnum);
      rex.input = rex.line + col;
  }

  // Compare the mark position to the match position, if the mark
  // exists and mark is set in reg_buf.
  if (pos != NULL && pos->lnum > 0)
  set re&
endfunc

func Test_using_mark_position()
  "" this was using freed memory
  new
  norm O0
  call assert_fails(""s/\\%')"", 'E486:')
  bwipe!
endfunc

"" vim: shiftwidth=2 sts=2 expandtab

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    3612,
/**/
    3611,
/**/
"
Heap-based Buffer Overflow in vim/vim,CVE-2021-3984,CWE-122: Heap-based Buffer Overflow,"    static pos_T *
find_start_brace(void)     // XXX
{
    pos_T     cursor_save;
    pos_T     *trypos;
    pos_T     *pos;
    static pos_T    pos_copy;

    cursor_save = curwin->w_cursor;
    while ((trypos = findmatchlimit(NULL, '{', FM_BLOCKSTOP, 0)) != NULL)
         && (pos = ind_find_start_CORS(NULL)) == NULL) // XXX
     break;
 if (pos != NULL)
     curwin->w_cursor = *pos;
    }
    curwin->w_cursor = cursor_save;
    return trypos;
  bwipe!
endfunc

func Test_find_brace_backwards()
  "" this was looking beyond the end of the line
  new
  norm R/*
  norm o0{
  norm o//
  norm V{=
  call assert_equal(['/*', '   0{', '//'], getline(1, 3))
  bwipe!
endfunc


"" vim: shiftwidth=2 sts=2 expandtab

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    3625,
/**/
    3624,
/**/
"
Heap-based Buffer Overflow in vim/vim,CVE-2021-4019,CWE-122: Heap-based Buffer Overflow,"      || (vim_strchr((char_u *)""%_z@"", arg[1]) != NULL
          && arg[2] != NUL)))
 {
     vim_snprintf((char *)d, IOSIZE, ""/\\\\%s"", arg + 1);

     // Check for ""/\\_$"", should be ""/\\_\$""
     if (d[3] == '_' && d[4] == '$')
  STRCPY(d + 4, ""\\$"");
  close
endfunc

func Test_help_long_argument()
  try
    exe 'help \%' .. repeat('0', 1021)
  catch
    call assert_match(""E149:"", v:exception)
  endtry
endfunc


"" vim: shiftwidth=2 sts=2 expandtab

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    3669,
/**/
    3668,
/**/
"
Cross-site Scripting (XSS) - Stored in meetecho/janus-gateway,CVE-2021-4020,CWE-79: Cross-site Scripting (XSS) - Stored,"            Janus.debug(""Got a list of participants:"", list);
            for(var f in list) {
             var id = list[f][""id""];
             var display = escapeXmlTags(list[f][""display""]);
             var setup = list[f][""setup""];
             var muted = list[f][""muted""];
             var spatial = list[f][""spatial_position""];
            Janus.debug(""Got a list of participants:"", list);
            for(var f in list) {
             var id = list[f][""id""];
             var display = escapeXmlTags(list[f][""display""]);
             var setup = list[f][""setup""];
             var muted = list[f][""muted""];
             var spatial = list[f][""spatial_position""];
            Janus.debug(""Got a list of participants:"", list);
            for(var f in list) {
             var id = list[f][""id""];
             var display = escapeXmlTags(list[f][""display""]);
             var setup = list[f][""setup""];
             var muted = list[f][""muted""];
             var spatial = list[f][""spatial_position""];
   return;
  }
  var register = { request: ""join"", room: myroom, display: username };
  myusername = escapeXmlTags(username);
  // Check if we need to join using G.711 instead of (default) Opus
  if(acodec === 'opus' || acodec === 'pcmu' || acodec === 'pcma')
   register.codec = acodec;
  results = regex.exec(location.search);
 return results === null ? """" : decodeURIComponent(results[1].replace(/\+/g, "" ""));
}

// Helper to escape XML tags
function escapeXmlTags(value) {
 if(value) {
  var escapedValue = value.replace(new RegExp('<', 'g'), '&lt');
  escapedValue = escapedValue.replace(new RegExp('>', 'g'), '&gt');
  return escapedValue;
 }
}
   Janus.debug(""Got a list of available recordings:"", list);
   for(var mp in list) {
    Janus.debug(""  >> ["" + list[mp][""id""] + ""] "" + list[mp][""name""] + "" ("" + list[mp][""date""] + "")"");
    $('#recslist').append(""<li><a href='#' id='"" + list[mp][""id""] + ""'>"" + escapeXmlTags(list[mp][""name""]) + "" ["" + list[mp][""date""] + ""]"" + ""</a></li>"");
   }
   $('#recslist a').unbind('click').click(function() {
    selectedRecording = $(this).attr(""id"");
    selectedRecordingInfo = escapeXmlTags($(this).text());
    $('#recset').html($(this).html()).parent().removeClass('open');
    $('#play').removeAttr('disabled').click(startPlayout);
    return false;
  results = regex.exec(location.search);
 return results === null ? """" : decodeURIComponent(results[1].replace(/\+/g, "" ""));
}

// Helper to escape XML tags
function escapeXmlTags(value) {
 if(value) {
  var escapedValue = value.replace(new RegExp('<', 'g'), '&lt');
  escapedValue = escapedValue.replace(new RegExp('>', 'g'), '&gt');
  return escapedValue;
 }
}
          if(event === ""joined"") {
           myid = msg[""id""];
           $('#session').html(room);
           $('#title').html(escapeXmlTags(msg[""description""]));
           Janus.log(""Successfully joined room "" + msg[""room""] + "" with ID "" + myid);
           if(role === ""publisher"") {
            // This is our session, publish our stream
   }
  });
}

// Helper to escape XML tags
function escapeXmlTags(value) {
 if(value) {
  var escapedValue = value.replace(new RegExp('<', 'g'), '&lt');
  escapedValue = escapedValue.replace(new RegExp('>', 'g'), '&gt');
  return escapedValue;
 }
}
   Janus.debug(list);
   for(var mp in list) {
    Janus.debug(""  >> ["" + list[mp][""id""] + ""] "" + list[mp][""description""] + "" ("" + list[mp][""type""] + "")"");
    $('#streamslist').append(""<li><a href='#' id='"" + list[mp][""id""] + ""'>"" + escapeXmlTags(list[mp][""description""]) + "" ("" + list[mp][""type""] + "")"" + ""</a></li>"");
   }
   $('#streamslist a').unbind('click').click(function() {
    selectedStream = $(this).attr(""id"");
 var body = { request: ""info"", id: parseInt(selectedStream) || selectedStream };
 streaming.send({ message: body, success: function(result) {
  if(result && result.info && result.info.metadata) {
   $('#metadata').html(escapeXmlTags(result.info.metadata));
   $('#info').removeClass('hide').show();
  }
 }});
 simulcastStarted = false;
}

// Helper to escape XML tags
function escapeXmlTags(value) {
 if(value) {
  var escapedValue = value.replace(new RegExp('<', 'g'), '&lt');
  escapedValue = escapedValue.replace(new RegExp('>', 'g'), '&gt');
  return escapedValue;
 }
}

// Helpers to create Simulcast-related UI, if enabled
function addSimulcastButtons() {
 $('#curres').parent().append(
         var what = json[""textroom""];
         if(what === ""message"") {
          // Incoming message: public or private?
          var msg = escapeXmlTags(json[""text""]);


          var from = json[""from""];
          var dateString = getDateString(json[""date""]);
          var whisper = json[""whisper""];
          }
         } else if(what === ""announcement"") {
          // Room announcement
          var msg = escapeXmlTags(json[""text""]);


          var dateString = getDateString(json[""date""]);
          $('#chatroom').append('<p style=""color: purple;"">[' + dateString + '] <i>' + msg + '</i>');
          $('#chatroom').get(0).scrollTop = $('#chatroom').get(0).scrollHeight;
         } else if(what === ""join"") {
          // Somebody joined
          var username = json[""username""];
          var display = json[""display""];
          participants[username] = escapeXmlTags(display ? display : username);
          if(username !== myid && $('#rp' + username).length === 0) {
           // Add to the participants list
           $('#list').append('<li id=""rp' + username + '"" class=""list-group-item"">' + participants[username] + '</li>');
   username: myid,
   display: username
  };
  myusername = escapeXmlTags(username);
  transactions[transaction] = function(response) {
   if(response[""textroom""] === ""error"") {
    // Something went wrong
   if(response.participants && response.participants.length > 0) {
    for(var i in response.participants) {
     var p = response.participants[i];
     participants[p.username] = escapeXmlTags(p.display ? p.display : p.username);
     if(p.username !== myid && $('#rp' + p.username).length === 0) {
      // Add to the participants list
      $('#list').append('<li id=""rp' + p.username + '"" class=""list-group-item"">' + participants[p.username] + '</li>');
  results = regex.exec(location.search);
 return results === null ? """" : decodeURIComponent(results[1].replace(/\+/g, "" ""));
}

// Helper to escape XML tags
function escapeXmlTags(value) {
 if(value) {
  var escapedValue = value.replace(new RegExp('<', 'g'), '&lt');
  escapedValue = escapedValue.replace(new RegExp('>', 'g'), '&gt');
  return escapedValue;
 }
}
          } else if(result[""event""]) {
           var event = result[""event""];
           if(event === 'registered') {
            myusername = escapeXmlTags(result[""username""]);
            Janus.log(""Successfully registered as "" + myusername + ""!"");
            $('#youok').removeClass('hide').show().html(""Registered as '"" + myusername + ""'"");
            // Get a list of available peers, just for fun
            bootbox.alert(""Waiting for the peer to answer..."");
           } else if(event === 'incomingcall') {
            Janus.log(""Incoming call from "" + result[""username""] + ""!"");
            yourusername = escapeXmlTags(result[""username""]);
            // Notify user
            bootbox.hideAll();
            incoming = bootbox.dialog({
            });
           } else if(event === 'accepted') {
            bootbox.hideAll();
            var peer = escapeXmlTags(result[""username""]);
            if(!peer) {
             Janus.log(""Call started!"");
            } else {
 return results === null ? """" : decodeURIComponent(results[1].replace(/\+/g, "" ""));
}

// Helper to escape XML tags
function escapeXmlTags(value) {
 if(value) {
  var escapedValue = value.replace(new RegExp('<', 'g'), '&lt');
  escapedValue = escapedValue.replace(new RegExp('>', 'g'), '&gt');
  return escapedValue;
 }
}

// Helpers to create Simulcast-related UI, if enabled
function addSimulcastButtons(temporal) {
 $('#curres').parent().append(
   ptype: ""publisher"",
   display: username
  };
  myusername = escapeXmlTags(username);
  sfutest.send({ message: register });
 }
}
       }
      }
      remoteFeed.rfid = msg[""id""];
      remoteFeed.rfdisplay = escapeXmlTags(msg[""display""]);
      if(!remoteFeed.spinner) {
       var target = document.getElementById('videoremote'+remoteFeed.rfindex);
       remoteFeed.spinner = new Spinner({top:100}).spin(target);
 return results === null ? """" : decodeURIComponent(results[1].replace(/\+/g, "" ""));
}

// Helper to escape XML tags
function escapeXmlTags(value) {
 if(value) {
  var escapedValue = value.replace(new RegExp('<', 'g'), '&lt');
  escapedValue = escapedValue.replace(new RegExp('>', 'g'), '&gt');
  return escapedValue;
 }
}

// Helpers to create Simulcast-related UI, if enabled
function addSimulcastButtons(feed, temporal) {
 var index = feed;
   ptype: ""publisher"",
   display: username
  };
  myusername = escapeXmlTags(username);
  sfutest.send({ message: register });
 }
}
       }
      }
      remoteFeed.rfid = msg[""id""];
      remoteFeed.rfdisplay = escapeXmlTags(msg[""display""]);
      if(!remoteFeed.spinner) {
       var target = document.getElementById('videoremote'+remoteFeed.rfindex);
       remoteFeed.spinner = new Spinner({top:100}).spin(target);
  });
}

// Helper to escape XML tags
function escapeXmlTags(value) {
 if(value) {
  var escapedValue = value.replace(new RegExp('<', 'g'), '&lt');
  escapedValue = escapedValue.replace(new RegExp('>', 'g'), '&gt');
  return escapedValue;
 }
}

// Helpers to create SVC-related UI for a new viewer
function addSvcButtons(feed) {
 var index = feed;
"
NULL Pointer Dereference in gpac/gpac,CVE-2021-4043,CWE-476: NULL Pointer Dereference," u32 i;
 GroupIdToNameBox *ptr = (GroupIdToNameBox *)s;
 if (ptr == NULL) return;
 if (ptr->entries) {
  for (i=0; i<ptr->nb_entries; i++) {
   if (ptr->entries[i].name) gf_free(ptr->entries[i].name);
  }
  gf_free(ptr->entries);
 }

 gf_free(ptr);
}

"
Use After Free in vim/vim,CVE-2021-4069,CWE-416: Use After Free," regmatch.regprog = vim_regcomp(eap->arg, magic_isset() ? RE_MAGIC : 0);
 if (regmatch.regprog != NULL)
 {
     // make a copy of the line, when searching for a mark it might be
     // flushed
     char_u *line = vim_strsave(ml_get_curline());

     regmatch.rm_ic = p_ic;
     if (vim_regexec(&regmatch, line, (colnr_T)0))
  curwin->w_cursor.col = (colnr_T)(regmatch.startp[0] - line);

     else
  emsg(_(e_nomatch));
     vim_regfree(regmatch.regprog);
     vim_free(line);
 }
 // Move to the NUL, ignore any other arguments.
 eap->arg += STRLEN(eap->arg);
  close!
endfunc

func Test_open_command_flush_line()
  "" this was accessing freed memory: the regexp match uses a pointer to the
  "" current line which becomes invalid when searching for the ') mark.
  new
  call setline(1, ['one', 'two. three'])
  s/one/ONE
  try
    open /\%')/
  catch /E479/
  endtry
  bwipe!
endfunc

"" Test for :g/pat/visual to run vi commands in Ex mode
"" This used to hang Vim before 8.2.0274.
func Test_Ex_global()

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    3741,
/**/
    3740,
/**/
"
NULL Pointer Dereference in mruby/mruby,CVE-2021-4110,CWE-476: NULL Pointer Dereference,"struct RProc *mrb_closure_new(mrb_state*, const mrb_irep*);
MRB_API struct RProc *mrb_proc_new_cfunc(mrb_state*, mrb_func_t);
MRB_API struct RProc *mrb_closure_new_cfunc(mrb_state *mrb, mrb_func_t func, int nlocals);
void mrb_proc_copy(mrb_state *mrb, struct RProc *a, struct RProc *b);
mrb_int mrb_proc_arity(const struct RProc *p);

/* following functions are defined in mruby-proc-ext so please include it when using */
    mrb_raise(mrb, E_ARGUMENT_ERROR, ""no block given"");
  }
  p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb->proc_class);
  mrb_proc_copy(mrb, p, mrb_proc_ptr(blk));
  p->flags |= MRB_PROC_STRICT;
  MRB_METHOD_FROM_PROC(m, p);
  mrb_define_method_raw(mrb, c, mid, m);
}

void
mrb_proc_copy(mrb_state *mrb, struct RProc *a, struct RProc *b)
{
  if (a->body.irep) {
    /* already initialized proc */
    return;
  }
  a->flags = b->flags;
  a->body = b->body;
  a->upper = b->upper;
  if (!MRB_PROC_CFUNC_P(a) && a->body.irep) {
    mrb_irep_incref(mrb, (mrb_irep*)a->body.irep);
  }

  a->e.env = b->e.env;
  /* a->e.target_class = a->e.target_class; */
}
  /* Calling Proc.new without a block is not implemented yet */
  mrb_get_args(mrb, ""&!"", &blk);
  p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb_class_ptr(proc_class));
  mrb_proc_copy(mrb, p, mrb_proc_ptr(blk));
  proc = mrb_obj_value(p);
  mrb_funcall_with_block(mrb, proc, MRB_SYM(initialize), 0, NULL, proc);
  if (!MRB_PROC_STRICT_P(p) &&
  if (!mrb_proc_p(proc)) {
    mrb_raise(mrb, E_ARGUMENT_ERROR, ""not a proc"");
  }
  mrb_proc_copy(mrb, mrb_proc_ptr(self), mrb_proc_ptr(proc));
  return self;
}

  p = mrb_proc_ptr(blk);
  if (!MRB_PROC_STRICT_P(p)) {
    struct RProc *p2 = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, p->c);
    mrb_proc_copy(mrb, p2, p);
    p2->flags |= MRB_PROC_STRICT;
    return mrb_obj_value(p2);
  }
"
Cross-site Scripting (XSS) - Stored in meetecho/janus-gateway,CVE-2021-4124,CWE-79: Cross-site Scripting (XSS) - Stored,"    text: JSON.stringify(message),
    error: function(reason) { bootbox.alert(reason); },
    success: function() {
     $('#chatroom').append('<p style=""color: purple;"">[' + getDateString() + '] <b>[whisper to ' + display + ']</b> ' + escapeXmlTags(result));
     $('#chatroom').get(0).scrollTop = $('#chatroom').get(0).scrollHeight;
    }
   });
"
Heap-based Buffer Overflow in vim/vim,CVE-2021-4136,CWE-122: Heap-based Buffer Overflow," ++*arg;
 ret = eval1(arg, rettv, evalarg);
 *arg = skipwhite_and_linebreak(*arg, evalarg);
 if (**arg == ')')
 {
     ++*arg;
 }
 else
 {
     emsg(_(e_missing_closing_paren));
     ret = FAIL;
 }

    }
    if (ret != OK)
 return FAIL;
  call assert_fails('echo {a, a -> a + a}(1, 2)', 'E853:')
  call assert_fails('echo {a, b -> a + b)}(1, 2)', 'E451:')
  echo assert_fails('echo 10->{a -> a + 2}', 'E107:')

  call assert_fails('eval 0->(', ""E110: Missing ')'"")
endfunc

func Test_not_lamda()

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    3847,
/**/
    3846,
/**/
"
Out-of-bounds Read in vim/vim,CVE-2021-4166,CWE-125: Out-of-bounds Read,"    tabpage_T *old_curtab, *last_curtab;
    win_T *new_curwin = NULL;
    tabpage_T *new_curtab = NULL;
    int  prev_arglist_locked = arglist_locked;

#ifdef FEAT_CMDWIN
    if (cmdwin_type != 0)
    // watch out for its size to be changed.
    alist = curwin->w_alist;
    ++alist->al_refcount;
    arglist_locked = TRUE;

    old_curwin = curwin;
    old_curtab = curtab;

    // Remove the ""lock"" on the argument list.
    alist_unlink(alist);
    arglist_locked = prev_arglist_locked;

    --autocmd_no_enter;

  au! BufEnter
endfunc

func Test_clear_arglist_in_all()
  n 0 00 000 0000 00000 000000
  au! * 0 n 0
  all
  au! *
endfunc

"" vim: shiftwidth=2 sts=2 expandtab

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    3884,
/**/
    3883,
/**/
"
Use After Free in vim/vim,CVE-2021-4173,CWE-416: Use After Free,"char_u *get_scriptlocal_funcname(char_u *funcname);
char_u *save_function_name(char_u **name, int *is_global, int skip, int flags, funcdict_T *fudi);
void list_functions(regmatch_T *regmatch);
ufunc_T *define_function(exarg_T *eap, char_u *name_arg, char_u **line_to_free);
void ex_function(exarg_T *eap);
void ex_defcompile(exarg_T *eap);
int eval_fname_script(char_u *p);
  assert_fails('FuncWithForwardCall()', 'E1096:', '', 1, 'FuncWithForwardCall')
enddef

def Test_nested_functin_with_nextcmd()
  var lines =<< trim END
      vim9script
      # Define an outer function
      def FirstFunction()
        # Define an inner function
        def SecondFunction()
          # the function has a body, a double free is detected.
          AAAAA

         # enddef followed by | or } followed by # one or more characters
         enddef|BBBB
      enddef

      # Compile all functions
      defcompile
  END
  CheckScriptFailure(lines, 'E476: Invalid command: AAAAA')
enddef

def Test_return_type_wrong()
  CheckScriptFailure([
        'def Func(): number',
 }
 else
 {

     if (eap->getline == NULL)
  theline = getcmdline(':', 0L, indent, getline_options);
     else
  theline = eap->getline(':', eap->cookie, indent,
             getline_options);
     if (*eap->cmdlinep == *line_to_free)
  *eap->cmdlinep = theline;
     vim_free(*line_to_free);
     *line_to_free = theline;
 }
 if (KeyTyped)
   // we can simply point into it, otherwise we need to
   // change ""eap->cmdlinep"".
   eap->nextcmd = nextcmd;
   if (*line_to_free != NULL
         && *eap->cmdlinep != *line_to_free)
   {
       vim_free(*eap->cmdlinep);
       *eap->cmdlinep = *line_to_free;
 }
 if (ga_grow(gap, 1) == FAIL || ga_grow(freegap, 1) == FAIL)
     goto erret;
 if (eap.nextcmd != NULL)
     // more is following after the ""}"", which was skipped
     last = cmdline;
 else
 ((char_u **)freegap->ga_data)[freegap->ga_len++] = pnl;
    }

    if (eap.nextcmd != NULL)
    {
 garray_T *tfgap = &evalarg->eval_tofree_ga;

 {
     ((char_u **)(tfgap->ga_data))[tfgap->ga_len++] = cmdline;
     evalarg->eval_using_cmdline = TRUE;
     if (cmdline == line_to_free)
  line_to_free = NULL;
 }
    }
    else
 * Returns a pointer to the function or NULL if no function defined.
 */
    ufunc_T *
define_function(exarg_T *eap, char_u *name_arg, char_u **line_to_free)
{

    int  j;
    int  c;
    int  saved_did_emsg;
    if (get_function_args(&p, ')', &newargs,
   eap->cmdidx == CMD_def ? &argtypes : NULL, FALSE,
    NULL, &varargs, &default_args, eap->skip,
    eap, line_to_free) == FAIL)
 goto errret_2;
    whitep = p;


    // Do not define the function when getting the body fails and when
    // skipping.
    if (get_function_body(eap, &newlines, line_arg, line_to_free) == FAIL
     || eap->skip)
 goto erret;

    }
ret_free:
    ga_clear_strings(&argtypes);

    vim_free(fudi.fd_newkey);
    if (name != name_arg)
 vim_free(name);
    void
ex_function(exarg_T *eap)
{
    char_u *line_to_free = NULL;

    (void)define_function(eap, NULL, &line_to_free);
    vim_free(line_to_free);
}

/*

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    3902,
/**/
    3901,
/**/
 * Compile a nested :def command.
 */
    static char_u *
compile_nested_function(exarg_T *eap, cctx_T *cctx, char_u **line_to_free)
{
    int  is_global = *eap->arg == 'g' && eap->arg[1] == ':';
    char_u *name_start = eap->arg;
    char_u *name_end = to_name_end(eap->arg, TRUE);
    int  off;
    char_u *func_name;
    char_u *lambda_name;
    ufunc_T *ufunc;
    int  r = FAIL;
    lambda_name = vim_strsave(get_lambda_name());
    if (lambda_name == NULL)
 return NULL;

    // This may free the current line, make a copy of the name.
    off = is_global ? 2 : 0;
    func_name = vim_strnsave(name_start + off, name_end - name_start - off);
    if (func_name == NULL)
    {
 r = FAIL;
 goto theend;
    }

    ufunc = define_function(eap, lambda_name, line_to_free);

    if (ufunc == NULL)
    {

    if (is_global)
    {
 r = generate_NEWFUNC(cctx, lambda_name, func_name);
 func_name = NULL;
 lambda_name = NULL;







    }
    else
    {
 // Define a local variable for the function reference.
 lvar_T *lvar = reserve_local(cctx, func_name, name_end - name_start,
          TRUE, ufunc->uf_func_type);

 if (lvar == NULL)

theend:
    vim_free(lambda_name);
    vim_free(func_name);
    return r == FAIL ? NULL : (char_u *)"""";
}

     case CMD_def:
     case CMD_function:
      ea.arg = p;
      line = compile_nested_function(&ea, &cctx, &line_to_free);
      break;

     case CMD_return:
  else
  {
      exarg_T ea;
      char_u  *line_to_free = NULL;

      CLEAR_FIELD(ea);
      ea.cmd = ea.arg = iptr->isn_arg.string;
      define_function(&ea, NULL, &line_to_free);
      vim_free(line_to_free);
  }
  break;

"
Use After Free in vim/vim,CVE-2021-4187,CWE-416: Use After Free,"  assert_fails('FuncWithForwardCall()', 'E1096:', '', 1, 'FuncWithForwardCall')
enddef

def Test_nested_function_with_nextcmd()
  var lines =<< trim END
      vim9script
      # Define an outer function
  CheckScriptFailure(lines, 'E476: Invalid command: AAAAA')
enddef

def Test_nested_function_with_args_split()
  var lines =<< trim END
      vim9script
      def FirstFunction()
        def SecondFunction(
        )
        # had a double free if the right parenthesis of the nested function is
        # on the next line

        enddef|BBBB
      enddef
      # Compile all functions
      defcompile
  END
  # FIXME: this should fail on the BBBB
  CheckScriptSuccess(lines)
enddef

def Test_return_type_wrong()
  CheckScriptFailure([
        'def Func(): number',
     if (theline == NULL)
  break;
     vim_free(*line_to_free);
     if (*eap->cmdlinep == *line_to_free)
  *eap->cmdlinep = theline;
     *line_to_free = theline;
     whitep = (char_u *)"" "";
     p = skipwhite(theline);

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    3923,
/**/
    3922,
/**/
"
NULL Pointer Dereference in mruby/mruby,CVE-2021-4188,CWE-476: NULL Pointer Dereference,"static mrb_value
mrb_ary_shift_m(mrb_state *mrb, mrb_value self)
{


  mrb_int n;


  if (mrb_get_args(mrb, ""|i"", &n) == 0) {
    return mrb_ary_shift(mrb, self);
  }

  struct RArray *a = mrb_ary_ptr(self);
  mrb_int len = ARY_LEN(a);
  mrb_value val;

  ary_modify_check(mrb, a);
  if (len == 0 || n == 0) return mrb_ary_new(mrb);
  if (n < 0) mrb_raise(mrb, E_ARGUMENT_ERROR, ""negative array shift"");
"
Use After Free in vim/vim,CVE-2021-4192,CWE-416: Use After Free,"    if (lnum < top.lnum || lnum > bot.lnum)
 return FALSE;

    col = (colnr_T)(rex.input - rex.line);
    if (mode == 'v')
    {

 if ((lnum == top.lnum && col < top.col)
  || (lnum == bot.lnum && col >= bot.col + (*p_sel != 'e')))
     return FALSE;
     end = end2;
 if (top.col == MAXCOL || bot.col == MAXCOL || curswant == MAXCOL)
     end = MAXCOL;

 // getvvcol() flushes rex.line, need to get it again
 rex.line = reg_getline(rex.lnum);
 rex.input = rex.line + col;

 cols = win_linetabsize(wp, rex.line, col);
 if (cols < start || cols > end - (*p_sel == 'e'))
     return FALSE;
    }
  bwipe!
endfunc

func Test_using_visual_position()
  "" this was using freed memory
  new
  exe ""norm 0o\<Esc>\<C-V>k\<C-X>o0""
  /\%V
  bwipe!
endfunc

"" vim: shiftwidth=2 sts=2 expandtab

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    3949,
/**/
    3948,
/**/
"
Out-of-bounds Read in vim/vim,CVE-2021-4193,CWE-125: Out-of-bounds Read," posptr = NULL;  // continue until the NUL
    else
    {
 colnr_T i;

 // In a few cases the position can be beyond the end of the line.
 for (i = 0; i < pos->col; ++i)
     if (ptr[i] == NUL)
     {
  pos->col = i;
  break;
     }
 posptr = ptr + pos->col;
 if (has_mbyte)
     // always start on the first byte
  bwipe!
endfunc

func Test_using_invalid_visual_position()
  "" this was going beyond the end of the line
  new
  exe ""norm 0o000\<Esc>0\<C-V>$s0""
  /\%V
  bwipe!
endfunc

"" vim: shiftwidth=2 sts=2 expandtab

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    3950,
/**/
    3949,
/**/
"
Heap-based Buffer Overflow in mruby/mruby,CVE-2022-0080,CWE-122: Heap-based Buffer Overflow,"    /* already initialized proc */
    return;
  }
  if (!MRB_PROC_CFUNC_P(b) && b->body.irep) {
    mrb_irep_incref(mrb, (mrb_irep*)b->body.irep);
  }
  a->flags = b->flags;
  a->body = b->body;
  a->upper = b->upper;



  a->e.env = b->e.env;
  /* a->e.target_class = a->e.target_class; */
}
"
Out-of-bounds Read in vim/vim,CVE-2022-0128,CWE-125: Out-of-bounds Read," }

 // Check for ""++nr"" and ""--nr"".
 if (p == eap->cmd && p[0] != NUL && p[0] == p[1]
         && (*p == '+' || *p == '-'))
 {
     eap->cmdidx = *p == '+' ? CMD_increment : CMD_decrement;
     return eap->cmd + 2;
  unlet g:mydict
enddef

def Test_go_beyond_end_of_cmd()
  # this was reading the byte after the end of the line
  var lines =<< trim END
    def F()
      cal
    enddef
    defcompile
  END
  CheckScriptFailure(lines, 'E476:')
enddef

if has('python3')
  def Test_python3_heredoc()
    py3 << trim EOF

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    4009,
/**/
    4008,
/**/
 cmd = ea.cmd;
 if ((*cmd != '$' || starts_with_colon)
  && (starts_with_colon || !(*cmd == '\''
         || (cmd[0] != NUL && cmd[0] == cmd[1]
         && (*cmd == '+' || *cmd == '-')))))
 {
     ea.cmd = skip_range(ea.cmd, TRUE, NULL);
     if (ea.cmd > cmd)
"
Use After Free in radareorg/radare2,CVE-2022-0139,CWE-416: Use After Free,"  //delete all submaps that are completly included in sm
  RRBNode *next = r_rbnode_next (entry);
  // this can be optimized, there is no need to do search here
  bool a = r_crbtree_delete (bank->submaps, entry->data, _find_sm_by_from_vaddr_cb, NULL);
  if (!a) {
   break;
  }
  entry = next;
 }
 if (entry && r_io_submap_from (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {
"
Use After Free in vim/vim,CVE-2022-0156,CWE-416: Use After Free,"}

    void
ga_init2(garray_T *gap, size_t itemsize, int growsize)
{
    ga_init(gap);
    gap->ga_itemsize = itemsize;
 * When out of memory nothing changes and FAIL is returned.
 */
    int
ga_copy_string(garray_T *gap, char_u *p)
{
    char_u *cp = vim_strsave(p);

    return OK;
}

/*
 * Add string ""p"" to ""gap"".
 * When out of memory ""p"" is freed and FAIL is returned.
 */
    int
ga_add_string(garray_T *gap, char_u *p)
{
    if (ga_grow(gap, 1) == FAIL)
 return FAIL;
    ((char_u **)(gap->ga_data))[gap->ga_len++] = p;
    return OK;
}

/*
 * Concatenate a string to a growarray which contains bytes.
 * When ""s"" is NULL does not do anything.
    if (STRCMP(""RESET"", error) == 0)
 ga_clear_strings(&ignore_error_list);
    else
 ga_copy_string(&ignore_error_list, error);
}

    static int
void ga_clear_strings(garray_T *gap);
int ga_copy_strings(garray_T *from, garray_T *to);
void ga_init(garray_T *gap);
void ga_init2(garray_T *gap, size_t itemsize, int growsize);
int ga_grow(garray_T *gap, int n);
int ga_grow_inner(garray_T *gap, int n);
char_u *ga_concat_strings(garray_T *gap, char *sep);
int ga_copy_string(garray_T *gap, char_u *p);
int ga_add_string(garray_T *gap, char_u *p);
void ga_concat(garray_T *gap, char_u *s);
void ga_concat_len(garray_T *gap, char_u *s, size_t len);
char_u *get_scriptlocal_funcname(char_u *funcname);
char_u *save_function_name(char_u **name, int *is_global, int skip, int flags, funcdict_T *fudi);
void list_functions(regmatch_T *regmatch);
ufunc_T *define_function(exarg_T *eap, char_u *name_arg, garray_T *lines_to_free);
void ex_function(exarg_T *eap);
void ex_defcompile(exarg_T *eap);
int eval_fname_script(char_u *p);
  CheckScriptFailure(lines, 'E1173: Text found after endfunction: BBBB')
enddef

def Test_error_in_function_args()
  var lines =<< trim END
      def FirstFunction()
        def SecondFunction(J  =
        # Nois
        # one

         enddef|BBBB
      enddef
      # Compile all functions
      defcompile
  END
  CheckScriptFailure(lines, 'E488:')
enddef

def Test_return_type_wrong()
  CheckScriptFailure([
        'def Func(): number',
endfunc

def Run_Test_free_dict_while_in_funcstack()

  # this was freeing the TermRun() default argument dictionary while it was
  # still referenced in a funcstack_T
  var lines =<< trim END
 char_u     *line = NULL;

 ga_init2(&ga, sizeof(char_u *), 10);
 if (ga_copy_string(&ga, p) == FAIL)
     return retp;

 // If the argument ends in ""}"" it must have been concatenated already
      emsg(_(e_missing_rcurly));
      break;
  }
  if (ga_copy_string(&ga, line) == FAIL)
      break;
  if (*skipwhite(line) == '}')
      break;

/*
 * Handle line continuation in function arguments or body.
 * Get a next line, store it in ""eap"" if appropriate and put the line in
 * ""lines_to_free"" to free the line later.
 */
    static char_u *
get_function_line(
 exarg_T  *eap,
 garray_T *lines_to_free,
 int  indent,
 getline_opt_T getline_options)
{
 theline = eap->getline(':', eap->cookie, indent, getline_options);
    if (theline != NULL)
    {
 if (lines_to_free->ga_len > 0
  && *eap->cmdlinep == ((char_u **)lines_to_free->ga_data)
         [lines_to_free->ga_len - 1])
     *eap->cmdlinep = theline;
 ga_add_string(lines_to_free, theline);

    }

    return theline;
    garray_T *default_args,
    int  skip,
    exarg_T *eap,
    garray_T *lines_to_free)
{
    int  mustend = FALSE;
    char_u *arg;
    && (*p == NUL || (VIM_ISWHITE(*whitep) && *p == '#')))
 {
     // End of the line, get the next one.
     char_u *theline = get_function_line(eap, lines_to_free, 0,
         GETLINE_CONCAT_CONT);

     if (theline == NULL)
 exarg_T     *eap,
 garray_T    *newlines,
 char_u     *line_arg_in,
 garray_T    *lines_to_free)
{
    linenr_T sourcing_lnum_top = SOURCING_LNUM;
    linenr_T sourcing_lnum_off;
 }
 else
 {
     theline = get_function_line(eap, lines_to_free, indent,
             getline_options);
 }
 if (KeyTyped)
      {
   // Another command follows. If the line came from ""eap""
   // we can simply point into it, otherwise we need to
   // change ""eap->cmdlinep"" to point to the last fetched
   // line.
   eap->nextcmd = nextcmd;
   if (lines_to_free->ga_len > 0
    && *eap->cmdlinep !=
         ((char_u **)lines_to_free->ga_data)
         [lines_to_free->ga_len - 1])
   {
       // *cmdlinep will be freed later, thus remove the
       // line from lines_to_free.
       vim_free(*eap->cmdlinep);
       *eap->cmdlinep = ((char_u **)lines_to_free->ga_data)
         [lines_to_free->ga_len - 1];
       --lines_to_free->ga_len;
   }
      }
      break;
    garray_T newlines;
    char_u *cmdline = NULL;
    int  ret = FAIL;

    partial_T *pt;
    char_u *name;
    int  lnum_save = -1;
    }

    ga_init2(&newlines, (int)sizeof(char_u *), 10);
    if (get_function_body(&eap, &newlines, NULL,
          &evalarg->eval_tofree_ga) == FAIL)


 goto erret;


    // When inside a lambda must add the function lines to evalarg.eval_ga.
    evalarg->eval_break_count += newlines.ga_len;
 {
     ((char_u **)(tfgap->ga_data))[tfgap->ga_len++] = cmdline;
     evalarg->eval_using_cmdline = TRUE;


 }
    }
    else
erret:
    if (lnum_save >= 0)
 SOURCING_LNUM = lnum_save;

    ga_clear_strings(&newlines);
    if (newargs != NULL)
 ga_clear_strings(newargs);
 * "":function"" also supporting nested "":def"".
 * When ""name_arg"" is not NULL this is a nested function, using ""name_arg"" for
 * the function name.
 * ""lines_to_free"" is a list of strings to be freed later.
 * Returns a pointer to the function or NULL if no function defined.
 */
    ufunc_T *
define_function(exarg_T *eap, char_u *name_arg, garray_T *lines_to_free)
{
    int  j;
    int  c;
    if (get_function_args(&p, ')', &newargs,
   eap->cmdidx == CMD_def ? &argtypes : NULL, FALSE,
    NULL, &varargs, &default_args, eap->skip,
    eap, lines_to_free) == FAIL)
 goto errret_2;
    whitep = p;


    // Do not define the function when getting the body fails and when
    // skipping.
    if (get_function_body(eap, &newlines, line_arg, lines_to_free) == FAIL
     || eap->skip)
 goto erret;

    void
ex_function(exarg_T *eap)
{
    garray_T lines_to_free;

    ga_init2(&lines_to_free, sizeof(char_u *), 50);
    (void)define_function(eap, NULL, &lines_to_free);
    ga_clear_strings(&lines_to_free);
}

/*

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    4040,
/**/
    4039,
/**/
 * Compile a nested :def command.
 */
    static char_u *
compile_nested_function(exarg_T *eap, cctx_T *cctx, garray_T *lines_to_free)
{
    int  is_global = *eap->arg == 'g' && eap->arg[1] == ':';
    char_u *name_start = eap->arg;
 goto theend;
    }

    ufunc = define_function(eap, lambda_name, lines_to_free);
    if (ufunc == NULL)
    {
 r = eap->skip ? OK : FAIL;
 cctx_T  *outer_cctx)
{
    char_u *line = NULL;
    garray_T lines_to_free;
    char_u *p;
    char *errormsg = NULL; // error message
    cctx_T cctx;
#endif
    int  debug_lnum = -1;

    // allocated lines are freed at the end
    ga_init2(&lines_to_free, sizeof(char_u *), 50);

    // When using a function that was compiled before: Free old instructions.
    // The index is reused.  Otherwise add a new entry in ""def_functions"".
    if (ufunc->uf_dfunc_idx > 0)
     if (line != NULL)
     {
  line = vim_strsave(line);
  if (ga_add_string(&lines_to_free, line) == FAIL)
      goto erret;
     }
 }

     case CMD_def:
     case CMD_function:
      ea.arg = p;
      line = compile_nested_function(&ea, &cctx, &lines_to_free);
      break;

     case CMD_return:
    if (do_estack_push)
 estack_pop();

    ga_clear_strings(&lines_to_free);
    free_imported(&cctx);
    free_locals(&cctx);
    ga_clear(&cctx.ctx_type_stack);
"
Heap-based Buffer Overflow in vim/vim,CVE-2022-0158,CWE-122: Heap-based Buffer Overflow,"  CheckDefAndScriptSuccess(lines)

  CheckDefAndScriptFailure([""var x = $$$""], ['E1002:', 'E15:'], 1)
  CheckDefAndScriptFailure([""$""], ['E1002:', 'E15:'], 1)
enddef

def Test_expr7_register()

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    4049,
/**/
    4048,
/**/
    len = get_env_len(arg);
    if (len == 0)
    {
 semsg(_(e_syntax_error_at_str), start);
 return FAIL;
    }

"
Out-of-bounds Read in radareorg/radare2,CVE-2022-0173,CWE-125: Out-of-bounds Read,"  //delete all submaps that are completly included in sm
  RRBNode *next = r_rbnode_next (entry);
  // this can be optimized, there is no need to do search here
  bool a = r_crbtree_delete (bank->submaps, entry->data, _find_sm_by_from_vaddr_cb, NULL);
  if (!a) {
   break;
  }
  entry = next;
 }
 if (entry && r_io_submap_from (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {
"
Heap-based Buffer Overflow in vim/vim,CVE-2022-0213,CWE-122: Heap-based Buffer Overflow," p = NameBuff;
 len = (int)STRLEN(p);

 if ((bt_help(wp->w_buffer)
#ifdef FEAT_QUICKFIX
      || wp->w_p_pvw
#endif
      || bufIsChanged(wp->w_buffer)
      || wp->w_buffer->b_p_ro)
  && len < MAXPATHL - 1)
     *(p + len++) = ' ';
 if (bt_help(wp->w_buffer))
 {
  bwipe!
endfunc

"" Weird long file name was going over the end of NameBuff
func Test_edit_overlong_file_name()
  CheckUnix

  file 0000000000000000000000000000
  file %%%%%%%%%%%%%%%%%%%%%%%%%%
  file %%%%%%
  set readonly
  set ls=2 

  redraw!
  set noreadonly ls&
  bwipe!
endfunc


"" vim: shiftwidth=2 sts=2 expandtab

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    4074,
/**/
    4073,
/**/
"
NULL Pointer Dereference in mruby/mruby,CVE-2022-0240,CWE-476: NULL Pointer Dereference,"{
  struct RClass *sc, *c;

  mrb_assert(o->c);
  if (o->c->tt == MRB_TT_SCLASS) return;
  sc = MRB_OBJ_ALLOC(mrb, MRB_TT_SCLASS, mrb->class_class);
  sc->flags |= MRB_FL_CLASS_IS_INHERITED;
    break;
  }
  obj = mrb_basic_ptr(v);
  if (obj->c == NULL) return NULL;
  prepare_singleton_class(mrb, obj);
  return obj->c;
}
"
Heap-based Buffer Overflow in vim/vim,CVE-2022-0261,CWE-122: Heap-based Buffer Overflow,"     if (b_insert)
     {
  off = (*mb_head_off)(oldp, oldp + offset + spaces);
  spaces -= off;
  count -= off;
     }
     else
     {
  // spaces fill the gap, the character that's at the edge moves
  // right
  off = (*mb_head_off)(oldp, oldp + offset);
  offset -= off;
     }


 }
 if (spaces < 0)  // can happen when the cursor was moved
     spaces = 0;

 // Make sure the allocated size matches what is actually copied below.
 newp = alloc(STRLEN(oldp) + spaces + s_len
      + (spaces > 0 && !bdp->is_short ? ts_val - spaces : 0)
          + count + 1);
 if (newp == NULL)
     continue;

 // copy up to shifted part
 mch_memmove(newp, oldp, (size_t)offset);
 oldp += offset;

 // insert pre-padding
 mch_memmove(newp + startcol, s, (size_t)s_len);
 offset += s_len;

 if (spaces > 0 && !bdp->is_short)
 {
     if (*oldp == TAB)
     {
  // insert post-padding
  vim_memset(newp + offset + spaces, ' ',
          (size_t)(ts_val - spaces));
  // we're splitting a TAB, don't copy it
  oldp++;
  // We allowed for that TAB, remember this now
  count++;
     }
     else
  // Not a TAB, no extra spaces
  count = spaces;
 }

 if (spaces > 0)
      oap->start_vcol = t;
  }
  else if (oap->op_type == OP_APPEND
   && oap->start.col + oap->start.coladd
    >= curbuf->b_op_start_orig.col
           + curbuf->b_op_start_orig.coladd)
  {
  au! BufNew
endfunc

func Test_visual_block_append_invalid_char()
  "" this was going over the end of the line
  new
  call setline(1, ['    let xxx', 'xxxxx', 'xxxxxxxxxxx'])
  exe ""normal 0\<C-V>jjA-\<Esc>""
  call assert_equal([' -   let xxx', 'xxxxx   -', 'xxxxxxxx-xxx'], getline(1, 3))
  bwipe!
endfunc

func Test_visual_reselect_with_count()
  "" this was causing an illegal memory access
  let lines =<< trim END

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    4120,
/**/
    4119,
/**/
"
Heap-based Buffer Overflow in vim/vim,CVE-2022-0318,CWE-122: Heap-based Buffer Overflow," }

 if (has_mbyte && spaces > 0)
     // avoid copying part of a multi-byte character
     offset -= (*mb_head_off)(oldp, oldp + offset);
















 if (spaces < 0)  // can happen when the cursor was moved
     spaces = 0;

  call delete('XvisualReselect')
endfunc

func Test_visual_block_insert_round_off()
  new
  "" The number of characters are tuned to fill a 4096 byte allocated block,
  "" so that valgrind reports going over the end.
  call setline(1, ['xxxxx', repeat('0', 1350), ""\t"", repeat('x', 60)])
  exe ""normal gg0\<C-V>GI"" .. repeat('0', 1320) .. ""\<Esc>""
  bwipe!
endfunc


"" vim: shiftwidth=2 sts=2 expandtab

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    4151,
/**/
    4150,
/**/
"
Out-of-bounds Read in vim/vim,CVE-2022-0319,CWE-125: Out-of-bounds Read,"  bwipe!
endfunc

"" this was causing an ml_get error
func Test_visual_exchange_windows()
  enew!
  new
  call setline(1, ['foo', 'bar'])
  exe ""normal G\<C-V>gg\<C-W>\<C-X>OO\<Esc>""
  bwipe!
  bwipe!
endfunc


"" vim: shiftwidth=2 sts=2 expandtab

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    4154,
/**/
    4153,
/**/

    (void)win_comp_pos();  // recompute window positions

    if (wp->w_buffer != curbuf)
 reset_VIsual_and_resel();
    else if (VIsual_active)
 wp->w_cursor = curwin->w_cursor;

    win_enter(wp, TRUE);
    redraw_all_later(NOT_VALID);
}
win_alloc_lines(win_T *wp)
{
    wp->w_lines_valid = 0;
    wp->w_lines = ALLOC_CLEAR_MULT(wline_T, Rows);
    if (wp->w_lines == NULL)
 return FAIL;
    return OK;
"
NULL Pointer Dereference in mruby/mruby,CVE-2022-0326,CWE-476: NULL Pointer Dereference,"    }
  }
  if (update) {
    if (val && len > 0) {
      pop_n(len*2+1);
      genop_2(s, OP_HASHADD, cursp(), len);
      push();
    }
    return -1;                  /* variable length */
  }

  return len;
}

"
Access of Memory Location Before Start of Buffer in vim/vim,CVE-2022-0351,CWE-786: Access of Memory Location Before Start of Buffer," INIT(= N_(""E1043: Invalid command after :export""));
EXTERN char e_export_with_invalid_argument[]
 INIT(= N_(""E1044: Export with invalid argument""));
// E1045 not used
// E1046 not used
EXTERN char e_syntax_error_in_import_str[]
 INIT(= N_(""E1047: Syntax error in import: %s""));
EXTERN char e_item_not_found_in_script_str[]
// E1080 unused
EXTERN char e_cannot_unlet_str[]
 INIT(= N_(""E1081: Cannot unlet %s""));
// E1082 unused
EXTERN char e_missing_backtick[]
 INIT(= N_(""E1083: Missing backtick""));
EXTERN char e_cannot_delete_vim9_script_function_str[]
 INIT(= N_(""E1140: :for argument must be a sequence of lists""));
EXTERN char e_indexable_type_required[]
 INIT(= N_(""E1141: Indexable type required""));
// E1142 unused
EXTERN char e_empty_expression_str[]
 INIT(= N_(""E1143: Empty expression: \""%s\""""));
EXTERN char e_command_str_not_followed_by_white_space_str[]
 INIT(= N_(""E1167: Argument name shadows existing variable: %s""));
EXTERN char e_argument_already_declared_in_script_str[]
 INIT(= N_(""E1168: Argument already declared in the script: %s""));
EXTERN char e_expression_too_recursive_str[]
 INIT(= N_(""E1169: Expression too recursive: %s""));
EXTERN char e_cannot_use_hash_curly_to_start_comment[]
 INIT(= N_(""E1170: Cannot use #{ to start a comment""));
EXTERN char e_missing_end_block[]
    char_u *start_leader, *end_leader;
    int  ret = OK;
    char_u *alias;
    static int recurse = 0;

    /*
     * Initialise variable so that clear_tv() can't mistake this for a
 return FAIL;
    }

    // Limit recursion to 1000 levels.  At least at 10000 we run out of stack
    // and crash.
    if (recurse == 1000)
    {
 semsg(_(e_expression_too_recursive_str), *arg);
 return FAIL;
    }
    ++recurse;

    switch (**arg)
    {
    /*
     */
    if (ret == OK && evaluate && end_leader > start_leader)
 ret = eval7_leader(rettv, FALSE, start_leader, &end_leader);

    --recurse;
    return ret;
}

  unlet g:gvar
endfunc

func Test_deep_recursion()
  "" this was running out of stack
  call assert_fails(""exe 'if ' .. repeat('(', 1002)"", 'E1169: Expression too recursive: ((')
endfunc

"" vim: shiftwidth=2 sts=2 expandtab

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    4206,
/**/
    4205,
/**/
"
Heap-based Buffer Overflow in vim/vim,CVE-2022-0359,CWE-122: Heap-based Buffer Overflow,"    ccline.cmdindent = (firstc > 0 ? indent : 0);

    // alloc initial ccline.cmdbuff
    alloc_cmdbuff(indent + 50);
    if (ccline.cmdbuff == NULL)
 return FAIL;
    ccline.cmdlen = ccline.cmdpos = 0;
  call delete('Xexmodescript')
endfunc

func Test_ex_mode_large_indent()
  new
  set ts=500 ai
  call setline(1, ""\t"")
  exe ""normal gQi\<CR>.""
  set ts=8 noai
  bwipe!
endfunc


"" vim: shiftwidth=2 sts=2 expandtab

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    4214,
/**/
    4213,
/**/
"
Heap-based Buffer Overflow in vim/vim,CVE-2022-0361,CWE-122: Heap-based Buffer Overflow,"    }

    appended_lines_mark(n, count);
    if (VIsual_active)
 check_pos(curbuf, &VIsual);

    msgmore((long)count);
}
  bwipe!
endfunc

"" this was leaving the end of the Visual area beyond the end of a line
func Test_visual_ex_copy_line()
  new
  call setline(1, [""aaa"", ""bbbbbbbbbxbb""])
  /x
  exe ""normal ggvjfxO""
  t0
  normal gNU
  bwipe!
endfunc


"" vim: shiftwidth=2 sts=2 expandtab

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    4215,
/**/
    4214,
/**/
"
Out-of-bounds Read in vim/vim,CVE-2022-0368,CWE-125: Out-of-bounds Read,"  bwipe!
endfunc

"" This was leaving the end of the Visual area beyond the end of a line.
"" Set 'undolevels' to start a new undo block.
func Test_visual_undo_deletes_last_line()
  new
  call setline(1, [""aaa"", ""ccc"", ""dyd""])
  set undolevels=100
  exe ""normal obbbbbbbbbxbb\<Esc>""
  set undolevels=100
  /y
  exe ""normal ggvjfxO""
  undo
  normal gNU
  bwipe!
endfunc


"" vim: shiftwidth=2 sts=2 expandtab
 }
    }
#endif
    if (VIsual_active)
 check_pos(curbuf, &VIsual);

    smsg_attr_keep(0, _(""%ld %s; %s #%ld  %s""),
     u_oldcount < 0 ? -u_oldcount : u_oldcount,

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    4217,
/**/
    4216,
/**/
"
Heap-based Buffer Overflow in vim/vim,CVE-2022-0392,CWE-122: Heap-based Buffer Overflow,"      break;

  case PASTE_EX:
      // add one for the NUL that is going to be appended
      if (gap != NULL && ga_grow(gap, idx + 1) == OK)
      {
   mch_memmove((char *)gap->ga_data + gap->ga_len,
            buf, (size_t)idx);
  unlet! foo
  call feedkeys(""Qlet foo=\""\<Esc>[200~foo\<CR>bar\<Esc>[201~\""\<CR>vi\<CR>"", 'xt')
  call assert_equal(""foo\rbar"", foo)

  "" pasting more than 40 bytes
  exe ""norm Q\<PasteStart>0000000000000000000000000000000000000000000000000000000000000000000000\<C-C>""
endfunc

func Test_paste_onechar()

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    4218,
/**/
    4217,
/**/
"
Out-of-bounds Read in vim/vim,CVE-2022-0393,CWE-125: Out-of-bounds Read,"    static void
delete_buff_tail(buffheader_T *buf, int slen)
{
    int len;

    if (buf->bh_curr == NULL || buf->bh_curr->b_str == NULL)
 return;  // nothing to delete
    len = (int)STRLEN(buf->bh_curr->b_str);
    if (len >= slen)
    {
 buf->bh_curr->b_str[len - slen] = NUL;
  bwipe!
endfunc

func Test_record_in_select_mode()
  new
  call setline(1, 'text')
  sil norm q00
  sil norm q
  call assert_equal('0ext', getline(1))
  bwipe!
endfunc

"" Make sure that y_append is correctly reset
"" and the previous register is working as expected
func Test_register_y_append_reset()

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    4233,
/**/
    4232,
/**/
"
Heap-based Buffer Overflow in vim/vim,CVE-2022-0407,CWE-122: Heap-based Buffer Overflow,"    {
 int s = bd->textlen + bd->endspaces;

 while (s > 0 && VIM_ISWHITE(*(bd->textstart + s - 1)))
 {
     s = s - (*mb_head_off)(bd->textstart, bd->textstart + s - 1) - 1;
     pnew--;
  bw!
endfunc

func Test_visual_block_yank_zy()
  new
  "" this was reading before the start of the line
  exe ""norm o\<C-T>\<Esc>\<C-V>zy""
  bwipe!
endfunc

func Test_visual_block_with_virtualedit()
  CheckScreendump


static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    4219,
/**/
    4218,
/**/
"
Stack-based Buffer Overflow in vim/vim,CVE-2022-0408,CWE-121: Stack-based Buffer Overflow,"
// Check the maximum score, if we go over it we won't try this change.
#define TRY_DEEPER(su, stack, depth, add) \
    (depth < MAXWLEN && stack[depth].ts_score + (add) < su->su_maxscore)

/*
 * Try finding suggestions by adding/removing/swapping letters.
    char_u changename[MAXWLEN][80];
#endif
    int  breakcheckcount = 1000;
#ifdef FEAT_RELTIME
    proftime_T time_limit;
#endif
    int  compound_ok;

    // Go through the whole case-fold tree, try changes at each node.
     sp->ts_state = STATE_START;
 }
    }
#ifdef FEAT_RELTIME
    // The loop may take an indefinite amount of time. Break out after five
    // sectonds. TODO: add an option for the time limit.
    profile_setlimit(5000, &time_limit);
#endif

    // Loop to find all suggestions.  At each round we either:
    // - For the current state try one operation, advance ""ts_curi"",

  // At end of a prefix or at start of prefixtree: check for
  // following word.
  if (depth < MAXWLEN
       && (byts[arridx] == 0 || n == (int)STATE_NOPREFIX))
  {
      // Set su->su_badflags to the caps type at this position.
      // Use the caps type until here for the prefix itself.
     {
  ui_breakcheck();
  breakcheckcount = 1000;
#ifdef FEAT_RELTIME
  if (profile_passed_limit(&time_limit))
      got_int = TRUE;
#endif
     }
 }
    }
  set nospell
endfunc

func Test_spellsuggest_too_deep()
  "" This was incrementing ""depth"" over MAXWLEN.
  new
  norm s000G00ý000000000000
  sil norm ..vzG................vvzG0     v z=
  bwipe!
endfunc

func LoadAffAndDic(aff_contents, dic_contents)
  set enc=latin1
  set spellfile=

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    4247,
/**/
    4246,
/**/
"
Use After Free in vim/vim,CVE-2022-0413,CWE-416: Use After Free,"    int  save_do_all;  // remember user specified 'g' flag
    int  save_do_ask;  // remember user specified 'c' flag
    char_u *pat = NULL, *sub = NULL; // init for GCC
    char_u *sub_copy = NULL;
    int  delimiter;
    int  sublen;
    int  got_quit = FALSE;
    sub_firstline = NULL;

    /*
     * If the substitute pattern starts with ""\="" then it's an expression.
     * Make a copy, a recursive function may free it.
     * Otherwise, '~' in the substitute pattern is replaced with the old
     * pattern.  We do it here once to avoid it to be replaced over and over
     * again.
     */
    if (sub[0] == '\\' && sub[1] == '=')
    {
 sub = vim_strsave(sub);
 if (sub == NULL)
     return;
 sub_copy = sub;
    }
    else
 sub = regtilde(sub, magic_isset());

    /*
#endif

    vim_regfree(regmatch.regprog);
    vim_free(sub_copy);

    // Restore the flag values, they can be used for "":&&"".
    subflags.do_all = save_do_all;
  bw!
endfunc

"" This was using ""old_sub"" after it was freed.
func Test_using_old_sub()
  set compatible maxfuncdepth=10
  new
  call setline(1, 'some text.')
  func Repl()
    ~
    s/
  endfunc
  silent!  s/\%')/\=Repl()

  delfunc Repl
  bwipe!
  set nocompatible
endfunc


"" vim: shiftwidth=2 sts=2 expandtab

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    4253,
/**/
    4252,
/**/
"
Heap-based Buffer Overflow in vim/vim,CVE-2022-0417,CWE-122: Heap-based Buffer Overflow," int n = atoi((char *)cp);

 // Catch negative values, overflow and ridiculous big values.
 if (n < 0 || n > TABSTOP_MAX)
 {
     semsg(_(e_invalid_argument_str), cp);
     vim_free(*array);
 emsg(_(e_argument_must_be_positive));
 return;
    }
    if (new_ts < 0 || new_ts > TABSTOP_MAX)
    {
 semsg(_(e_invalid_argument_str), eap->arg);
 return;
 errmsg = e_argument_must_be_positive;
 curbuf->b_p_ts = 8;
    }
    else if (curbuf->b_p_ts > TABSTOP_MAX)
    {
 errmsg = e_invalid_argument;
 curbuf->b_p_ts = 8;
    }
    if (p_tm < 0)
    {
 errmsg = e_argument_must_be_positive;
     if (p_vsts && p_vsts != empty_option)
  (void)tabstop_set(p_vsts, &buf->b_p_vsts_array);
     else
  buf->b_p_vsts_array = NULL;
     buf->b_p_vsts_nopaste = p_vsts_nopaste
     ? vim_strsave(p_vsts_nopaste) : NULL;
#endif
     if (buf->b_p_vsts)
  free_string_option(buf->b_p_vsts);
     buf->b_p_vsts = empty_option;
     VIM_CLEAR(buf->b_p_vsts_array);


#endif
 }

  free_string_option(buf->b_p_vsts);
     buf->b_p_vsts = buf->b_p_vsts_nopaste
    ? vim_strsave(buf->b_p_vsts_nopaste) : empty_option;
     vim_free(buf->b_p_vsts_array);

     if (buf->b_p_vsts && buf->b_p_vsts != empty_option)
  (void)tabstop_set(buf->b_p_vsts, &buf->b_p_vsts_array);
     else
  buf->b_p_vsts_array = NULL;
#endif
 }

  call assert_fails('set shiftwidth=-1', 'E487:')
  call assert_fails('set sidescroll=-1', 'E487:')
  call assert_fails('set tabstop=-1', 'E487:')
  call assert_fails('set tabstop=10000', 'E474:')
  call assert_fails('set tabstop=5500000000', 'E474:')
  call assert_fails('set textwidth=-1', 'E487:')
  call assert_fails('set timeoutlen=-1', 'E487:')
  call assert_fails('set updatecount=-1', 'E487:')

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    4245,
/**/
    4244,
/**/

#define DICT_MAXNEST 100 // maximum nesting of lists and dicts

#define TABSTOP_MAX 9999

#ifdef FEAT_CLIPBOARD

// VIM_ATOM_NAME is the older Vim-specific selection type for X11.  Still
"
NULL Pointer Dereference in radareorg/radare2,CVE-2022-0419,CWE-476: NULL Pointer Dereference,"
beach:
 r_buf_free (fbuf);
 if (obj) {
  obj->cache_buf = NULL;
 }
 MACH0_(mach0_free) (main_mach0);
 return false;
}
"
Use After Free in vim/vim,CVE-2022-0443,CWE-416: Use After Free,"#endif
    bufref_T newbufref;
    bufref_T prevbufref;
    int  valid;

    setpcmark();
    if ((cmdmod.cmod_flags & CMOD_KEEPALT) == 0)
    // An autocommand may have deleted ""buf"", already entered it (e.g., when
    // it did "":bunload"") or aborted the script processing.
    // If curwin->w_buffer is null, enter_buffer() will make it valid again
    valid = buf_valid(buf);
    if ((valid && buf != curbuf
#ifdef FEAT_EVAL
  && !aborting()
#endif
 ) || curwin->w_buffer == NULL)
    {
 // If the buffer is not valid but curwin->w_buffer is NULL we must
 // enter some buffer.  Using the last one is hopefully OK.
 if (!valid)
     enter_buffer(lastbuf);
 else
     enter_buffer(buf);
#ifdef FEAT_SYN_HL
 if (old_tw != curbuf->b_p_tw)
     check_colorcolumn(curwin);
    clear_string_option(&buf->b_p_vsts);
    vim_free(buf->b_p_vsts_nopaste);
    buf->b_p_vsts_nopaste = NULL;
    VIM_CLEAR(buf->b_p_vsts_array);

    clear_string_option(&buf->b_p_vts);
    VIM_CLEAR(buf->b_p_vts_array);
#endif
  call assert_fails('lrewind', 'E924:')

  augroup! testgroup
  delfunc R
endfunc

func Test_locationlist_cross_tab_jump()
  %bw!
endfunc

"" Weird sequence of commands that caused entering a wiped-out buffer
func Test_lopen_bwipe()
  func R()
    silent! tab lopen
    e x
    silent! lfile
  endfunc

  cal R()
  cal R()
  cal R()
  bw!
  delfunc R
endfunc


"" vim: shiftwidth=2 sts=2 expandtab

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    4281,
/**/
    4280,
/**/
"
Denial of Service in radareorg/radare2,CVE-2022-0476,CWE-400: Denial of Service," return true;
}

static struct minidump_module *read_module(RBuffer *b, ut64 addr) {
 st64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);
 if (r_buf_seek (b, addr, R_BUF_SET) == -1) {
  return NULL;
 }
 struct minidump_module *module = R_NEW0 (struct minidump_module);
 if (!module) {
  return NULL;
 }
 module->base_of_image = r_buf_read_le64 (b);
 module->size_of_image = r_buf_read_le32 (b);
 module->check_sum = r_buf_read_le32 (b);
 module->reserved_0 = r_buf_read_le64 (b);
 module->reserved_1 = r_buf_read_le64 (b);
 r_buf_seek (b, o_addr, R_BUF_SET);
 return module;
}

static void read_memory64_list(RBuffer *b, ut64 addr, struct minidump_memory64_list *memory64_list) {
   0);

  offset = entry->location.rva + sizeof (module_list);
  for (i = 0; i < module_list.number_of_modules && offset < obj->size; i++) {
   struct minidump_module *module = read_module (obj->b, offset);
   if (!module) {
    break; 
   }

   r_list_append (obj->streams.modules, module);
   offset += sizeof (*module);
  }
   0);

  offset = entry->location.rva + sizeof (memory_list);
  for (i = 0; i < memory_list.number_of_memory_ranges && offset < obj->size; i++) {
   struct minidump_memory_descriptor *desc = R_NEW (struct minidump_memory_descriptor);
   if (!desc) {
    break;
   0);

  offset = entry->location.rva + sizeof (thread_ex_list);
  for (i = 0; i < thread_ex_list.number_of_threads && offset < obj->size; i++) {
   struct minidump_thread_ex *thread = R_NEW (struct minidump_thread_ex);
   if (!thread) {
    break;

  obj->streams.memories64.base_rva = memory64_list.base_rva;
  offset = entry->location.rva + sizeof (memory64_list);
  for (i = 0; i < memory64_list.number_of_memory_ranges && offset < obj->size; i++) {
   struct minidump_memory_descriptor64 *desc = R_NEW (struct minidump_memory_descriptor64);
   if (!desc) {
    break;
   ""SizeOfHeader SizeOfEntry NumberOfEntries"", 0);

  offset = entry->location.rva + sizeof (unloaded_module_list);
  for (i = 0; i < unloaded_module_list.number_of_entries && offset < obj->size; i++) {
   struct minidump_unloaded_module *module = R_NEW (struct minidump_unloaded_module);
   if (!module) {
    break;
   0);

  offset = entry->location.rva + sizeof (memory_info_list);
  for (i = 0; i < memory_info_list.number_of_entries && offset < obj->size; i++) {
   struct minidump_memory_info *info = R_NEW (struct minidump_memory_info);
   if (!info) {
    break;
   ""SizeOfHeader SizeOfEntry NumberOfEntries"", 0);

  offset = entry->location.rva + sizeof (thread_info_list);
  for (i = 0; i < thread_info_list.number_of_entries && offset < obj->size; i++) {
   struct minidump_thread_info *info = R_NEW (struct minidump_thread_info);
   if (!info) {
    break;
   ""SizeOfHeader SizeOfEntry NumberOfEntries Reserved"", 0);

  offset = entry->location.rva + sizeof (handle_operation_list);
  for (i = 0; i < handle_operation_list.number_of_entries && offset < obj->size; i++) {
   struct avrf_handle_operation *op = R_NEW (struct avrf_handle_operation);
   if (!op) {
    break;
   ""TokenListSize TokenListEntries ListHeaderSize ElementHeaderSize"", 0);

  offset = entry->location.rva + sizeof (token_info_list);
  for (i = 0; i < token_info_list.number_of_entries && offset < obj->size; i++) {
   struct minidump_token_info *info = R_NEW (struct minidump_token_info);
   if (!info) {
    break;
"
NULL Pointer Dereference in mruby/mruby,CVE-2022-0481,CWE-476: NULL Pointer Dereference,"
  while (tree) {
    if (nint(tree->car->car->car) == NODE_KW_REST_ARGS) {
      if (val && len > 0) {
        pop_n(len*2);
        if (!update) {
          genop_2(s, OP_HASH, cursp(), len);
        push();
      }
      codegen(s, tree->car->cdr, val);
      if (val && (len > 0 || update)) {
        pop(); pop();
        genop_1(s, OP_HASHCAT, cursp());
        push();
"
Heap-based Buffer Overflow in radareorg/radare2,CVE-2022-0518,CWE-122: Heap-based Buffer Overflow," ut64 offset = 0, curpos;
 attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 offset += 6;
 if (buf_offset + offset + 8 > sz) {
  eprintf (""Invalid amount of inner classes\n"");
  return NULL;
 }
 if (attr == NULL) {
  // TODO eprintf
  return attr;
 attr->info.inner_classes_attr.classes = r_list_newf (r_bin_java_inner_classes_attr_entry_free);
 for (i = 0; i < attr->info.inner_classes_attr.number_of_classes; i++) {
  curpos = buf_offset + offset;
  if (buf_offset + offset + 8 > sz) {
   eprintf (""Invalid amount of inner classes\n"");
   break;
  }
"
Buffer Access with Incorrect Length Value in radareorg/radare2,CVE-2022-0519,CWE-805: Buffer Access with Incorrect Length Value,"
R_API RBinJavaAttrInfo *r_bin_java_enclosing_methods_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut64 offset = 6;
 if (sz < 8) {
  return NULL;
 }
 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 if (!attr || sz < 10) {
  free (attr);

R_API RBinJavaAttrInfo *r_bin_java_inner_classes_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 RBinJavaClassesAttribute *icattr;

 RBinJavaCPTypeObj *obj;
 ut32 i = 0;
 ut64 offset = 0, curpos;
 if (sz < 8) {



  return NULL;
 }
 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 if (!attr) {
  return NULL;
 }
 offset += 6;
 attr->type = R_BIN_JAVA_ATTR_TYPE_INNER_CLASSES_ATTR;
 attr->info.inner_classes_attr.number_of_classes = R_BIN_JAVA_USHORT (buffer, offset);
 offset += 2;
 attr->info.inner_classes_attr.classes = r_list_newf (r_bin_java_inner_classes_attr_entry_free);
 for (i = 0; i < attr->info.inner_classes_attr.number_of_classes; i++) {
  curpos = buf_offset + offset;
  if (offset + 8 > sz) {
   eprintf (""Invalid amount of inner classes\n"");
   break;
  }

R_API RBinJavaAttrInfo *r_bin_java_source_debug_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut64 offset = 6;
 if (sz < 8) {
  return NULL;
 }
 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 if (!attr) {
  return NULL;
R_API RBinJavaAttrInfo *r_bin_java_local_variable_table_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 RBinJavaLocalVariableAttribute *lvattr;
 ut64 curpos = 0, offset = 6;

 ut32 i = 0;
 if (!bin || !buffer || sz < 8) {
  return NULL;
 }
 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 if (!attr) {
  return NULL;
 }
}

R_API RBinJavaAttrInfo *r_bin_java_local_variable_type_table_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 if (sz < 8) {
  return NULL;
 }
 RBinJavaLocalVariableTypeAttribute *lvattr;
 ut64 offset = 6;
 ut32 i = 0;
}

R_API RBinJavaAttrInfo *r_bin_java_source_code_file_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 if (!sz || sz == UT64_MAX) {
  return NULL;
 }
#if 0
 /// XXX this breaks tests
 if (sz < 8) {
  return NULL;
 }
#endif
 ut64 offset = 0;
 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 offset += 6;
 if (attr) {
  attr->type = R_BIN_JAVA_ATTR_TYPE_SOURCE_FILE_ATTR;
  attr->info.source_file_attr.sourcefile_idx = R_BIN_JAVA_USHORT (buffer, offset);
  offset += 2;
  attr->size = offset;
  // IFDBG r_bin_java_print_source_code_file_attr_summary(attr);
 }






 return attr;
}

}

R_API RBinJavaAttrInfo *r_bin_java_synthetic_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 if (sz < 8) {
  return NULL;
 }
 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 if (!attr) {
  return NULL;
 }

 attr->type = R_BIN_JAVA_ATTR_TYPE_SYNTHETIC_ATTR;
 attr->size = 6;
 return attr;
}


R_API RBinJavaVerificationObj *r_bin_java_verification_info_from_type(RBinJavaObj *bin, R_BIN_JAVA_STACKMAP_TYPE type, ut32 value) {
 RBinJavaVerificationObj *se = R_NEW0 (RBinJavaVerificationObj);
 if (se) {
  se->tag = type;
  if (se->tag == R_BIN_JAVA_STACKMAP_OBJECT) {
   se->info.obj_val_cp_idx = (ut16) value;
  } else if (se->tag == R_BIN_JAVA_STACKMAP_UNINIT) {
   se->info.uninit_offset = (ut16) value;
  }






 }
 return se;
}

R_API RBinJavaVerificationObj *r_bin_java_read_from_buffer_verification_info_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {
 if (sz < 8) {
  return NULL;
 }
 ut64 offset = 0;
 RBinJavaVerificationObj *se = R_NEW0 (RBinJavaVerificationObj);
 if (!se) {
}

R_API RBinJavaStackMapFrame *r_bin_java_stack_map_frame_new(ut8 *buffer, ut64 sz, RBinJavaStackMapFrame *p_frame, ut64 buf_offset) {
 if (sz < 8) {
  return NULL;
 }
 RBinJavaStackMapFrame *stack_frame = r_bin_java_default_stack_frame ();
 RBinJavaVerificationObj *se = NULL;
 ut64 offset = 0;
R_API RBinJavaAttrInfo *r_bin_java_stack_map_table_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut32 i = 0;
 ut64 offset = 0;
 if (sz < 8) {
  return NULL;
 }
 RBinJavaStackMapFrame *stack_frame = NULL, *new_stack_frame = NULL;
 if (sz < 10) {
  return NULL;
 }
 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 offset += 6;
 IFDBG eprintf (""r_bin_java_stack_map_table_attr_new: New stack map allocated.\n"");
 if (!attr) {
  return NULL;
 }

R_API RBinJavaAttrInfo *r_bin_java_annotation_default_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut64 offset = 0;
 if (sz < 8) {
  return NULL;
 }
 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 offset += 6;
 if (attr && sz >= offset) {
  attr->type = R_BIN_JAVA_ATTR_TYPE_ANNOTATION_DEFAULT_ATTR;

R_API RBinJavaAnnotation *r_bin_java_annotation_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut32 i = 0;

 RBinJavaElementValuePair *evps = NULL;
 ut64 offset = 0;
 if (sz < 8) {
  return NULL;
 }
 RBinJavaAnnotation *annotation = R_NEW0 (RBinJavaAnnotation);
 if (!annotation) {
  return NULL;
 }
}

R_API ut64 r_bin_java_element_pair_calc_size(RBinJavaElementValuePair *evp) {
 ut64 sz = 2;
 if (evp && evp->value) {
  // evp->element_name_idx = r_bin_java_read_short(bin, bin->b->cur);
  // evp->value = r_bin_java_element_value_new (bin, offset+2);




  sz += r_bin_java_element_value_calc_size (evp->value);
 }
 return sz;
R_API RBinJavaElementValue *r_bin_java_element_value_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut32 i = 0;
 ut64 offset = 0;
 if (sz < 8) {
  return NULL;
 }
 RBinJavaElementValue *element_value = R_NEW0 (RBinJavaElementValue);
 if (!element_value) {
  return NULL;
R_API RBinJavaAttrInfo *r_bin_java_rtv_annotations_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut32 i = 0;
 ut64 offset = 0;
 if (sz < 8) {
  return NULL;
 }
 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
"
Use After Free in radareorg/radare2,CVE-2022-0520,CWE-416: Use After Free,"  break;
 case TYPE_UNKNOWN:
  eprintf (""Get not implemented for type 0x%x\n"", type);
  // r_list_pop (refs);
  free_object (ret);
  return NULL;
 case 0:
"
Access of Memory Location After End of Buffer in radareorg/radare2,CVE-2022-0521,CWE-788: Access of Memory Location After End of Buffer,"
R_API RBinJavaAttrInfo *r_bin_java_enclosing_methods_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut64 offset = 6;
 if (sz < 8) {
  return NULL;
 }
 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 if (!attr || sz < 10) {
  free (attr);

R_API RBinJavaAttrInfo *r_bin_java_inner_classes_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 RBinJavaClassesAttribute *icattr;

 RBinJavaCPTypeObj *obj;
 ut32 i = 0;
 ut64 offset = 0, curpos;
 if (sz < 8) {



  return NULL;
 }
 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 if (!attr) {
  return NULL;
 }
 offset += 6;
 attr->type = R_BIN_JAVA_ATTR_TYPE_INNER_CLASSES_ATTR;
 attr->info.inner_classes_attr.number_of_classes = R_BIN_JAVA_USHORT (buffer, offset);
 offset += 2;
 attr->info.inner_classes_attr.classes = r_list_newf (r_bin_java_inner_classes_attr_entry_free);
 for (i = 0; i < attr->info.inner_classes_attr.number_of_classes; i++) {
  curpos = buf_offset + offset;
  if (offset + 8 > sz) {
   eprintf (""Invalid amount of inner classes\n"");
   break;
  }

R_API RBinJavaAttrInfo *r_bin_java_source_debug_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut64 offset = 6;
 if (sz < 8) {
  return NULL;
 }
 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 if (!attr) {
  return NULL;
R_API RBinJavaAttrInfo *r_bin_java_local_variable_table_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 RBinJavaLocalVariableAttribute *lvattr;
 ut64 curpos = 0, offset = 6;

 ut32 i = 0;
 if (!bin || !buffer || sz < 8) {
  return NULL;
 }
 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 if (!attr) {
  return NULL;
 }
}

R_API RBinJavaAttrInfo *r_bin_java_local_variable_type_table_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 if (sz < 8) {
  return NULL;
 }
 RBinJavaLocalVariableTypeAttribute *lvattr;
 ut64 offset = 6;
 ut32 i = 0;
}

R_API RBinJavaAttrInfo *r_bin_java_source_code_file_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 if (!sz || sz == UT64_MAX) {
  return NULL;
 }
#if 0
 /// XXX this breaks tests
 if (sz < 8) {
  return NULL;
 }
#endif
 ut64 offset = 0;
 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 offset += 6;
 if (attr) {
  attr->type = R_BIN_JAVA_ATTR_TYPE_SOURCE_FILE_ATTR;
  attr->info.source_file_attr.sourcefile_idx = R_BIN_JAVA_USHORT (buffer, offset);
  offset += 2;
  attr->size = offset;
  // IFDBG r_bin_java_print_source_code_file_attr_summary(attr);
 }






 return attr;
}

}

R_API RBinJavaAttrInfo *r_bin_java_synthetic_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 if (sz < 8) {
  return NULL;
 }
 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 if (!attr) {
  return NULL;
 }

 attr->type = R_BIN_JAVA_ATTR_TYPE_SYNTHETIC_ATTR;
 attr->size = 6;
 return attr;
}


R_API RBinJavaVerificationObj *r_bin_java_verification_info_from_type(RBinJavaObj *bin, R_BIN_JAVA_STACKMAP_TYPE type, ut32 value) {
 RBinJavaVerificationObj *se = R_NEW0 (RBinJavaVerificationObj);
 if (se) {
  se->tag = type;
  if (se->tag == R_BIN_JAVA_STACKMAP_OBJECT) {
   se->info.obj_val_cp_idx = (ut16) value;
  } else if (se->tag == R_BIN_JAVA_STACKMAP_UNINIT) {
   se->info.uninit_offset = (ut16) value;
  }






 }
 return se;
}

R_API RBinJavaVerificationObj *r_bin_java_read_from_buffer_verification_info_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {
 if (sz < 8) {
  return NULL;
 }
 ut64 offset = 0;
 RBinJavaVerificationObj *se = R_NEW0 (RBinJavaVerificationObj);
 if (!se) {
}

R_API RBinJavaStackMapFrame *r_bin_java_stack_map_frame_new(ut8 *buffer, ut64 sz, RBinJavaStackMapFrame *p_frame, ut64 buf_offset) {
 if (sz < 8) {
  return NULL;
 }
 RBinJavaStackMapFrame *stack_frame = r_bin_java_default_stack_frame ();
 RBinJavaVerificationObj *se = NULL;
 ut64 offset = 0;
R_API RBinJavaAttrInfo *r_bin_java_stack_map_table_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut32 i = 0;
 ut64 offset = 0;
 if (sz < 8) {
  return NULL;
 }
 RBinJavaStackMapFrame *stack_frame = NULL, *new_stack_frame = NULL;
 if (sz < 10) {
  return NULL;
 }
 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 offset += 6;
 IFDBG eprintf (""r_bin_java_stack_map_table_attr_new: New stack map allocated.\n"");
 if (!attr) {
  return NULL;
 }

R_API RBinJavaAttrInfo *r_bin_java_annotation_default_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut64 offset = 0;
 if (sz < 8) {
  return NULL;
 }
 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 offset += 6;
 if (attr && sz >= offset) {
  attr->type = R_BIN_JAVA_ATTR_TYPE_ANNOTATION_DEFAULT_ATTR;

R_API RBinJavaAnnotation *r_bin_java_annotation_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut32 i = 0;

 RBinJavaElementValuePair *evps = NULL;
 ut64 offset = 0;
 if (sz < 8) {
  return NULL;
 }
 RBinJavaAnnotation *annotation = R_NEW0 (RBinJavaAnnotation);
 if (!annotation) {
  return NULL;
 }
}

R_API ut64 r_bin_java_element_pair_calc_size(RBinJavaElementValuePair *evp) {
 ut64 sz = 2;
 if (evp && evp->value) {
  // evp->element_name_idx = r_bin_java_read_short(bin, bin->b->cur);
  // evp->value = r_bin_java_element_value_new (bin, offset+2);




  sz += r_bin_java_element_value_calc_size (evp->value);
 }
 return sz;
R_API RBinJavaElementValue *r_bin_java_element_value_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut32 i = 0;
 ut64 offset = 0;
 if (sz < 8) {
  return NULL;
 }
 RBinJavaElementValue *element_value = R_NEW0 (RBinJavaElementValue);
 if (!element_value) {
  return NULL;
R_API RBinJavaAttrInfo *r_bin_java_rtv_annotations_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut32 i = 0;
 ut64 offset = 0;
 if (sz < 8) {
  return NULL;
 }
 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
"
Access of Memory Location Before Start of Buffer in radareorg/radare2,CVE-2022-0522,CWE-786: Access of Memory Location Before Start of Buffer,"
#define VEC64(n) insn->detail->arm64.operands[n].vess
#define VEC64_APPEND(sb, n, i) vector64_append(sb, handle, insn, n, i)
#define VEC64_MASK(sh, sz) (bitmask_by_width[63]^(bitmask_by_width[sz>0?sz-1:0]<<sh))

static void vector64_append(RStrBuf *sb, csh *handle, cs_insn *insn, int n, int i) {
 cs_arm64_op op = INSOP64 (n);
   shift -= 64;
   regc = ""h"";
  }

  if (shift > 0 && shift < 64) {
   r_strbuf_appendf (sb, ""%d,SWAP,0x%""PFMT64x"",&,<<,%s%s,0x%""PFMT64x"",&,|,%s%s"",
    shift, mask, REG64 (n), regc, VEC64_MASK (shift, size), REG64 (n), regc);
"
Expired Pointer Dereference in radareorg/radare2,CVE-2022-0523,CWE-825: Expired Pointer Dereference,"/* radare - LGPL3 - Copyright 2016-2022 - Matthieu (c0riolis) Tardy - l0stb1t */

#include <r_io.h>
#include <r_bin.h>
#define if_true_return(cond,ret) if(cond){return(ret);}

// TODO: kill globals
static R_TH_LOCAL ut32 magic_int;
static R_TH_LOCAL ut32 symbols_ordinal = 0;
static R_TH_LOCAL RList *refs = NULL; // If you don't have a good reason, do not change this. And also checkout !refs in get_code_object()

/* interned_table is used to handle TYPE_INTERNED object */
extern RList *interned_table;
 }
 for (i = 0; i < size; i++) {
  tmp = get_object (buffer);
  if (!tmp || !r_list_append (ret->data, tmp)) {





   free_object (tmp);
   ((RList*)ret->data)->free = NULL;
   r_list_free (ret->data);
   free (ret);
   return NULL;
}

/* small TYPE_SMALL_TUPLE doesn't exist in python2 */

static pyc_object *get_small_tuple_object(RBuffer *buffer) {
 pyc_object *ret = NULL;
 bool error = false;
}

static pyc_object *get_tuple_object(RBuffer *buffer) {

 bool error = false;
 ut32 n = get_ut32 (buffer, &error);


 if (n > ST32_MAX) {
  eprintf (""bad marshal data (tuple size out of range)\n"");
  return NULL;
 }
 if (error) {
  return NULL;
 }
 pyc_object *ret = get_array_object_generic (buffer, n);
 if (ret) {
  ret->type = TYPE_TUPLE;

 }
 return ret;
}

static pyc_object *get_list_object(RBuffer *buffer) {
 pyc_object *ret = NULL;
 bool error = false;
 ut32 n = get_ut32 (buffer, &error);


 if (n > ST32_MAX) {
  eprintf (""bad marshal data (list size out of range)\n"");
  return NULL;
}

static pyc_object *get_set_object(RBuffer *buffer) {

 bool error = false;
 ut32 n = get_ut32 (buffer, &error);
 if (n > ST32_MAX) {
 if (error) {
  return NULL;
 }
 pyc_object *ret = get_array_object_generic (buffer, n);
 if (ret) {
  ret->type = TYPE_SET;
 }

 return ret;
}

"
Out-of-bounds Read in mruby/mruby,CVE-2022-0525,CWE-125: Out-of-bounds Read,"          }
        }
        if (tree->cdr->car) {       /* keyword arguments */
          if (n == 14) {
            pop_n(n);
            genop_2(s, OP_ARRAY, cursp(), n);
            push();
            n = 15;
          }
          gen_hash(s, tree->cdr->car->cdr, VAL, 0);
          if (n < 14) {
            n++;

          }
          else {
            pop_n(2);
            genop_2(s, OP_ARYPUSH, cursp(), 1);
          }
          push();
        }
      }
      if (rhs) {
"
Use of Out-of-range Pointer Offset in vim/vim,CVE-2022-0554,CWE-823: Use of Out-of-range Pointer Offset,"  buf = buflist_findnr(curwin->w_jumplist[jumpidx].fmark.fnum);
  if (buf != NULL)
  {
      // Skip current and unlisted bufs.  Also skip a quickfix
      // buffer, it might be deleted soon.
      if (buf == curbuf || !buf->b_p_bl
#if defined(FEAT_QUICKFIX)
       || bt_quickfix(buf)
#endif
       )
   buf = NULL;
      else if (buf->b_ml.ml_mfp == NULL)
      {
   // skip unloaded buf, but may keep it for later
      continue;
  }
  // in non-help buffer, try to skip help buffers, and vv
  if (buf->b_help == curbuf->b_help && buf->b_p_bl
#if defined(FEAT_QUICKFIX)
       && !bt_quickfix(buf)
#endif
      )
  {
      if (buf->b_ml.ml_mfp != NULL)   // found loaded buffer
   break;
 if (buf == NULL) // No loaded buffer, find listed one
 {
     FOR_ALL_BUFFERS(buf)
  if (buf->b_p_bl && buf != curbuf
#if defined(FEAT_QUICKFIX)
       && !bt_quickfix(buf)
#endif
         )
      break;
 }
 if (buf == NULL) // Still no buffer, just take one
  buf = curbuf->b_next;
     else
  buf = curbuf->b_prev;
#if defined(FEAT_QUICKFIX)
     if (bt_quickfix(buf))
  buf = NULL;
#endif
 }
    }

  delfunc R
endfunc

"" Another sequence of commands that caused all buffers to be wiped out
func Test_lopen_bwipe_all()
  let lines =<< trim END
    func R()
      silent! tab lopen
      e foo
      silent! lfile
    endfunc
    cal R()
    exe ""norm \<C-W>\<C-V>0""
    cal R()
    bwipe

    call writefile(['done'], 'Xresult')
    qall!
  END
  call writefile(lines, 'Xscript')
  if RunVim([], [], '-u NONE -n -X -Z -e -m -s -S Xscript')
    call assert_equal(['done'], readfile('Xresult'))
  endif

  call delete('Xscript')
  call delete('Xresult')
endfunc


"" vim: shiftwidth=2 sts=2 expandtab

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    4327,
/**/
    4326,
/**/
"
Use After Free in radareorg/radare2,CVE-2022-0559,CWE-416: Use After Free,"  r_io_submap_set_to (bd, r_io_submap_from (sm) - 1);
  entry = r_rbnode_next (entry);
 }
 ut64 smto = r_io_submap_to (sm);
 while (entry && r_io_submap_to (((RIOSubMap *)entry->data)) <= smto) {
  //delete all submaps that are completly included in sm
  RRBNode *next = r_rbnode_next (entry);
  // this can be optimized, there is no need to do search here
  // XXX this is a workaround to avoid an UAF in Reproducer: iobank-crash
  void *smfree = bank->submaps->free;
  bank->submaps->free = NULL;
  bool a = r_crbtree_delete (bank->submaps, entry->data, _find_sm_by_from_vaddr_cb, NULL);
  bank->submaps->free = smfree;
  if (!a) {
   entry = NULL;
   break;
  }
  entry = next;
 r_return_val_if_fail (tree && data && cmp, false);
 bool inserted = false;

 if (!tree->root) {
  tree->root = _node_new (data, NULL);
  if (!tree->root) {
   return false;
  }
  inserted = true;
"
Heap-based Buffer Overflow in mruby/mruby,CVE-2022-0570,CWE-122: Heap-based Buffer Overflow,"  while (t) {
    int is_splat = nint(t->car->car) == NODE_SPLAT;

    if (is_splat || cursp() >= slimit) { /* flush stack */
      pop_n(n);
      if (first) {
        if (n == 0) {
    }
    return -1;                  /* variable length */
  }
  else if (n > limit) {
    pop_n(n);
    genop_2(s, OP_ARRAY, cursp(), n);
    return -1;
  }
  return n;
}

"
Heap-based Buffer Overflow in vim/vim,CVE-2022-0572,CWE-122: Heap-based Buffer Overflow,"     if (ptr[col] == NUL)
  break;
     vcol += chartabsize(ptr + col, (colnr_T)vcol);
     if (vcol >= MAXCOL)
     {
  emsg(_(e_resulting_text_too_long));
  break;
     }
     if (has_mbyte)
  col += (*mb_ptr2len)(ptr + col);
     else
  call assert_equal(""    a       b        c    "",         Retab('!', 3))
  call assert_equal(""    a       b        c    "",         Retab('',  5))
  call assert_equal(""    a       b        c    "",         Retab('!', 5))

  set tabstop& expandtab&
endfunc

func Test_retab_error()
  call assert_fails('ret 80000000000000000000', 'E475:')
endfunc

func Test_retab_endless()
  new
  call setline(1, ""\t0\t"")
  let caught = 'no'
  try
    while 1
      set ts=4000
      retab 4
    endwhile
  catch /E1240/
    let caught = 'yes'
  endtry
  bwipe!
  set tabstop&
endfunc


"" vim: shiftwidth=2 sts=2 expandtab

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    4359,
/**/
    4358,
/**/
"
Use of Out-of-range Pointer Offset in mruby/mruby,CVE-2022-0614,CWE-823: Use of Out-of-range Pointer Offset,"      int lim = a+b*2+1;

      hash = regs[a];
      mrb_ensure_hash_type(mrb, hash);
      for (i=a+1; i<lim; i+=2) {
        mrb_hash_set(mrb, hash, regs[i], regs[i+1]);
      }
"
Out-of-bounds Read in mruby/mruby,CVE-2022-0623,CWE-125: Out-of-bounds Read,"      int lim = a+b*2+1;

      hash = regs[a];
      mrb_ensure_hash_type(mrb, hash);
      for (i=a+1; i<lim; i+=2) {
        mrb_hash_set(mrb, hash, regs[i], regs[i+1]);
      }
"
Stack-based Buffer Overflow in vim/vim,CVE-2022-0629,CWE-121: Stack-based Buffer Overflow,"  call assert_equal(""\b\e\f\n\t\r\\\x01\x7f"", 'x')
  call assert_match('Expected ''\\b\\e\\f\\n\\t\\r\\\\\\x01\\x7f'' but got ''x''', v:errors[0])
  call remove(v:errors, 0)

  "" many composing characters are handled properly
  call setline(1, ' ')
  norm 100gr݀
  call assert_equal(1, getline(1))
  call assert_match(""Expected 1 but got '.* occurs 100 times]'"", v:errors[0])
  call remove(v:errors, 0)
  bwipe!
endfunc

func Test_assert_equal_dict()
    {
 same_len = 1;
 s = p;
 c = mb_cptr2char_adv(&s);
 clen = s - p;
 while (*s != NUL && c == mb_ptr2char(s))
 {

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    4397,
/**/
    4396,
/**/
"
Out-of-bounds Read in mruby/mruby,CVE-2022-0630,CWE-125: Out-of-bounds Read,"      int lim = a+b*2+1;

      hash = regs[a];
      mrb_ensure_hash_type(mrb, hash);
      for (i=a+1; i<lim; i+=2) {
        mrb_hash_set(mrb, hash, regs[i], regs[i+1]);
      }
"
Heap-based Buffer Overflow in mruby/mruby,CVE-2022-0631,CWE-122: Heap-based Buffer Overflow,"  regs = mrb->c->ci->stack+1;

  if (n == 0) {
  argnum_error:
    mrb_argnum_error(mrb, 0, 1, -1);
  }
  else if (n == 15) {
    if (RARRAY_LEN(regs[0]) == 0) goto argnum_error;
    name = mrb_obj_to_sym(mrb, RARRAY_PTR(regs[0])[0]);
  }
  else {
"
NULL Pointer Dereference in mruby/mruby,CVE-2022-0632,CWE-476: NULL Pointer Dereference,"        if (tree->cdr->cdr) {
          codegen(s, tree->cdr->cdr, VAL);
        }
        else if (s2) gen_blkmove(s, s2->ainfo, lv);


        else {
          genop_1(s, OP_LOADNIL, cursp());
          push();
        }

      }
      else {
        if (s2) gen_blkmove(s, s2->ainfo, lv);
        else {
          genop_1(s, OP_LOADNIL, cursp());
          push();
        }
      }
      st++;
      pop_n(st+1);
      genop_2(s, OP_SUPER, cursp(), n);
      if (val) push();
        codegen_error(s, ""no anonymous block argument"");
      }
      gen_move(s, cursp(), idx, val);
      if (val) push();
    }
    else {
      codegen(s, tree, val);
"
Heap-based Buffer Overflow in radareorg/radare2,CVE-2022-0676,CWE-122: Heap-based Buffer Overflow,"
static RList *create_cache_bins(RBinFile *bf, RDyldCache *cache) {
 RList *bins = r_list_newf ((RListFree)free_bin);
 ut16 *depArray = NULL;
 cache_imgxtr_t *extras = NULL;
 if (!bins) {
  return NULL;
 }
  }

  ut32 j;


  if (target_libs) {
   HtPU *path_to_idx = NULL;
   if (cache->accel) {
 cache->n_maps = next_map;
}

static cache_accel_t *read_cache_accel(RBuffer *cache_buf, cache_hdr_t *hdr, cache_map_t *maps, int n_maps) {
 if (!cache_buf || !hdr || !hdr->accelerateInfoSize || !hdr->accelerateInfoAddr) {
  return NULL;
 }
 size_t mc = R_MIN (hdr->mappingCount, n_maps);
 ut64 offset = va2pa (hdr->accelerateInfoAddr, mc, maps, cache_buf, 0, NULL, NULL);
 if (!offset) {
  return NULL;
 }
  r_dyldcache_free (cache);
  return false;
 }
 cache->accel = read_cache_accel (cache->buf, cache->hdr, cache->maps, cache->n_maps);
 cache->bins = create_cache_bins (bf, cache);
 if (!cache->bins) {
  r_dyldcache_free (cache);
"
Use of Out-of-range Pointer Offset in vim/vim,CVE-2022-0685,CWE-823: Use of Out-of-range Pointer Offset,"    return isupper(c);
}

    int
vim_isalpha(int c)
{
    return vim_islower(c) || vim_isupper(c);
}

    int
vim_toupper(int c)
{
 else if (path_end >= path + wildoff
    && (vim_strchr((char_u *)""*?[{~$"", *path_end) != NULL
        || (!p_fic && (flags & EW_ICASE)
       && vim_isalpha(PTR2CHAR(path_end)))))
     e = p;
 if (has_mbyte)
 {
int vim_isbdigit(int c);
int vim_islower(int c);
int vim_isupper(int c);
int vim_isalpha(int c);
int vim_toupper(int c);
int vim_tolower(int c);
char_u *skiptowhite(char_u *p);
int rem_backslash(char_u *str);
void backslash_halve(char_u *p);
char_u *backslash_halve_save(char_u *p);

/* vim: set ft=c : */
  call delete('Xautodir', 'rf')
endfunc

func Test_multibyte()
  "" using an invalid character should not cause a crash
  set wic
  call assert_fails('tc űŤŤŤ¦*', 'E344:')
  set nowic
endfunc


"" vim: shiftwidth=2 sts=2 expandtab

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    4418,
/**/
    4417,
/**/
"
Denial of Service in radareorg/radare2,CVE-2022-0695,CWE-400: Denial of Service,"/* radare - LGPL - Copyright 2008-2022 nibble, pancake, inisider */

#include <stdio.h>
#include <stdlib.h>
}

struct r_bin_pe_addr_t *PE_(check_mingw)(RBinPEObj *pe) {

 bool sw = false;
 ut8 b[1024] = {0};
 size_t n = 0;
 if (!pe || !pe->b) {
  return 0LL;
 }
 struct r_bin_pe_addr_t* entry = PE_(r_bin_pe_get_entrypoint) (pe);

 if (r_buf_read_at (pe->b, entry->paddr, b, sizeof (b)) < 0) {
  pe_printf (""Warning: Cannot read entry at 0x%08""PFMT64x ""\n"", entry->paddr);
  free (entry);
 if (!pe || !pe->b) {
  return 0LL;
 }
 ut8 b[512] = {0};
 ZERO_FILL (b);
 entry = PE_ (r_bin_pe_get_entrypoint) (pe);
 // option2: /x 8bff558bec83ec20
 if (r_buf_read_at (pe->b, entry->paddr, b, sizeof (b)) != sizeof (b)) {
  pe_printf (""Warning: Cannot read entry at 0x%08""PFMT64x""\n"", entry->paddr);
  free (entry);
  return NULL;
    if (len < 1) {
     pe_printf (""Warning: read (import name)\n"");
     goto error;
    }
    if (!*name) {
     break;
    }
    name[PE_NAME_LENGTH] = '\0';
 // read the header after the string
 rr = r_buf_fread_at (pe->b, metadata_directory + 16 + metadata->VersionStringLength,
  (ut8*) (&metadata->Flags), pe->big_endian? ""2S"": ""2s"", 1);

 if (rr < 1) {
  goto fail;
 }
  free_Var (var);
  return NULL;
 }
 if (r_buf_read_at (pe->b, *curAddr, (ut8*) var->szKey, TRANSLATION_UTF_16_LEN) != TRANSLATION_UTF_16_LEN) {
  pe_printf (""Warning: read (Var szKey)\n"");
  free_Var (var);
  return NULL;
  int n_classes = classlist_sample_size / 8;
  ut64 sect_offset = sections[classlist_idx].offset + bin->hdr_offset;

  if (r_buf_fread_at (cache->buf, sect_offset, (ut8*) classlist, ""l"", n_classes) != classlist_sample_size) {
   goto next_bin;
  }

  return NULL;
 }

 if (r_buf_fread_at (bf->buf, 0, (ut8*)&psxheader, ""8c17i"", 1) != sizeof (psxexe_header)) {
  eprintf (""Truncated Header\n"");
  free (sect);
  r_list_free (ret);
  return NULL;
 }

 if (r_buf_fread_at (bf->buf, 0, (ut8*)&psxheader, ""8c17i"", 1) != sizeof (psxexe_header)) {
  eprintf (""PSXEXE Header truncated\n"");
  r_list_free (ret);
  free (addr);
 if (r_buf_size (buf) < sizeof (lmf_header)) {
  return false;
 }
 if (r_buf_fread_at (buf, QNX_HEADER_ADDR, (ut8 *) lmfh, ""iiiiiiiicccciiiicc"", 1) != QNX_HDR_SIZE) {
  return false;
 }
 r_strf_buffer (32);
  goto beach;
 }
 // Read the first record
 if (r_buf_fread_at (bf->buf, 0, (ut8 *)&lrec, ""ccss"", 1) != QNX_RECORD_SIZE) {
  goto beach;
 }
 // Load the header
 lmf_header_load (&qo->lmfh, bf->buf, qo->kv);
 offset += lrec.data_nbytes;

 for (;;) {
  if (r_buf_fread_at (bf->buf, offset, (ut8 *)&lrec, ""ccss"", 1) != QNX_RECORD_SIZE) {
   goto beach;
  }
  offset += sizeof (lmf_record);
   if (!ptr) {
    goto beach;
   }
   if (r_buf_fread_at (bf->buf, offset, (ut8 *)&lres, ""ssss"", 1) != sizeof (lmf_resource)) {
    goto beach;
   }
   ptr->name = strdup (""LMF_RESOURCE"");
    r_list_append (sections, ptr);
  } else if (lrec.rec_type == LMF_LOAD_REC) {
   RBinSection *ptr = R_NEW0 (RBinSection);
   if (r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, ""si"", 1) != sizeof (lmf_data)) {
    goto beach;
   }
   if (!ptr) {
    r_list_append (sections, ptr);
  } else if (lrec.rec_type == LMF_FIXUP_REC) {
   RBinReloc *ptr = R_NEW0 (RBinReloc);
   if (!ptr || r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, ""si"", 1) != sizeof (lmf_data)) {
    goto beach;
   }
   ptr->vaddr = ptr->paddr = ldata.offset;
   ptr->type = 'f'; // ""LMF_FIXUP"";
   r_list_append (fixups, ptr);
  } else if (lrec.rec_type == LMF_8087_FIXUP_REC) {
   RBinReloc *ptr = R_NEW0 (RBinReloc);
   if (!ptr || r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, ""si"", 1) != sizeof (lmf_data)) {
    goto beach;
   }
   ptr->vaddr = ptr->paddr = ldata.offset;
    ut32 d3;
    ut64 d4;
    st64 r = r_buf_read (src, tmp, tsize);
    if (r != tsize) {
     return -1;
    }

    switch (tsize) {
    case 1:
     d1 = r_read_ble8 (tmp);
  return r;
 }
 r = r_buf_fread (b, buf, fmt, n);
 (void)r_buf_seek (b, o_addr, R_BUF_SET);
 return r;
}

 if (r < 0) {
  return r;
 }

 r = r_buf_read (b, buf, len);
 r_buf_seek (b, o_addr, R_BUF_SET);
 return r;
"
NULL Pointer Dereference in vim/vim,CVE-2022-0696,CWE-476: NULL Pointer Dereference,"    }

    // b: variables
    ht = &prevwin_curwin()->w_buffer->b_vars->dv_hashtab;





    if (bdone < ht->ht_used)
    {
 if (bdone++ == 0)
    }

    // w: variables
    ht = &prevwin_curwin()->w_vars->dv_hashtab;





    if (wdone < ht->ht_used)
    {
 if (wdone++ == 0)
/* window.c */
win_T *prevwin_curwin(void);
void do_window(int nchar, long Prenum, int xchar);
void get_wincmd_addr_type(char_u *arg, exarg_T *eap);
int win_split(int size, int flags);
    /*
     * Look for buffer-local user commands first, then global ones.
     */
    gap = &prevwin_curwin()->w_buffer->b_ucmds;




    for (;;)
    {
 for (j = 0; j < gap->ga_len; ++j)
get_user_commands(expand_T *xp UNUSED, int idx)
{
    // In cmdwin, the alternative buffer should be used.
    buf_T *buf = prevwin_curwin()->w_buffer;





    if (idx < buf->b_ucmds.ga_len)
 return USER_CMD_GA(&buf->b_ucmds, idx)->uc_name;
    if (cmdidx == CMD_USER_BUF)
    {
 // In cmdwin, the alternative buffer should be used.
 buf_T *buf = prevwin_curwin()->w_buffer;





 if (idx < buf->b_ucmds.ga_len)
     return USER_CMD_GA(&buf->b_ucmds, idx)->uc_name;
    garray_T *gap;

    // In cmdwin, the alternative buffer should be used.
    gap = &prevwin_curwin()->w_buffer->b_ucmds;




    for (;;)
    {
 for (i = 0; i < gap->ga_len; ++i)

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    4428,
/**/
    4427,
/**/
}
#endif

/*
 * Return the current window, unless in the cmdline window and ""prevwin"" is
 * set, then return ""prevwin"".
 */
    win_T *
prevwin_curwin(void)
{
    return
#ifdef FEAT_CMDWIN
 // In cmdwin, the alternative buffer should be used.
 is_in_cmdwin() && prevwin != NULL ? prevwin :
#endif
 curwin;
}

/*
 * All CTRL-W window commands are handled here, called from normal_cmd().
 */
    tabpage_T *newtp;
    int  n;

#ifdef FEAT_CMDWIN
    if (cmdwin_type != 0)
    {
 emsg(_(e_invalid_in_cmdline_window));
 return FAIL;
    }
#endif

    newtp = alloc_tabpage();
    if (newtp == NULL)
 return FAIL;
 text_locked_msg();
 return;
    }
    CHECK_CMDWIN;

    // If there is only one it can't work.
    if (first_tabpage->tp_next == NULL)
    int  trigger_enter_autocmds,
    int  trigger_leave_autocmds)
{
    CHECK_CMDWIN;

    // Don't repeat a message in another tab page.
    set_keep_msg(NULL, 0);

"
NULL Pointer Dereference in radareorg/radare2,CVE-2022-0712,CWE-476: NULL Pointer Dereference,"/* radare - LGPL - Copyright 2018-2022 - pancake */

#include <r_types.h>
#include <r_util.h>
 bool found = false;
 for (i = 0; i < element->hdr->n_lined_symbols; i++) {
  RCoreSymCacheElementSymbol *sym = (RCoreSymCacheElementSymbol *)&element->lined_symbols[i];
  if (!sym) {
   break;
  }
  ht_uu_find (hash, sym->paddr, &found);
  if (found) {
   continue;
"
Heap-based Buffer Overflow in radareorg/radare2,CVE-2022-0713,CWE-122: Heap-based Buffer Overflow,"  }
  size_t i;
  ut8 *cursor = b + R_CS_EL_OFF_SEGS;
  for (i = 0; i < hdr->n_segments && cursor + sizeof (RCoreSymCacheElementSegment) < end; i++) {
   RCoreSymCacheElementSegment *seg = &result->segments[i];
   seg->paddr = seg->vaddr = r_read_le64 (cursor);
   cursor += 8;
"
Heap-based Buffer Overflow in vim/vim,CVE-2022-0714,CWE-122: Heap-based Buffer Overflow,"  new_cursor_col += (*mb_ptr2len)(ptr + new_cursor_col);
     else
  ++new_cursor_col;
     if (ptr[new_cursor_col] == NUL)
  break;
     vcol += lbr_chartabsize(ptr, ptr + new_cursor_col, (colnr_T)vcol);
 }
 vcol = last_vcol;
  setlocal shiftwidth& vartabstop& tabstop&
endfunc

func Test_vartabstop_latin1()
  let save_encoding = &encoding
  new
  set encoding=iso8859
  silent norm :se 
  set vartabstop=400
  norm i00 
  bwipe!
  let &encoding = save_encoding
endfunc


"" vim: shiftwidth=2 sts=2 expandtab

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    4436,
/**/
    4435,
/**/
"
Out-of-bounds Read in mruby/mruby,CVE-2022-0717,CWE-125: Out-of-bounds Read,"      if (val) {
        gen_move(s, top, cursp(), 1);
      }
      if (n < 15) {
        n++;
        if (n == 15) {
          pop_n(14);
          genop_2(s, OP_ARRAY, cursp(), 15);
        }
      }
      else {
        pop();
"
Use of Out-of-range Pointer Offset in vim/vim,CVE-2022-0729,CWE-823: Use of Out-of-range Pointer Offset,"       if (rex.input == rex.line)
       {
    // backup to last char of previous line
    if (rex.lnum == 0)
    {
        status = RA_NOMATCH;
        break;
    }
    --rex.lnum;
    rex.line = reg_getline(rex.lnum);
    // Just in case regrepeat() didn't count
"" Check that [[:upper:]] matches for automatic engine
func Test_match_char_class_upper()
  new


  "" Test 1: [[:upper:]]\{2,\}
  set regexpengine=0
  call assert_equal(4, searchcount().total, 'TEST 3 lower')

  "" clean up
  set regexpengine=0
  bwipe!
endfunc

  call delete('Xinvalid')
endfunc

func Test_match_too_complicated()
  set regexpengine=1
  exe ""vsplit \xeb\xdb\x99""
  silent! buf \&\zs*\zs*0
  bwipe!
  set regexpengine=0
endfunc


"" vim: shiftwidth=2 sts=2 expandtab

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    4440,
/**/
    4439,
/**/
"
Use After Free in r_reg_get_name_idx in radareorg/radare2,CVE-2022-0849,CWE-416: Use After Free," return (major > 1) && (major < 8);
}

#if UNUSED0
static inline int kvx_is_nop_opcode(ut32 x) {
 return ((x)<<1) == 0xFFFFFFFE;
}
#endif

static inline int kvx_opc_match(const opc_t *opc, insn_t *insn) {
 int i;
/* radare - LGPL - Copyright 2009-2022 - pancake, nibble */

#include <r_types.h>
#include <r_list.h>
typedef struct {
 RAnalOp *op;
 RAnalFunction *fcn;
 char *spname;
 ut64 initial_sp;
} EsilBreakCtx;

 bool gp_fixed = r_config_get_i (core->config, ""anal.gpfixed"");
 RAnalEsil *ESIL = core->anal->esil;
 ut64 refptr = 0LL;
 char *pcname = NULL;
 RAnalOp op = R_EMPTY;
 ut8 *buf = NULL;
 bool end_address_set = false;
  r_core_cmd0 (core, ""aeim"");
  ESIL = core->anal->esil;
 }
 const char *kspname = r_reg_get_name (core->anal->reg, R_REG_NAME_SP);
 if (R_STR_ISEMPTY (kspname)) {
  eprintf (""Error: No =SP defined in the reg profile.\n"");
  return;
 }
 char *spname = strdup (kspname);
 EsilBreakCtx ctx = {
  &op,
  fcn,
 }
 //eprintf (""Analyzing ESIL refs from 0x%""PFMT64x"" - 0x%""PFMT64x""\n"", addr, end);
 // TODO: backup/restore register state before/after analysis
 const char *kpcname = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);
 if (!kpcname || !*kpcname) {
  eprintf (""Cannot find program counter register in the current profile.\n"");
  return;
 }
 pcname = strdup (kpcname);
 esil_anal_stop = false;
 r_cons_break_push (cccb, core);

  r_anal_op_fini (&op);
  r_asm_set_pc (core->rasm, cur);
  i_old = i;

  if (i > iend) {
   goto repeat;
  }

  if (!r_anal_op (core->anal, &op, cur, buf + i, iend - i, R_ANAL_OP_MASK_ESIL | R_ANAL_OP_MASK_VAL | R_ANAL_OP_MASK_HINT)) {
   i += minopsize - 1; //   XXX dupe in op.size below
  }
   break;
  }
 } while (get_next_i (&ictx, &i));
 free (pcname);
 free (spname);
 r_list_free (ictx.bbl);
 r_list_free (ictx.path);
 r_list_free (ictx.switch_path);
"
NULL Pointer Dereference in mruby/mruby,CVE-2022-0890,CWE-476: NULL Pointer Dereference,"    if (!c->ci->proc) {
      mrb_raise(mrb, E_FIBER_ERROR, ""double resume (current)"");
    }






    if (vmexec) {
      c->ci--;                    /* pop dummy callinfo */
    }
    if (len >= 15) {
      mrb_stack_extend(mrb, 3);   /* for receiver, args and (optional) block */
      c->stbase[1] = mrb_ary_new_from_values(mrb, len, a);
      len = 15;
    }
    else {
      mrb_stack_extend(mrb, len+2); /* for receiver and (optional) block */
      b = c->stbase+1;
      e = b + len;
      while (b<e) {
        *b++ = *a++;
      }
    }
    c->cibase->n = len;
    value = c->stbase[0] = MRB_PROC_ENV(c->cibase->proc)->stack[0];
  }
"
Heap-based Buffer Overflow occurs in vim in vim/vim,CVE-2022-0943,CWE-122: Heap-based Buffer Overflow,"     curwin->w_cursor.col = VIsual.col;
 ++badlen;
 end_visual_mode();
 // make sure we don't include the NUL at the end of the line
 line = ml_get_curline();
 if (badlen > STRLEN(line) - curwin->w_cursor.col)
     badlen = STRLEN(line) - curwin->w_cursor.col;
    }
    // Find the start of the badly spelled word.
    else if (spell_move_to(curwin, FORWARD, TRUE, TRUE, NULL) == 0
  call assert_fails('set spellsuggest=timeout:--9', 'E474:')
endfunc

func Test_spellsuggest_visual_end_of_line()
  let enc_save = &encoding
  set encoding=iso8859

  "" This was reading beyond the end of the line.
  norm R00000000000
  sil norm 0
  sil! norm i00000)
  sil! norm i00000)
  call feedkeys(""\<CR>"")
  norm z=

  let &encoding = enc_save
endfunc

func Test_spellinfo()
  new
  let runtime = substitute($VIMRUNTIME, '\\', '/', 'g')

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    4563,
/**/
    4562,
/**/
"
Use After Free in op_is_set_bp in radareorg/radare2,CVE-2022-1031,CWE-416: Use After Free,"   // note, we have still increased size of basic block
   // (and function)
   if (anal->verbose) {
    eprintf (""Enter branch delay at 0x%08""PFMT64x "". bb->sz=%""PFMT64u""\n"", at - oplen, bb->size);
   }
   delay.idx = idx - oplen;
   delay.cnt = op->delay;
   // swapped parameters wtf
   r_anal_xrefs_set (anal, op->addr, op->ptr, R_ANAL_REF_TYPE_DATA);
  }
  if (anal->opt.vars && !varset) {
   // XXX uses op.src/dst and fails because regprofile invalidates the regitems
   // lets just call this BEFORE retpoline() to avoid such issue
   r_anal_extract_vars (anal, fcn, op);
  }
  // this call may cause regprofile changes which cause ranalop.regitem references to be invalid
  analyze_retpoline (anal, op);
  switch (op->type & R_ANAL_OP_TYPE_MASK) {
  case R_ANAL_OP_TYPE_CMOV:
    fcn->bp_off = fcn->stack - op->src[0]->delta;
   }
   if (op->dst && op->dst->reg && op->dst->reg->name && op->ptr > 0 && op->ptr != UT64_MAX) {
    free (last_reg_mov_lea_name);
    if ((last_reg_mov_lea_name = strdup(op->dst->reg->name))) {
     last_reg_mov_lea_val = op->ptr;
     last_is_reg_mov_lea = true;
    }
   }
  }
#if 0
  if (anal->opt.vars && !varset) {
   // XXX uses op.src/dst and fails because regprofile invalidates the regitems
   // we must ranalop in here to avoid uaf
   r_anal_extract_vars (anal, fcn, op);
  }
#endif
  if (op->type != R_ANAL_OP_TYPE_MOV && op->type != R_ANAL_OP_TYPE_CMOV && op->type != R_ANAL_OP_TYPE_LEA) {
   last_is_reg_mov_lea = false;
  }
  free (vartype);
 } else {
  st64 frame_off = -(ptr + fcn->bp_off);
  if (maxstackframe > 0 && (frame_off > maxstackframe || frame_off < -maxstackframe)) {
   goto beach;
  }
  RAnalVar *var = get_stack_var (fcn, frame_off);
"
Segmentation Fault caused by MP4Box -lsr in gpac/gpac,CVE-2022-1035,CWE-476: NULL Pointer Dereference,"
 switch (field.fieldType) {
 case GF_SG_VRML_SFNODE:
  gf_dump_vrml_node(sdump, field.far_ptr ? *(GF_Node **)field.far_ptr : NULL, 0, NULL);

  return;
 case GF_SG_VRML_MFNODE:
  list = * ((GF_ChildNodeItem **) field.far_ptr);
"
Heap Buffer Overflow in iterate_chained_fixups in radareorg/radare2,CVE-2022-1052,CWE-122: Heap-based Buffer Overflow," if (header.starts_offset > size) {
  return false;
 }
 ut32 segs_count = r_buf_read_le32_at (bin->b, starts_at);
 if (segs_count == UT32_MAX || segs_count == 0) {
  return false;
 }
 bin->segs_count = segs_count;
 bin->chained_starts = R_NEWS0 (struct r_dyld_chained_starts_in_segment *, segs_count);
 if (!bin->chained_starts) {
  return false;
 }
 R_FREE (opcodes);

 bin->segs_count = bin->nsegs;
 return true;
}

 free (mo->intrp);
 free (mo->compiler);
 if (mo->chained_starts) {
  for (i = 0; i < mo->nsegs && i < mo->segs_count; i++) {
   if (mo->chained_starts[i]) {
    free (mo->chained_starts[i]->page_start);
    free (mo->chained_starts[i]);

void MACH0_(iterate_chained_fixups)(struct MACH0_(obj_t) *bin, ut64 limit_start, ut64 limit_end, ut32 event_mask, RFixupCallback callback, void * context) {
 int i = 0;
 for (; i < bin->nsegs && i < bin->segs_count; i++) {
  if (!bin->chained_starts[i]) {
   continue;
  }
 char *intrp;
 char *compiler;
 int nsegs;
 int segs_count;
 struct r_dyld_chained_starts_in_segment **chained_starts;
 struct dyld_chained_fixups_header fixups_header;
 ut64 fixups_offset;

R_API RCmdAliasVal *r_cmd_alias_get(RCmd *cmd, const char *k) {
 r_return_val_if_fail (cmd && cmd->aliases && k, NULL);
 return ht_pp_find (cmd->aliases, k, NULL);
}

static ut8 *alias_append_internal(int *out_szp, const RCmdAliasVal *first, const ut8 *second, int second_sz) {
"
Heap Buffer Overflow in parseDragons in radareorg/radare2,CVE-2022-1061,CWE-122: Heap-based Buffer Overflow,"
static RCoreSymCacheElement *parseDragons(RBinFile *bf, RBuffer *buf, int off, int bits, R_OWN char *file_name) {
 D eprintf (""Dragons at 0x%x\n"", off);
 st64 size = r_buf_size (buf);
 if (off >= size) {
  return NULL;
 }
 size -= off;
 if (!size) {
  return NULL;
 }
 if (size < 32) {
  return NULL;
 }
 ut8 *b = malloc (size);
 if (!b) {
  return NULL;
"
User after free in mrb_vm_exec in mruby/mruby,CVE-2022-1071,CWE-416: Use After Free,"        regs[a] = mrb_ary_entry(va, mrb_integer(vb));
        break;
      case MRB_TT_HASH:
        va = mrb_hash_get(mrb, va, vb);
        regs[a] = va;
        break;
      case MRB_TT_STRING:
        switch (mrb_type(vb)) {
        case MRB_TT_INTEGER:
        case MRB_TT_STRING:
        case MRB_TT_RANGE:
          va = mrb_str_aref(mrb, va, vb, mrb_undef_value());
          regs[a] = va;
          break;
        default:
          goto getidx_fallback;
    }

    CASE(OP_GETCONST, BB) {
      mrb_value v = mrb_vm_const_get(mrb, syms[b]);
      regs[a] = v;
      NEXT;
    }

    }

    CASE(OP_GETMCNST, BB) {
      mrb_value v = mrb_const_get(mrb, regs[a], syms[b]);
      regs[a] = v;
      NEXT;
    }

    CASE(OP_KARG, BB) {
      mrb_value k = mrb_symbol_value(syms[b]);
      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);
      mrb_value kdict, v;

      if (kidx < 0 || !mrb_hash_p(kdict=regs[kidx]) || !mrb_hash_key_p(mrb, kdict, k)) {
        mrb_value str = mrb_format(mrb, ""missing keyword: %v"", k);
        mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));
        goto L_RAISE;
      }
      v = mrb_hash_get(mrb, kdict, k);
      regs[a] = v;
      mrb_hash_delete_key(mrb, kdict, k);
      NEXT;
    }
"
use after free in mrb_vm_exec in mruby/mruby,CVE-2022-1106,CWE-416: Use After Free,"    }

    CASE(OP_RANGE_INC, B) {
      mrb_value v = mrb_range_new(mrb, regs[a], regs[a+1], FALSE);
      regs[a] = v;
      mrb_gc_arena_restore(mrb, ai);
      NEXT;
    }

    CASE(OP_RANGE_EXC, B) {
      mrb_value v = mrb_range_new(mrb, regs[a], regs[a+1], TRUE);
      regs[a] = v;
      mrb_gc_arena_restore(mrb, ai);
      NEXT;
    }
"
Use after free in utf_ptr2char in vim/vim,CVE-2022-1154,CWE-416: Use After Free,"  int mark = OPERAND(scan)[0];
  int cmp = OPERAND(scan)[1];
  pos_T *pos;
  size_t col = REG_MULTI ? rex.input - rex.line : 0;

  pos = getmark_buf(rex.reg_buf, mark, FALSE);

  // Line may have been freed, get it again.
  if (REG_MULTI)
  {
      rex.line = reg_getline(rex.lnum);
      rex.input = rex.line + col;
  }

  if (pos == NULL       // mark doesn't exist
   || pos->lnum <= 0)   // mark isn't set in reg_buf
  {

func Test_using_mark_position()
  "" this was using freed memory
  "" new engine
  new
  norm O0
  call assert_fails(""s/\\%')"", 'E486:')
  bwipe!

  "" old engine
  new
  norm O0
  call assert_fails(""s/\\%#=1\\%')"", 'E486:')
  bwipe!
endfunc

func Test_using_visual_position()

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    4646,
/**/
    4645,
/**/
"
heap buffer overflow in get_one_sourceline in vim/vim,CVE-2022-1160,CWE-122: Heap-based Buffer Overflow,"  break;      // all the lines are processed
     ga_concat(&ga, ((char_u **)sp->buflines.ga_data)[sp->buf_lnum]);
     sp->buf_lnum++;
     if (ga_grow(&ga, 1) == FAIL)
  break;
     buf = (char_u *)ga.ga_data;
     buf[ga.ga_len++] = NUL;
 }
 else
 {
  %bw!
endfunc

func Test_source_buffer_long_line()
  "" This was reading past the end of the line.
  new
  norm300gr0
  so
  bwipe!
endfunc


"" vim: shiftwidth=2 sts=2 expandtab

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    4647,
/**/
    4646,
/**/
"
Null Pointer Dereference Caused Segmentation Fault in gpac/gpac,CVE-2022-1172,CWE-476: NULL Pointer Dereference,"  if (sfcb->buffer) {
   gf_free(sfcb->buffer);
   sfcb->buffer = NULL;
   sfcb->bufferSize = 0;
  }
  while (gf_list_count(sfcb->commandList)) {
   GF_Command *com = (GF_Command*)gf_list_get(sfcb->commandList, 0);
"
NULL Pointer Dereference in mrb_vm_exec with super in mruby/mruby,CVE-2022-1201,CWE-476: NULL Pointer Dereference,"      }
      else if (target_class->tt == MRB_TT_MODULE) {
        target_class = mrb_vm_ci_target_class(ci);
        if (!target_class || target_class->tt != MRB_TT_ICLASS) {
          goto super_typeerror;
        }
      }
"
Out-of-bounds read in radareorg/radare2,CVE-2022-1207,CWE-125: Out-of-bounds Read,"/* radare2 - LGPL - Copyright 2014-2022 - pancake */

#include <r_asm.h>
#include <r_lib.h>
 int opsize = -1;
 op->type = -1;
 opsize = 2;
 if (len < 1) {
  return -1;
 }
 switch (buf[0]) {
 case 0x3f:
 case 0x4f:
  op->type = R_ANAL_OP_TYPE_LEA;
  if (len > 5) {
   op->ptr = buf[2];
   op->ptr |= buf[3] << 8;
   op->ptr |= buf[4] << 16;
   op->ptr |= ((ut32)(0xff & buf[5])) << 24;
   op->ptr += addr;
   opsize = 6;
  } else {
  op->type = R_ANAL_OP_TYPE_CALL;
  if (len > 5) {
   st32 delta = buf[2];
   delta |= buf[3] << 8;
   delta |= buf[4] << 16;
   delta |= buf[5] << 24;
   op->jump = addr + delta;
  } else {
   op->jump = UT64_MAX;
  opsize = 6;
  break;
 case 0x00:
  if (len < 2) {
   break;
  }
  if (buf[1] == 0x00) {
   op->type = R_ANAL_OP_TYPE_TRAP;
  } else {
  }
  break;
 case 0xf0:
  if (len < 2) {
   break;
  }
  if (buf[1] == 0xb9) {
   op->type = R_ANAL_OP_TYPE_RET;
  }
  break;
 default:
  if (len < 2) {
   break;
  }
  switch (buf[1]) {
  case 0x00:
   op->type = R_ANAL_OP_TYPE_CJMP; // BCC
   op->type = R_ANAL_OP_TYPE_SHR;
   break;
  case 0x96: // move.d r, r
   if (buf[0] >= 0xc0) {
    op->type = R_ANAL_OP_TYPE_CMP;
   } else {
    op->type = R_ANAL_OP_TYPE_MOV;
  ""=PC pc\n""
  ""=SP r14\n"" // XXX
  ""=BP srp\n"" // XXX
  ""=SN r0\n""
  ""=A0 r0\n""
  ""=A1 r1\n""
  ""=A2 r2\n""
"
Use-After-Free in str_escape in mruby/mruby in mruby/mruby,CVE-2022-1212,CWE-416: Use After Free,"          }
          if (ci->cci > CINFO_NONE) {
            ci = cipop(mrb);
            mrb->exc = (struct RObject*)break_new(mrb, RBREAK_TAG_BREAK, proc, v);
            mrb_gc_arena_restore(mrb, ai);
            mrb->c->vmexec = FALSE;

            mrb->jmp = prev_jmp;
            MRB_THROW(prev_jmp);
          }
"
Inf loop in gpac/gpac,CVE-2022-1222,CWE-835: Infinite Loop,"
int avi_parse_input_file(avi_t *AVI, int getIndex)
{
 int rate, scale, idx_type;
 s64 n, i;
 unsigned char *hdrl_data;
 u64 header_offset=0;
 int hdrl_len=0;
    n -= 4;
   if(strnicmp(data,""hdrl"",4) == 0)
   {
    if (n>0xFFFFFFFF) ERR_EXIT(AVI_ERR_READ)
    hdrl_len = (u32) n;
    hdrl_data = (unsigned char *) gf_malloc((u32)n);
    if(hdrl_data==0) ERR_EXIT(AVI_ERR_NO_MEM);
      AVI->compressor2[4] = 0;

      if (n>40) {
       if (n>0xFFFFFFFF) ERR_EXIT(AVI_ERR_READ)
       AVI->extradata_size = (u32) (n - 40);
       AVI->extradata = gf_malloc(sizeof(u8)* AVI->extradata_size);
       if (!AVI->extradata) ERR_EXIT(AVI_ERR_NO_MEM)
       memcpy(AVI->extradata, hdrl_data + i + 40, AVI->extradata_size);
      }

"
Improper Validation of Array Index in radareorg/radare2,CVE-2022-1237,CWE-129: Improper Validation of Array Index,"/* radare - LGPL - Copyright 2019-2022 - GustavoLCR */

#include ""ne.h""

 RList *segments = r_list_newf (free);
 for (i = 0; i < bin->ne_header->SegCount; i++) {
  RBinSection *bs = R_NEW0 (RBinSection);

  if (!bs) {
   return segments;
  }
  NE_image_segment_entry *se = &bin->segment_entries[i];
  bs->size = se->length;
  bs->vsize = se->minAllocSz ? se->minAllocSz : 64000;
  bs->bits = R_SYS_BITS_16;
  return NULL;
 }

 ut16 *modref = calloc (bin->ne_header->ModRefs, sizeof (ut16));
 if (!modref) {
  return NULL;
 }
   continue;
  }
  off += 2;
  size_t buf_size = r_buf_size (bin->buf);
  while (off < start + length * sizeof (NE_image_reloc_item) && off < buf_size) {
   RBinReloc *reloc = R_NEW0 (RBinReloc);
   if (!reloc) {
    return NULL;
     break;
    }
    char *name;
    if (rel.index < 1 || rel.index > bin->ne_header->ModRefs) {
     name = r_str_newf (""UnknownModule%d_%x"", rel.index, off); // ????
    } else {
     int index = rel.index;
     offset = modref[index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;
     name = __read_nonnull_str_at (bin->buf, offset);
    }
    if (rel.flags & IMPORTED_ORD) {
  return;
 }
 bin->buf = buf;
 // XXX this is endian unsafe
 r_buf_read_at (buf, bin->header_offset, (ut8 *)bin->ne_header, sizeof (NE_image_header));
 if (bin->ne_header->FileAlnSzShftCnt > 8) {
  bin->ne_header->FileAlnSzShftCnt = 8;
 }
 if (bin->ne_header->ModRefs * sizeof (ut16) >= r_buf_size (bin->buf)) {
  bin->ne_header->ModRefs = r_buf_size (bin->buf) / sizeof (ut16);
 }
 bin->alignment = 1 << bin->ne_header->FileAlnSzShftCnt;
 if (!bin->alignment) {
  bin->alignment = 1 << 9;
 }
 bin->os = __get_target_os (bin);

 ut16 offset = bin->ne_header->SegTableOffset + bin->header_offset;
 size_t size = bin->ne_header->SegCount * sizeof (NE_image_segment_entry);
 if (offset >= r_buf_size (bin->buf)) {
  return;
 }
 size_t remaining = r_buf_size (bin->buf) - offset;
 size = R_MIN (remaining, size);
 bin->segment_entries = calloc (1, size);
 if (size >= remaining) {
  bin->ne_header->SegCount = size / sizeof (NE_image_segment_entry);
 }
 if (!bin->segment_entries) {
  return;
 }
"
Heap-based Buffer Overflow in libr/bin/format/ne/ne.c in radareorg/radare2,CVE-2022-1238,CWE-805: Buffer Access with Incorrect Length Value," }
 int off = 0;
 while (off < bin->ne_header->EntryTableLength) {
  if (bin->entry_table + off + 32 >= r_buf_size (bin->buf)) {
   break;
  }
  ut8 bundle_length = *(ut8 *)(bin->entry_table + off);
  if (!bundle_length) {
   break;
    ut8 segnum = *(bin->entry_table + off);
    off++;
    ut16 segoff = *(ut16 *)(bin->entry_table + off);
    if (segnum > 0) {
     entry->paddr = (ut64)bin->segment_entries[segnum - 1].offset * bin->alignment + segoff;
    }
   } else { // Fixed
    entry->paddr = (ut64)bin->segment_entries[bundle_type - 1].offset * bin->alignment + *(ut16 *)(bin->entry_table + off);
   }
"
Heap buffer overflow in libr/bin/format/mach0/mach0.c in radareorg/radare2,CVE-2022-1240,CWE-122: Heap-based Buffer Overflow," for (i = 0; i < num; i++) {
  struct relocation_info a_info = info[i];
  ut32 sym_num = a_info.r_symbolnum;
  if (sym_num >= bin->nsymtab) {
   continue;
  }

"
heap-buffer-overflow in radareorg/radare2,CVE-2022-1244,CWE-122: Heap-based Buffer Overflow,"/* radare - LGPL - Copyright 2009-2022 nibble, pancake */

#include <r_types.h>
#include ""mach0_specs.h""
   if (deps && !deps[j]) {
    continue;
   }
   // ut64 pa = va2pa (img[j].address, hdr->mappingCount, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);
   ut64 pa = va2pa (img[j].address, cache->n_maps, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);
   if (pa == UT64_MAX) {
    continue;
   }
"
Out-of-bounds Read in mrb_get_args in mruby/mruby,CVE-2022-1276,CWE-125: Out-of-bounds Read,"          }
        }
        if (tree->cdr->car) {       /* keyword arguments */
          if (n == 13 || n == 14) {
            pop_n(n);
            genop_2(s, OP_ARRAY, cursp(), n);
            push();
"
NULL Pointer Dereference in r_bin_ne_get_entrypoints function in radareorg/radare2,CVE-2022-1283,CWE-476: NULL Pointer Dereference," }
 RList *entries = r_bin_ne_get_entrypoints (bin);
 bool resident = true, first = true;
 while (entries) {
  ut8 sz = r_buf_read8_at (bin->buf, off);
  if (!sz) {
   first = true;
}

RList *r_bin_ne_get_entrypoints(r_bin_ne_obj_t *bin) {
 if (!bin->entry_table) {
  return NULL;
 }
 RList *entries = r_list_newf (free);
 if (!entries) {
  return NULL;
"
heap-use-after-free in radareorg/radare2,CVE-2022-1284,CWE-416: Use After Free,"  arch = R2_ARCH_MIPS;
 }





 r_reg_arena_push (core->anal->reg);

 IterCtx ictx = { start, end, fcn, NULL };
    goto repeat;
   }
  }
  const char *sn = r_reg_get_name (core->anal->reg, R_REG_NAME_SN);
  if (!sn) {
   eprintf (""Warning: No SN reg alias for current architecture.\n"");
  }
  if (sn && op.type == R_ANAL_OP_TYPE_SWI) {
   r_strf_buffer (64);
   r_flag_space_set (core->flags, R_FLAGS_FS_SYSCALLS);
"
heap-buffer-overflow in mrb_vm_exec in mruby/mruby in mruby/mruby,CVE-2022-1286,CWE-122: Heap-based Buffer Overflow,"  MRB_CLASS_ORIGIN(c);
  h = c->mt;

  if (h && mt_del(mrb, h, mid)) {
    mrb_mc_clear_by_class(mrb, c);
    return;
  }
  mrb_name_error(mrb, mid, ""method '%n' not defined in %C"", mid, c);
}

"
Out-of-bounds read in `r_bin_ne_get_relocs` function in radareorg/radare2,CVE-2022-1296,CWE-125: Out-of-bounds Read,"/* radare - LGPL - Copyright 2019-2022 - GustavoLCR */

#include ""ne.h""


static char *__get_target_os(r_bin_ne_obj_t *bin) {
 switch (bin->ne_header->targOS) {
     free (reloc);
     break;
    }
    char *name = NULL;








    if (rel.index > bin->ne_header->ModRefs) {
     name = r_str_newf (""UnknownModule%d_%x"", rel.index, off); // ????
    } else if (rel.index > 0) {
     offset = modref[rel.index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;
     name = __read_nonnull_str_at (bin->buf, offset);
    }

    if (rel.flags & IMPORTED_ORD) {
     imp->ordinal = rel.func_ord;
     char *fname = __func_name_from_ord (name, rel.func_ord);
     imp->name = r_str_newf (""%s.%s"", name, fname);
     free (fname);
    } else {
     offset = bin->header_offset + bin->ne_header->ImportNameTable + rel.name_off;
     char *func = __read_nonnull_str_at (bin->buf, offset);
    r_list_append (relocs, reloc);
   } else {
    do {
#define NE_BUG 0
#if NE_BUG
     if (reloc->paddr + 4 < r_buf_size (bin->buf)) {
      break;
NAME=NE crash
FILE=bins/ne/necrash
CMDS=<<EOF
aaa
i~format
i~csum
aflc
EOF
EXPECT=<<EOF
format   ne
hdr.csum c258016a
0
EOF
RUN
NAME=NE Symbols
FILE=bins/ne/anim8.exe
CMDS=is
"
Out-of-bounds Read in r_bin_ne_get_entrypoints function in radareorg/radare2,CVE-2022-1297,CWE-125: Out-of-bounds Read,"    off += 2;
    ut8 segnum = *(bin->entry_table + off);
    off++;
    if (off > bin->ne_header->EntryTableLength) {
     break;
    }
    ut16 segoff = r_read_le16 (bin->entry_table + off);
    if (segnum > 0 && segnum < bin->ne_header->SegCount) {
     entry->paddr = (ut64)bin->segment_entries[segnum - 1].offset * bin->alignment + segoff;
    }
   } else { // Fixed
    if (off + 2 >= bin->ne_header->EntryTableLength) {
     break;
    }
    ut16 delta = r_read_le16 (bin->entry_table + off);
    if (bundle_type < bin->ne_header->SegCount) {
     entry->paddr = (ut64)bin->segment_entries[bundle_type - 1].offset
      * bin->alignment + delta;
    }
   }
   off += 2;
"
global heap buffer overflow in skip_range in vim/vim,CVE-2022-1381,CWE-122: Heap-based Buffer Overflow," cmdmod_T    *cmod,
 int     skip_only)
{
    char_u  *orig_cmd = eap->cmd;
    char_u  *cmd_start = NULL;
    int     did_plus_cmd = FALSE;
    char_u  *p;
    int     starts_with_colon = FALSE;
    int     vim9script = in_vim9script();
   && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)
 {
     eap->cmd = (char_u *)""+"";
     did_plus_cmd = TRUE;
     if (!skip_only)
  ex_pressedreturn = TRUE;
 }
     // Since the modifiers have been parsed put the colon on top of the
     // space: ""'<,'>mod cmd"" -> ""mod:'<,'>cmd
     // Put eap->cmd after the colon.
     if (did_plus_cmd)
     {
  size_t len = STRLEN(cmd_start);

  // Special case: empty command may have been changed to ""+"":
  //  ""'<,'>mod"" -> ""mod'<,'>+
  mch_memmove(orig_cmd, cmd_start, len);
  STRCPY(orig_cmd + len, ""'<,'>+"");
     }
     else
     {
  mch_memmove(cmd_start - 5, cmd_start, eap->cmd - cmd_start);
  eap->cmd -= 5;
  mch_memmove(eap->cmd - 1, "":'<,'>"", 6);
     }
 }
 else
     // No modifiers, move the pointer back.
     // Special case: empty command may have been changed to ""+"".
     if (did_plus_cmd)
  eap->cmd = (char_u *)""'<,'>+"";
     else
  eap->cmd = orig_cmd;
    }

    return OK;
  bwipe!
endfunc

"" This was accessing illegal memory when using ""+"" for eap->cmd.
func Test_empty_command_visual_mode()
  let lines =<< trim END
      r<sfile>
      0norm0V:
      :qall!
  END
  call writefile(lines, 'Xexmodescript')
  call assert_equal(1, RunVim([], [], '-u NONE -e -s -S Xexmodescript'))

  call delete('Xexmodescript')
endfunc


"" vim: shiftwidth=2 sts=2 expandtab

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    4763,
/**/
    4762,
/**/
"
NULL Pointer Dereference in radareorg/radare2,CVE-2022-1382,CWE-476: NULL Pointer Dereference,"
RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {
 int i;
 if (!bin || !bin->segment_entries) {
  return NULL;
 }
 RList *segments = r_list_newf (free);
"
Heap-based Buffer Overflow in radareorg/radare2,CVE-2022-1383,CWE-122: Heap-based Buffer Overflow,"    sect->vaddr += page_zero_size;
   }
   cursor += word_size;
   if (cursor + word_size >= end) {
    break;
   }
   sect->size = r_read_ble (cursor, false, bits);
   cursor += word_size;
   if (cursor + word_size >= end) {
    break;
   }
   ut64 sect_name_off = r_read_ble (cursor, false, bits);
    cursor += word_size;
   }
   string_origin = relative_to_strings? b + start_of_strings : sect_start;
   if (sect_name_off < (ut64)(size_t)(end - string_origin)) {
    sect->name = str_dup_safe (b, string_origin + sect_name_off, end);
   } else {
    sect->name = strdup ("""");
   }
  }
 }
 if (hdr->n_symbols) {
"
Use of Out-of-range Pointer Offset in vim/vim,CVE-2022-1420,CWE-823: Use of Out-of-range Pointer Offset," INIT(= N_(""E1273: (NFA regexp) missing value in '\\%%%c'""));
EXTERN char e_no_script_file_name_to_substitute_for_script[]
 INIT(= N_(""E1274: No script file name to substitute for \""<script>\""""));
#ifdef FEAT_EVAL
EXTERN char e_string_or_function_required_for_arrow_parens_expr[]
 INIT(= N_(""E1275: String or function required for ->(expr)""));
#endif
 ++*arg;
 ret = eval1(arg, rettv, evalarg);
 *arg = skipwhite_and_linebreak(*arg, evalarg);
 if (**arg != ')')
 {
     emsg(_(e_missing_closing_paren));
     return FAIL;
 }
 if (rettv->v_type != VAR_STRING && rettv->v_type != VAR_FUNC
            && rettv->v_type != VAR_PARTIAL)
 {
     emsg(_(e_string_or_function_required_for_arrow_parens_expr));
     return FAIL;
 }
 ++*arg;
    }
    if (ret != OK)
 return FAIL;

    if (**arg != '(')
    {
 if (verbose)
 {
  echo assert_fails('echo 10->{a -> a + 2}', 'E107:')

  call assert_fails('eval 0->(', ""E110: Missing ')'"")
  call assert_fails('eval 0->(3)()', ""E1275:"")
  call assert_fails('eval 0->([3])()', ""E1275:"")
  call assert_fails('eval 0->({""a"": 3})()', ""E1275:"")
  call assert_fails('eval 0->(xxx)()', ""E121:"")
endfunc

func Test_not_lamda()

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    4774,
/**/
    4773,
/**/
"
Out-of-bounds Read in mrb_obj_is_kind_of in in mruby/mruby,CVE-2022-1427,CWE-125: Out-of-bounds Read,"        mrb_exc_set(mrb, exc);
        goto L_RAISE;
      }
      if ((target_class->flags & MRB_FL_CLASS_IS_PREPENDED) || target_class->tt == MRB_TT_MODULE) {



        target_class = mrb_vm_ci_target_class(ci);
        if (!target_class || target_class->tt != MRB_TT_ICLASS) {
          goto super_typeerror;
"
Heap-based Buffer Overflow in radareorg/radare2,CVE-2022-1437,CWE-122: Heap-based Buffer Overflow,"  for (i = 0; i < hdr->n_sections && cursor < end; i++) {
   ut8 *sect_start = cursor;
   RCoreSymCacheElementSection *sect = &result->sections[i];
   if (cursor + (word_size * 4) > end) {
    goto beach;
   }
   sect->vaddr = sect->paddr = r_read_ble (cursor, false, bits);
   if (sect->vaddr < page_zero_size) {
    sect->vaddr += page_zero_size;
    continue;
   }
   string_origin = relative_to_strings? b + start_of_strings : cursor;
   if (!string_origin) {
    cursor += R_CS_EL_SIZE_LSYM;
    continue;
   }
   lsym->flc.file = str_dup_safe (b, string_origin + file_name_off, end);
   if (!lsym->flc.file) {
    cursor += R_CS_EL_SIZE_LSYM;
}

static RList *symbols(RBinFile *bf) {
 r_return_val_if_fail (bf && bf->o && bf->o->bin_obj, NULL);

 RCoreSymCacheElement *element = bf->o->bin_obj;
 size_t i;
 HtUU *hash = ht_uu_new0 ();
 if (!hash) {
  return NULL;
 }
 RList *res = r_list_newf ((RListFree)r_bin_symbol_free);
 bool found = false;
 if (element->lined_symbols) {
  for (i = 0; i < element->hdr->n_lined_symbols; i++) {
   RCoreSymCacheElementSymbol *sym = (RCoreSymCacheElementSymbol *)&element->lined_symbols[i];
   if (!sym) {
    break;
   }
   ht_uu_find (hash, sym->paddr, &found);
   if (found) {
    continue;
   }
   RBinSymbol *s = bin_symbol_from_symbol (element, sym);
   if (s) {
    r_list_append (res, s);
    ht_uu_insert (hash, sym->paddr, 1);
   }
  }
 }
 if (element->symbols) {
"
heap-use-after-free in radareorg/radare2,CVE-2022-1444,CWE-416: Use After Free," r_return_val_if_fail (tree && data && cmp, false);
 bool inserted = false;

 if (!tree->root) {
  tree->root = _node_new (data, NULL);
  if (!tree->root) {
   return false;
  }
  inserted = true;
"
Out-of-bounds Read in r_bin_java_constant_value_attr_new function in radareorg/radare2,CVE-2022-1451,CWE-788: Access of Memory Location After End of Buffer,"}

R_API ut8 *r_bin_java_get_attr_buf(RBinJavaObj *bin, ut64 sz, const ut64 offset, const ut8 *buf, const ut64 len) {
 // XXX this pending is wrong and too expensive
 int pending = len - offset;
 const ut8 *a_buf = offset + buf;
 ut8 *attr_buf = (ut8 *) calloc (pending + 1, 1);
 if (!attr_buf) {
  eprintf (""Unable to allocate enough bytes (0x%04""PFMT64x
   "") to read in the attribute.\n"", sz);
 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 if (attr) {
  attr->type = R_BIN_JAVA_ATTR_TYPE_CONST_VALUE_ATTR;
  if (offset + 4 < sz) {
   attr->info.constant_value_attr.constantvalue_idx = R_BIN_JAVA_USHORT (buffer, offset);
  }
  offset += 2;
  attr->size = offset;
 }

R_API RBinJavaAttrInfo *r_bin_java_rti_annotations_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut32 i = 0;

 ut64 offset = 0;
 if (buf_offset + 32 >= sz) {
  return NULL;
 }
 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 offset += 6;
 if (attr) {
  attr->type = R_BIN_JAVA_ATTR_TYPE_RUNTIME_INVISIBLE_ANNOTATION_ATTR;
"
Out-of-bounds Read in r_bin_java_bootstrap_methods_attr_new function in radareorg/radare2,CVE-2022-1452,CWE-125: Out-of-bounds Read," offset += 6;
 if (attr) {
  attr->type = R_BIN_JAVA_ATTR_TYPE_BOOTSTRAP_METHODS_ATTR;
  if (offset + 8 > sz)  {
   free (attr);
   return NULL;
  }
  attr->info.bootstrap_methods_attr.num_bootstrap_methods = R_BIN_JAVA_USHORT (buffer, offset);
  offset += 2;
  attr->info.bootstrap_methods_attr.bootstrap_methods = r_list_newf (r_bin_java_bootstrap_method_free);
"
chafa: NULL Pointer Dereference in function gif_internal_decode_frame at libnsgif.c:599 allows attackers to cause a denial of service (crash) via a crafted input file. in hpjansson/chafa,CVE-2022-1507,CWE-476: NULL Pointer Dereference,"        unsigned int x, y, decode_y, burst_bytes;
        register unsigned char colour;

        /* If the GIF has no frame data, frame holders will not be allocated in
         * gif_initialise() */
        if (gif->frames == NULL) {
                return GIF_INSUFFICIENT_DATA;
        }

        /* Ensure this frame is supposed to be decoded */
        if (gif->frames[frame].display == false) {
                return GIF_OK;
"
Buffer Over-read in bfabiszewski/libmobi,CVE-2022-1533,CWE-126: Buffer Over-read,"2022-04-27: Fix wrong boundary checks in inflections parser resulting in stack buffer over-read with corrupt input
2022-04-26: Fix text formatting
2022-04-26: Fix array boundary check when parsing inflections which could result in buffer over-read with corrupt input
2022-04-23: Fix formatting
            }
            pos -= c - 10;
            dir = 0;




        }
        else {
            if (mod == 'i') {
                const unsigned char *s = decoded + pos;
                unsigned char *d = decoded + pos + 1;
                const int l = *decoded_size - pos;
                if (pos < 0 || l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) {
                    debug_print(""Out of buffer in %s at pos: %i\n"", decoded, pos);
                    return MOBI_DATA_CORRUPT;
                }
                const unsigned char *s = decoded + pos + 1;
                unsigned char *d = decoded + pos;
                const int l = *decoded_size - pos;
                if (pos < 0 || l < 0 || s + l > decoded + INDX_INFLBUF_SIZEMAX) {
                    debug_print(""Out of buffer in %s at pos: %i\n"", decoded, pos);
                    return MOBI_DATA_CORRUPT;
                }
"
Buffer Over-read at parse_rawml.c:1416 in bfabiszewski/libmobi,CVE-2022-1534,CWE-126: Buffer Over-read,"2022-04-26: Fix array boundary check when parsing inflections which could result in buffer over-read with corrupt input
2022-04-23: Fix formatting
2022-04-23: Fix checking boundary of deobfuscation key which could cause buffer over-read with corrupt data
2022-04-23: Fix issue with corrupt data with empty lookup string which could lead to read beyond buffer
2022-04-23: Fix faulty checks for array boundary which caused buffer over-read with corrupt input
2022-04-23: Fix issue with corrupt files with tagvalues_count = 0 that caused null pointer dereference
2022-04-23: Fix issues when mobi_buffer_getpointer returns null. With corrupt data this could lead to out-of-bounds read
2022-04-13: Add packaging status [skip ci]
2022-04-10: Make random generation return proper error codes

            unsigned char decoded[INDX_INFLBUF_SIZEMAX + 1];
            memset(decoded, 0, INDX_INFLBUF_SIZEMAX + 1);
            if (parts[j] >= infl->entries_count) {
                debug_print(""%s\n"", ""Invalid entry offset"");
                return MOBI_DATA_CORRUPT;
            }
            unsigned char *rule = (unsigned char *) infl->entries[parts[j]].label;
            memcpy(decoded, label, label_length);
            int decoded_length = (int) label_length;
"
Use after free in append_command in vim/vim,CVE-2022-1616,CWE-416: Use After Free,"
    STRCAT(IObuff, "": "");
    d = IObuff + STRLEN(IObuff);
    while (*s != NUL && d - IObuff + 5 < IOSIZE)
    {
 if (enc_utf8 ? (s[0] == 0xc2 && s[1] == 0xa0) : *s == 0xa0)
 {
     s += enc_utf8 ? 2 : 1;
     STRCPY(d, ""<a0>"");
     d += 4;
 }
 else if (d - IObuff + (*mb_ptr2len)(s) + 1 >= IOSIZE)
     break;
 else
     MB_COPY_CHAR(s, d);
    }
  set wildmenu&
endfunc

"" this was going over the end of IObuff
func Test_report_error_with_composing()
  let caught = 'no'
  try
    exe repeat('0', 987) .. ""0\xdd\x80\xdd\x80\xdd\x80\xdd\x80""
  catch /E492:/
    let caught = 'yes'
  endtry
  call assert_equal('yes', caught)
endfunc

"" Test for expanding 2-letter and 3-letter :substitute command arguments.
"" These commands don't accept an argument.
func Test_cmdline_complete_substitute_short()

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    4895,
/**/
    4894,
/**/
"
Heap-based Buffer Overflow in function cmdline_erase_chars in vim/vim,CVE-2022-1619,CWE-122: Heap-based Buffer Overflow," {
     while (p > ccline.cmdbuff && vim_isspace(p[-1]))
  --p;
     if (p > ccline.cmdbuff)
     {
  i = vim_iswordc(p[-1]);
  while (p > ccline.cmdbuff && !vim_isspace(p[-1])
   && vim_iswordc(p[-1]) == i)
      --p;
     }
 }
 else
     --p;

    call feedkeys("":abc def\<S-Left>\<C-U>\<C-B>\""\<CR>"", 'tx')
    call assert_equal('""def', @:, e)

    "" This was going before the start in latin1.
    call feedkeys("": \<C-W>\<CR>"", 'tx')
  endfor

  let &encoding = encoding_save

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    4899,
/**/
    4898,
/**/
"
NULL Pointer Dereference in function vim_regexec_string at regexp.c:2729 in vim/vim,CVE-2022-1620,CWE-476: NULL Pointer Dereference," rmp->rm_ic = p_fic || ignore_case;
 if (vim_regexec(rmp, name, (colnr_T)0))
     match = name;
 else if (rmp->regprog != NULL)
 {
     // Replace $(HOME) with '~' and try matching again.
     p = home_replace_save(NULL, name);
  set shellslash&
endfunc

"" this was using a NULL pointer after failing to use the pattern
func Test_buf_pattern_invalid()
  vsplit 0000000
  silent! buf [0--]\&\zs*\zs*e
  bwipe!
endfunc

"" Test for the 'maxmem' and 'maxmemtot' options
func Test_buffer_maxmem()
  "" use 1KB per buffer and 2KB for all the buffers

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    4901,
/**/
    4900,
/**/
"
Heap buffer overflow in vim_strncpy find_word in vim/vim,CVE-2022-1621,CWE-122: Heap-based Buffer Overflow,"EXTERN char e_missing_close_curly_str[]
 INIT(= N_(""E1279: Missing '}': %s""));
#endif
#ifdef FEAT_SPELL
EXTERN char e_illegal_character_in_word[]
 INIT(= N_(""E1280: Illegal character in word""));
#endif
    convert_setup(&vimconv, NULL, NULL);
}

#if defined(FEAT_GUI_GTK) || defined(FEAT_SPELL) || defined(PROTO)
/*
 * Return TRUE if string ""s"" is a valid utf-8 string.
 * When ""end"" is NULL stop at the first NUL.
    int  res = OK;
    char_u *p;

    // Avoid adding illegal bytes to the word tree.
    if (enc_utf8 && !utf_valid_string(word, NULL))
 return FAIL;

    (void)spell_casefold(curwin, word, len, foldword, MAXWLEN);
    for (p = pfxlist; res == OK; ++p)
    {
    int  i;
    char_u *spf;

    if (enc_utf8 && !utf_valid_string(word, NULL))
    {
 emsg(_(e_illegal_character_in_word));
 return;
    }

    if (idx == 0)     // use internal wordlist
    {
 if (int_wordlist == NULL)
  bwipe!
endfunc

"" Invalid bytes may cause trouble when creating the word list.
func Test_check_for_valid_word()
  call assert_fails(""spellgood! 0\xac"", 'E1280:')
endfunc


"" vim: shiftwidth=2 sts=2 expandtab
"
Buffer Over-read in function find_next_quote in vim/vim,CVE-2022-1629,CWE-126: Buffer Over-read,"    call assert_equal(""<div><div\nattr=\""attr\""\n></div></div>"", @"", e)

    set quoteescape&

    "" this was going beyond the end of the line
    %del
    sil! norm i""\
    sil! norm i""\
    sil! norm i""\
    call assert_equal('""\', getline(1))

    bwipe!
  endfor

  set enc=utf-8

endfunc

func Test_empty_html_tag()
 if (c == NUL)
     return -1;
 else if (escape != NULL && vim_strchr(escape, c))
 {
     ++col;
     if (line[col] == NUL)
  return -1;
 }
 else if (c == quotechar)
     break;
 if (has_mbyte)

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    4925,
/**/
    4924,
/**/
"
Null pointer dereference in libr/bin/format/mach0/mach0.c in radareorg/radare2 in radareorg/radare2,CVE-2022-1649,CWE-476: NULL Pointer Dereference,"    if (page_idx >= bin->chained_starts[i]->page_count) {
     break;
    }
    if (!bin->chained_starts[i]->page_start) {
     break;
    }
    ut16 page_start = bin->chained_starts[i]->page_start[page_idx];
    if (page_start == DYLD_CHAINED_PTR_START_NONE) {
     continue;
"
NULL Pointer Dereference in function vim_regexec_string at regexp.c:2733 in vim/vim,CVE-2022-1674,CWE-476: NULL Pointer Dereference,"
    // First try the short file name, then the long file name.
    match = fname_match(rmp, buf->b_sfname, ignore_case);
    if (match == NULL && rmp->regprog != NULL)
 match = fname_match(rmp, buf->b_ffname, ignore_case);

    return match;
  vsplit 0000000
  silent! buf [0--]\&\zs*\zs*e
  bwipe!

  vsplit 00000000000000000000000000
  silent! buf [0--]\&\zs*\zs*e
  bwipe!
endfunc

"" Test for the 'maxmem' and 'maxmemtot' options

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    4938,
/**/
    4937,
/**/
"
Heap-based Buffer Overflow in radareorg/radare2,CVE-2022-1714,CWE-122: Heap-based Buffer Overflow,"#include ""../arch/msp430/msp430_disas.h""

static int msp430_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *buf, int len, RAnalOpMask mask) {
 struct msp430_cmd cmd = {0};




 op->size = -1;
 op->nopcode = 1;
 op->type = R_ANAL_OP_TYPE_UNK;
 op->family = R_ANAL_OP_FAMILY_CPU;

 int ret = op->size = msp430_decode_command (buf, len, &cmd);
 if (mask & R_ANAL_OP_MASK_DISASM) {
  if (ret < 1) {
   op->mnemonic = strdup (""invalid"");
  case MSP430_CALL:
   op->type = R_ANAL_OP_TYPE_CALL;
   op->fail = addr + op->size;
   if (len > 4) {
    op->jump = r_read_at_le16 (buf, 2);
   }
   break;
  case MSP430_RETI:
   op->type = R_ANAL_OP_TYPE_RET;
 const char *p = \
  ""=PC pc\n""
  ""=SP sp\n""
  ""=SN r0\n""
  // this is the ""new"" ABI, the old was reverse order
  ""=A0 r12\n""
  ""=A1 r13\n""
 ut8 ehdr[sizeof (Elf_(Ehdr))] = {0};
 int i, len;
 if (r_buf_read_at (bin->b, 0, e_ident, EI_NIDENT) == -1) {
  R_LOG_DEBUG (""read (magic)"");
  return false;
 }
 sdb_set (bin->kv, ""elf_type.cparse"", ""enum elf_type { ET_NONE=0, ET_REL=1,""
 memset (&bin->ehdr, 0, sizeof (Elf_(Ehdr)));
 len = r_buf_read_at (bin->b, 0, ehdr, sizeof (ehdr));
 if (len < 32) { // tinyelf != sizeof (Elf_(Ehdr))) {
  R_LOG_DEBUG (""read (ehdr)"");
  return false;
 }
 // XXX no need to check twice
  const size_t rsize = bin->ehdr.e_phoff + i * sizeof (Elf_(Phdr));
  int len = r_buf_read_at (bin->b, rsize, phdr, sizeof (Elf_(Phdr)));
  if (len < 1) {
   R_LOG_DEBUG (""read (phdr)"");
   R_FREE (bin->phdr);
   return false;
  }
  j = 0;
  len = r_buf_read_at (bin->b, bin->ehdr.e_shoff + i * sizeof (Elf_(Shdr)), shdr, sizeof (Elf_(Shdr)));
  if (len < 1) {
   R_LOG_DEBUG (""read (shdr) at 0x%"" PFMT64x, (ut64) bin->ehdr.e_shoff);
   R_FREE (bin->shdr);
   return false;
  }
 int res = r_buf_read_at (bin->b, bin->shstrtab_section->sh_offset, (ut8*)bin->shstrtab,
  bin->shstrtab_section->sh_size);
 if (res < 1) {
  R_LOG_DEBUG (""read (shstrtab) at 0x%"" PFMT64x, (ut64) bin->shstrtab_section->sh_offset);
  R_FREE (bin->shstrtab);
  return false;
 }
 }
 Elf_(Verdef) *defs = calloc (shdr->sh_size, 1);
 if (!defs) {
  R_LOG_DEBUG (""Cannot allocate memory (Check Elf_(Verdef))"");
  return false;
 }
 if (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {
  return UT64_MAX;
 }
 if (r_buf_read_at (bin->b, entry + 16, buf, sizeof (buf)) < 1) {
  R_LOG_DEBUG (""read (init_offset)"");
  return 0;
 }
 if (buf[0] == 0x68) { // push // x86 only
"
Buffer Over-read in function grab_file_name in vim/vim,CVE-2022-1720,CWE-126: Buffer Over-read," }
 if (**pp == NUL)
     *lenp = 0;
 if (*lenp > 0)
 {
     if (has_mbyte)
  // Correct the length to include all bytes of the last
  // character.
  *lenp += (*mb_ptr2len)(*pp + (*lenp - 1)) - 1;
     else if ((*pp)[*lenp - 1] == NUL)
  // Do not include a trailing NUL.
  *lenp -= 1;
 }
    }
    reset_VIsual_and_resel();
    return OK;
  call assert_equal('Xtest_gf_visual', bufname('%'))
  call assert_equal(3, getcurpos()[1])

  "" do not include the NUL at the end 
  call writefile(['x'], 'X')
  let save_enc = &enc
  for enc in ['latin1', 'utf-8']
    exe ""set enc="" .. enc
    new
    call setline(1, 'X')
    set nomodified
    exe ""normal \<C-V>$gf""
    call assert_equal('X', bufname())
    bwipe!
  endfor
  let &enc = save_enc
  call delete('X')

  "" line number in visual area is used for file name
  if has('unix')
    bwipe!

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    4956,
/**/
    4955,
/**/
"
NULL Pointer Dereference in function vim_regexec_string in vim/vim,CVE-2022-1725,CWE-476: NULL Pointer Dereference,"  if (*p == '^' && !(attempt & 1))  // add/remove '^'
      ++p;
  regmatch.regprog = vim_regcomp(p, magic_isset() ? RE_MAGIC : 0);






  FOR_ALL_BUFS_FROM_LAST(buf)
  {
      if (regmatch.regprog == NULL)
      {
   // invalid pattern, possibly after switching engine
   vim_free(pat);
   return -1;
      }
      if (buf->b_p_bl == find_listed
#ifdef FEAT_DIFF
       && (!diffmode || diff_mode_buf(buf))
   }
   match = buf->b_fnum; // remember first match
      }
  }

  vim_regfree(regmatch.regprog);
  if (match >= 0)   // found one match
     if (attempt > 0 && patc == pat)
  break; // there was no anchor, no need to try again
     regmatch.regprog = vim_regcomp(patc + attempt * 11, RE_MAGIC);






 }

 // round == 1: Count the matches.
#endif

  if (!fuzzy)
  {
      if (regmatch.regprog == NULL)
      {
   // invalid pattern, possibly after recompiling
   if (patc != pat)
       vim_free(patc);
   return FAIL;
      }
      p = buflist_match(&regmatch, buf, p_wic);
  }
  else
  {
      p = NULL;

/*
 * Check for a match on the file name for buffer ""buf"" with regprog ""prog"".
 * Note that rmp->regprog may become NULL when switching regexp engine.
 */
    static char_u *
buflist_match(
}

/*
 * Try matching the regexp in ""rmp->regprog"" with file name ""name"".
 * Note that rmp->regprog may become NULL when switching regexp engine.
 * Return ""name"" when there is a match, NULL when not.
 */
    static char_u *
    char_u *match = NULL;
    char_u *p;

    // extra check for valid arguments
    if (name != NULL && rmp->regprog != NULL)
    {
 // Ignore case when 'fileignorecase' or the argument is set.
 rmp->rm_ic = p_fic || ignore_case;
  vsplit 00000000000000000000000000
  silent! buf [0--]\&\zs*\zs*e
  bwipe!

  "" similar case with different code path
  split 0
  edit ÿ
  silent! buf [0--]\&\zs*\zs*0
  bwipe!
endfunc

"" Test for the 'maxmem' and 'maxmemtot' options

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    4959,
/**/
    4958,
/**/
"
Heap-based Buffer Overflow in function skip_string in vim/vim,CVE-2022-1733,CWE-122: Heap-based Buffer Overflow,"  while (vim_isdigit(p[i - 1]))   // '\000'
      ++i;
     }
     if (p[i - 1] != NUL && p[i] == '\'')    // check for trailing '
     {
  p += i;
  continue;
  close!
endfunc

"" This was reading past the end of the line
func Test_cindent_check_funcdecl()
  new
  sil norm o0('\0=L
  bwipe!
endfunc

func Test_cindent_scopedecls()
  new
  setl cindent ts=4 sw=4

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    4968,
/**/
    4967,
/**/
"
Buffer Over-read in function utfc_ptr2len in vim/vim,CVE-2022-1735,CWE-120: Classic Buffer Overflow," curwin->w_changelistidx = curbuf->b_changelistlen;
    }

    if (VIsual_active)
 check_visual_pos();

    FOR_ALL_TAB_WINDOWS(tp, wp)
    {
 if (wp->w_buffer == curbuf)

     // <C-S-Right> may have started Visual mode, adjust the position for
     // deleted characters.
     if (VIsual_active)
  check_visual_pos();








 }
    }
    did_ai = FALSE;
    check_cursor_col();
}

/*
 * Check if VIsual position is valid, correct it if not.
 * Can be called when in Visual mode and a change has been made.
 */
    void
check_visual_pos(void)
{
    if (VIsual.lnum > curbuf->b_ml.ml_line_count)
    {
 VIsual.lnum = curbuf->b_ml.ml_line_count;
 VIsual.col = 0;
 VIsual.coladd = 0;
    }
    else
    {
 int len = (int)STRLEN(ml_get(VIsual.lnum));

 if (VIsual.col > len)
 {
     VIsual.col = len;
     VIsual.coladd = 0;
 }
    }
}

#if defined(FEAT_TEXTOBJ) || defined(PROTO)
/*
 * Make sure curwin->w_cursor is not on the NUL at the end of the line.
    return OK;
}

#if defined(EXITFREE) || defined(PROTO)
/*
 * Free the memory allocated by get_user_name()
 */
void check_cursor_col(void);
void check_cursor_col_win(win_T *win);
void check_cursor(void);
void check_visual_pos(void);
void adjust_cursor_col(void);
int leftcol_changed(void);
int copy_option_part(char_u **option, char_u *buf, int maxlen, char *sep_chars);
  set isprint&
endfunc

func Test_visual_block_with_substitute()
  "" this was reading beyond the end of the line
  new
  norm a0)
  sil! norm  O
  s/)
  sil! norm 
  bwipe!
endfunc

func Test_visual_reselect_with_count()
  "" this was causing an illegal memory access
  let lines =<< trim END

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    4969,
/**/
    4968,
/**/
"
Buffer Over-read in function get_one_sourceline in vim/vim,CVE-2022-1769,CWE-126: Buffer Over-read,"  break;
     buf = (char_u *)ga.ga_data;
     buf[ga.ga_len++] = NUL;
     len = ga.ga_len;
 }
 else
 {
     buf = (char_u *)ga.ga_data;
     if (fgets((char *)buf + ga.ga_len, ga.ga_maxlen - ga.ga_len,
   sp->fp) == NULL)
  break;
     len = ga.ga_len + (int)STRLEN(buf + ga.ga_len);
 }

#ifdef USE_CRNL
 // Ignore a trailing CTRL-Z, when in Dos mode. Only recognize the
 // CTRL-Z by its own, or after a NL.
  norm300gr0
  so
  bwipe!

  let lines =<< trim END
      new
      norm 10a0000000000ø00000000000
      norm i0000000000000000000
      silent! so
  END
  call writefile(lines, 'Xtest.vim')
  source Xtest.vim
  bwipe!
  call delete('Xtest.vim')
endfunc



static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    4974,
/**/
    4973,
/**/
"
Infinite recursive function calls result in stack overflow in vim/vim,CVE-2022-1771,CWE-674: Uncontrolled Recursion,"    int  indent,  // indent for inside conditionals
    int  clear_ccline) // clear ccline first
{
    static int depth = 0;     // call depth
    int  c;
    int  i;
    int  j;
    int  cmdline_type;
    int  wild_type;

    // one recursion level deeper
    ++depth;

    if (ccline.cmdbuff != NULL)
    {
 // Being called recursively.  Since ccline is global, we need to save
    if (init_ccline(firstc, indent) != OK)
 goto theend; // out of memory

    if (depth == 50)
    {
 // Somehow got into a loop recursively calling getcmdline(), bail out.
 emsg(_(e_command_too_recursive));
 goto theend;
    }

    ExpandInit(&xpc);
    ccline.xpc = &xpc;

    {
 char_u *p = ccline.cmdbuff;

 --depth;
 if (did_save_ccline)
     restore_cmdline(&save_ccline);
 else
  call feedkeys("":let a\<C-R>=Check_completion()\<CR>\<Esc>"", ""xt"")
endfunc

func Test_recursive_register()
  let @= = ''
  silent! ?e/
  let caught = 'no'
  try
    normal // 
  catch /E169:/
    let caught = 'yes'
  endtry
  call assert_equal('yes', caught)
endfunc

"" vim: shiftwidth=2 sts=2 expandtab

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    4975,
/**/
    4974,
/**/
"
Out-of-bounds write in function vim_regsub_both in vim/vim,CVE-2022-1785,CWE-787: Out-of-bounds Write,"  // Save flags for recursion.  They can change for e.g.
  // :s/^/\=execute(""s#^##gn"")
  subflags_save = subflags;

  // Disallow changing text or switching window in an expression.
  ++textwinlock;
#endif
  // get length of substitution part
  sublen = vim_regsub_multi(&regmatch,
        sub_firstlnum - regmatch.startpos[0].lnum,
          sub, sub_firstline, FALSE, magic_isset(), TRUE);
#ifdef FEAT_EVAL
  --textwinlock;

  // If getting the substitute string caused an error, don't do
  // the replacement.
  // Don't keep flags set by a recursive call.
  mch_memmove(new_end, sub_firstline + copycol, (size_t)copy_len);
  new_end += copy_len;

#ifdef FEAT_EVAL
  ++textwinlock;
#endif
  (void)vim_regsub_multi(&regmatch,
        sub_firstlnum - regmatch.startpos[0].lnum,
          sub, new_end, TRUE, magic_isset(), TRUE);
#ifdef FEAT_EVAL
  --textwinlock;
#endif
  sub_nsubs++;
  did_sub = TRUE;

  set nocompatible
endfunc

"" This was switching windows in between computing the length and using it.
func Test_sub_change_window()
  silent! lfile
  sil! norm o0000000000000000000000000000000000000000000000000000
  func Repl()
    lopen
  endfunc
  silent!  s/\%')/\=Repl()
  bwipe!
  bwipe!
  delfunc Repl
endfunc

"" Test for the 2-letter and 3-letter :substitute commands
func Test_substitute_short_cmd()
  new

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    4977,
/**/
    4976,
/**/
"
Use After Free in gpac/gpac,CVE-2022-1795,CWE-416: Use After Free," codec->scenegraph->global_qp = NULL;

 if (gf_node_get_tag(node) != TAG_MPEG4_QuantizationParameter) {
  //if node was just created (num_instances == 0), unregister
  //otherwise (USE node) don't do anything
  if (!node->sgprivate->num_instances) {
   node->sgprivate->num_instances = 1;
   gf_node_unregister(node, NULL);
  }
  return GF_NON_COMPLIANT_BITSTREAM;
 }

 codec->scenegraph->global_qp = node;

 /*register TWICE: once for the command, and for the scenegraph globalQP*/
 gf_node_unregister(node, NULL);
 gf_node_unregister(node, NULL);

 com = gf_sg_command_new(codec->current_graph, GF_SG_GLOBAL_QUANTIZER);
 inf = gf_sg_command_field_new(com);
"
heap-use-after-free in function find_pattern_in_path in vim/vim,CVE-2022-1796,CWE-416: Use After Free,"  close!
endfunc

func Test_define_search()
  "" this was accessing freed memory
  new
  call setline(1, ['first line', '', '#define something 0'])
  sil norm o0
  sil! norm 
  bwipe!
endfunc

"" Test for [*, [/, ]* and ]/
func Test_comment_search()
  new

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    4979,
/**/
    4978,
/**/
  CHECK_CMDWIN;
  if ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)
      break;

  // Make a copy, if the line was changed it will be freed.
  ptr = vim_strnsave(ptr, len);
  if (ptr == NULL)
      break;

  find_pattern_in_path(ptr, 0, len, TRUE,
   Prenum == 0 ? TRUE : FALSE, type,
   Prenum1, ACTION_SPLIT, (linenr_T)1, (linenr_T)MAXLNUM);
  vim_free(ptr);
  curwin->w_set_curswant = TRUE;
  break;
#endif
"
Use of Uninitialized Function Pointer in radareorg/radare2,CVE-2022-1809,CWE-824: Access of Uninitialized Pointer,"  context->read_addr = be? vtable_read_addr_be64 : vtable_read_addr_le64;
  break;
 default:
  // cant be null. assume 32bit ""->read_addr = NULL;
  context->read_addr = be? vtable_read_addr_be32 : vtable_read_addr_le32;
  return false;
 }
 return true;

static bool vtable_is_value_in_text_section(RVTableContext *context, ut64 curAddress, ut64 *value) {
 //value at the current address
 ut64 curAddressValue = UT64_MAX;
 if (!context->read_addr (context->anal, curAddress, &curAddressValue)) {
  return false;
 }
}

static bool vtable_is_addr_vtable_start_msvc(RVTableContext *context, ut64 curAddress) {
 ut8 buf[VTABLE_BUFF_SIZE];
 RAnalRef *xref;
 RListIter *xrefIter;

 r_list_foreach (xrefs, xrefIter, xref) {
  // section in which currenct xref lies
  if (vtable_addr_in_text_section (context, xref->addr)) {
   context->anal->iob.read_at (context->anal->iob.io, xref->addr, buf, sizeof (buf));


   RAnalOp analop = {0};
   r_anal_op (context->anal, &analop, xref->addr, buf, sizeof (buf), R_ANAL_OP_MASK_BASIC);
   if (analop.type == R_ANAL_OP_TYPE_MOV || analop.type == R_ANAL_OP_TYPE_LEA) {


    r_list_free (xrefs);
    r_anal_op_fini (&analop);
    return true;
   }

   r_anal_op_fini (&analop);
  }
 }
}

R_API void r_anal_list_vtables(RAnal *anal, int rad) {
 RVTableContext context = {0};
 r_anal_vtable_begin (anal, &context);

 const char *noMethodName = ""No Name found"";
"
Out-of-bounds read in function gchar_cursor in vim/vim,CVE-2022-1851,CWE-125: Out-of-bounds Read,"  close!
endfunc

"" This was leaving the cursor after the end of a line.  Complicated way to
"" have the problem show up with valgrind.
func Test_correct_cursor_position()
  set encoding=iso8859
  new
  norm a0000
  sil! norm gggg0i0gw0gg

  bwipe!
  set encoding=utf8
endfunc

"" vim: shiftwidth=2 sts=2 expandtab
    {
 curwin->w_cursor = saved_cursor;
 saved_cursor.lnum = 0;

 // formatting may have made the cursor position invalid
 check_cursor();
    }

    if (oap->is_VIsual)

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    5013,
/**/
    5012,
/**/
"
Heap-based Buffer Overflow in function utf_head_off in vim/vim,CVE-2022-1886,CWE-122: Heap-based Buffer Overflow,"     len = STRLEN(y_array[y_size - 1]);
     col = (colnr_T)len - lendiff;
     if (col > 1)
     {
  curbuf->b_op_end.col = col - 1;
  if (len > 0)
      curbuf->b_op_end.col -= mb_head_off(y_array[y_size - 1],
      y_array[y_size - 1] + len - 1);
     }
     else
  curbuf->b_op_end.col = 0;

  bwipe!
endfunc

"" this was putting a mark before the start of a line
func Test_put_empty_register()
  new
  norm yy
  norm [Pi00ggv)s0
  sil! norm [P
  bwipe!
endfunc


"" vim: shiftwidth=2 sts=2 expandtab

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    5016,
/**/
    5015,
/**/
"
Out-of-bounds write in function vim_regsub_both in vim/vim,CVE-2022-1897,CWE-787: Out-of-bounds Write,"    return idx;
}

/*
 * If currently editing a cmdline or text is locked: beep and give an error
 * message, return TRUE.
 */
    static int
check_text_locked(oparg_T *oap)
{
    if (text_locked())
    {
 clearopbeep(oap);
 text_locked_msg();
 return TRUE;
    }
    return FALSE;
}

/*
 * Handle the count before a normal command and set cap->count0.
 */
 goto normal_end;
    }

    if ((nv_cmds[idx].cmd_flags & NV_NCW)
    && (check_text_locked(oap) || curbuf_locked()))
 // this command is not allowed now





 goto normal_end;

    // In Visual/Select mode, a few keys are handled in a special way.
    char_u *ptr;
    linenr_T lnum = -1;

    if (check_text_locked(cap->oap))



 return;

    if (curbuf_locked())
    {
 clearop(cap->oap);

    // ""gQ"": improved Ex mode
    case 'Q':
 if (!check_text_locked(cap->oap) && !checkclearopq(oap))







     do_exmode(TRUE);
 break;

  delfunc Repl
endfunc

"" This was undoign a change in between computing the length and using it.
func Do_Test_sub_undo_change()
  new
  norm o0000000000000000000000000000000000000000000000000000
  silent! s/\%')/\=Repl()
  bwipe!
endfunc

func Test_sub_undo_change()
  func Repl()
    silent! norm g-
  endfunc
  call Do_Test_sub_undo_change()

  func! Repl()
    silent earlier
  endfunc
  call Do_Test_sub_undo_change()

  delfunc Repl
endfunc

"" Test for the 2-letter and 3-letter :substitute commands
func Test_substitute_short_cmd()
  new
    int      above = FALSE;
    int      did_undo = TRUE;

    if (text_locked())
    {
 text_locked_msg();
 return;
    }

    // First make sure the current undoable change is synced.
    if (curbuf->b_u_synced == FALSE)
 u_sync(TRUE);

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    5023,
/**/
    5022,
/**/
"
Use After Free in function find_pattern_in_path in vim/vim,CVE-2022-1898,CWE-416: Use After Free,"     clearop(cap->oap);
 else
 {
     // Make a copy, if the line was changed it will be freed.
     ptr = vim_strnsave(ptr, len);
     if (ptr == NULL)
  return;

     find_pattern_in_path(ptr, 0, len, TRUE,
  cap->count0 == 0 ? !isupper(cap->nchar) : FALSE,
  ((cap->nchar & 0xf) == ('d' & 0xf)) ?  FIND_DEFINE : FIND_ANY,
       islower(cap->nchar) ? ACTION_SHOW : ACTION_GOTO,
  cap->cmdchar == ']' ? curwin->w_cursor.lnum + 1 : (linenr_T)1,
  (linenr_T)MAXLNUM);
     vim_free(ptr);
     curwin->w_set_curswant = TRUE;
 }
    }
  sil norm o0
  sil! norm 
  bwipe!

  new somefile
  call setline(1, ['first line', '', '#define something 0'])
  sil norm 0o0
  sil! norm ]d
  bwipe!
endfunc

"" Test for [*, [/, ]* and ]/

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    5024,
/**/
    5023,
/**/
"
Out of Bounds Read in string_scan_range in radareorg/radare2,CVE-2022-1899,CWE-125: Out-of-bounds Read," free (charset);
 RConsIsBreaked is_breaked = (bin && bin->consb.is_breaked)? bin->consb.is_breaked: NULL;
 // may oobread
 while (needle < to && needle < UT64_MAX - 4) {
  if (is_breaked && is_breaked ()) {
   break;
  }
  // smol optimization
  if (needle < to - 4) {
   ut32 n1 = r_read_le32 (buf + (needle - from));
   if (!n1) {
    needle += 4;
    continue;
   }
  }
  rc = r_utf8_decode (buf + (needle - from), to - needle, NULL);
  if (!rc) {
   needle++;
   continue;
  }
  bool addr_aligned = !(needle % 4);

  if (type == R_STRING_TYPE_DETECT) {
   char *w = (char *)buf + (needle + rc - from);
   if (((to - needle) > 8 + rc)) {
    // TODO: support le and be
    bool is_wide32le = (needle + rc + 2 < to) && (!w[0] && !w[1] && !w[2] && w[3] && !w[4]);
     rc = 2;
    }
   } else {
    rc = r_utf8_decode (buf + (needle - from), to - needle, &r);
    if (rc > 1) {
     str_type = R_STRING_TYPE_UTF8;
    }
"
heap-buffer-overflow in mobi_get_attribute_value in bfabiszewski/libmobi,CVE-2022-1907,CWE-126: Buffer Over-read,"2022-05-03: Fix boundary checking error in markup search, that could cause buffer over-read with corrupt input
2022-05-02: Fix typo in macro name
2022-04-27: Fix undefined behavior when passing null to strdup
2022-04-27: Fix wrong boundary checks in inflections parser resulting in stack buffer over-read with corrupt input
                    result->value[i++] = (char) *data++;
                }
                /* self closing tag '/>' */
                if (data <= data_end && *(data - 1) == '/' && *data == '>') {
                    --data; --i;
                }
                result->end = data;
                result->value[i++] = (char) *data++;
            }
            /* self closing tag '/>' */
            if (data <= data_end && *(data - 1) == '/' && *data == '>') {
                --data; --i;
            }
            result->end = data;
                length--;
            }
            /* self closing tag '/>' */
            if (length && *(data - 1) == '/' && *data == '>') {
                value--;
            }
            *value = '\0';
"
Heap-buffer-overflow in mobi_search_links_kf7 in bfabiszewski/libmobi,CVE-2022-1908,CWE-126: Buffer Over-read,"2022-05-03: Fix boundary checking error in markup search, that could cause buffer over-read with corrupt input
2022-05-02: Fix typo in macro name
2022-04-27: Fix undefined behavior when passing null to strdup
2022-04-27: Fix wrong boundary checks in inflections parser resulting in stack buffer over-read with corrupt input
                    result->value[i++] = (char) *data++;
                }
                /* self closing tag '/>' */
                if (data <= data_end && *(data - 1) == '/' && *data == '>') {
                    --data; --i;
                }
                result->end = data;
                result->value[i++] = (char) *data++;
            }
            /* self closing tag '/>' */
            if (data <= data_end && *(data - 1) == '/' && *data == '>') {
                --data; --i;
            }
            result->end = data;
                length--;
            }
            /* self closing tag '/>' */
            if (length && *(data - 1) == '/' && *data == '>') {
                value--;
            }
            *value = '\0';
"
Buffer Over-read in function utf_ptr2char in vim/vim,CVE-2022-1927,CWE-126: Buffer Over-read,"{
    int  address_count = 1;
    linenr_T lnum;
    int  need_check_cursor = FALSE;
    int  ret = FAIL;

    // Repeat for all ',' or ';' separated addresses.
    for (;;)
 lnum = get_address(eap, &eap->cmd, eap->addr_type, eap->skip, silent,
     eap->addr_count == 0, address_count++);
 if (eap->cmd == NULL) // error detected
     goto theend;
 if (lnum == MAXLNUM)
 {
     if (*eap->cmd == '%')   // '%' - all lines
       // there is no Vim command which uses '%' and
       // ADDR_WINDOWS or ADDR_TABS
       *errormsg = _(e_invalid_range);
       goto theend;
   }
   break;
      case ADDR_TABS_RELATIVE:
      case ADDR_UNSIGNED:
      case ADDR_QUICKFIX:
   *errormsg = _(e_invalid_range);
   goto theend;
      case ADDR_ARGUMENTS:
   if (ARGCOUNT == 0)
       eap->line1 = eap->line2 = 0;
  if (eap->addr_type != ADDR_LINES)
  {
      *errormsg = _(e_invalid_range);
      goto theend;
  }

  ++eap->cmd;
  if (!eap->skip)
  {
      fp = getmark('<', FALSE);
      if (check_mark(fp) == FAIL)
   goto theend;
      eap->line1 = fp->lnum;
      fp = getmark('>', FALSE);
      if (check_mark(fp) == FAIL)
   goto theend;
      eap->line2 = fp->lnum;
      ++eap->addr_count;
  }
     if (!eap->skip)
     {
  curwin->w_cursor.lnum = eap->line2;

  // Don't leave the cursor on an illegal line or column, but do
  // accept zero as address, so 0;/PATTERN/ works correctly.
  // Check the cursor position before returning.
  if (eap->line2 > 0)
      check_cursor();
  need_check_cursor = TRUE;
     }
 }
 else if (*eap->cmd != ',')
 if (lnum == MAXLNUM)
     eap->addr_count = 0;
    }
    ret = OK;

theend:
    if (need_check_cursor)
 check_cursor();
    return ret;
}

/*
  bwipe!
endfunc

"" This was leaving the cursor in line zero
func Test_using_zero_in_range()
  new
  norm o00
  silent!  0;s/\%')
  bwipe!
endfunc


"" vim: shiftwidth=2 sts=2 expandtab

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    5037,
/**/
    5036,
/**/
"
Use-After-Free in function hash_new_from_values in mruby/mruby,CVE-2022-1934,CWE-416: Use After Free,"  return target;
}

#define regs (mrb->c->ci->stack)

static mrb_value
hash_new_from_regs(mrb_state *mrb, mrb_int argc, mrb_int idx)
{
  mrb_value hash = mrb_hash_new_capa(mrb, argc);
  while (argc--) {
    mrb_hash_set(mrb, hash, regs[idx+0], regs[idx+1]);
    idx += 2;
  }
  return hash;
}

#define ARGUMENT_NORMALIZE(arg_base, arg_info, insn) do {       \
  int n = *(arg_info)&0xf; \
  int nk = (*(arg_info)>>4)&0xf; \
  mrb_int bidx = (arg_base) + mrb_bidx(*(arg_info)); \
  } \
  else if (nk > 0) {  /* pack keyword arguments */ \
    mrb_int kidx = (arg_base)+(n==CALL_MAXARGS?1:n)+1; \
    mrb_value kdict = hash_new_from_regs(mrb, nk, kidx); \
    regs[kidx] = kdict; \
    nk = CALL_MAXARGS; \
    *(arg_info) = n | (nk<<4); \
  mrb->jmp = &c_jmp;
  mrb_vm_ci_proc_set(mrb->c->ci, proc);


  INIT_DISPATCH {
    CASE(OP_NOP, Z) {
      /* do nothing */
"
Heap-based Buffer Overflow in function vim_regsub_both in vim/vim,CVE-2022-1942,CWE-122: Heap-based Buffer Overflow,"    if (buf == curbuf)
 return OK;

    if (text_or_buf_locked())





 return FAIL;

    // altfpos may be changed by getfile(), get it now
    return e_not_allowed_to_change_text_or_change_window;
}

/*
 * Check for text, window or buffer locked.
 * Give an error message and return TRUE if something is locked.
 */
    int
text_or_buf_locked(void)
{
    if (text_locked())
    {
 text_locked_msg();
 return TRUE;
    }
    return curbuf_locked();
}

/*
 * Check if ""curbuf_lock"" or ""allbuf_lock"" is set and return TRUE when it is
 * and give an error message.
    int   save_KeyTyped;
#endif

    // Can't do this when text or buffer is locked.
    if (text_or_buf_locked())
 return K_IGNORE;

    // Can't do this recursively.  Can't do it when typing a password.
    if (cmdwin_type != 0
# if defined(FEAT_CRYPT) || defined(FEAT_EVAL)
char_u *getcmdline(int firstc, long count, int indent, getline_opt_T do_concat);
char_u *getcmdline_prompt(int firstc, char_u *prompt, int attr, int xp_context, char_u *xp_arg);
int check_opt_wim(void);
int text_locked(void);
void text_locked_msg(void);
char *get_text_locked_msg(void);
int text_or_buf_locked(void);
int curbuf_locked(void);
int allbuf_locked(void);
char_u *getexline(int c, void *cookie, int indent, getline_opt_T options);
void f_getcmdcompltype(typval_T *argvars, typval_T *rettv);
void f_getcmdline(typval_T *argvars, typval_T *rettv);
void f_getcmdpos(typval_T *argvars, typval_T *rettv);

void f_getcmdscreenpos(typval_T *argvars, typval_T *rettv);
void f_setcmdpos(typval_T *argvars, typval_T *rettv);
void f_getcmdtype(typval_T *argvars, typval_T *rettv);
int get_cmdline_firstc(void);
int get_list_range(char_u **str, int *num1, int *num2);
  delfunc Repl
endfunc

"" This was opening a command line window from the expression
func Test_sub_open_cmdline_win()
  "" the error only happens in a very specific setup, run a new Vim instance to
  "" get a clean starting point.
  let lines =<< trim [SCRIPT]
    norm o0000000000000000000000000000000000000000000000000000
    func Replace()
      norm q/
    endfunc
    s/\%')/\=Replace()
    redir >Xresult
    messages
    redir END
    qall!
  [SCRIPT]
  call writefile(lines, 'Xscript')
  if RunVim([], [], '-u NONE -S Xscript')
    let messages = readfile('Xresult')
    call assert_match('E565: Not allowed to change text or change window', messages[3])
  endif

  call delete('Xscript')
  call delete('Xresult')
endfunc

"" Test for the 2-letter and 3-letter :substitute commands
func Test_substitute_short_cmd()
  new

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    5043,
/**/
    5042,
/**/
 return;
    }
#endif
    if (text_or_buf_locked())
    {
 beep_flush();

 return;
    }



    if (wp->w_buffer != curbuf)
 reset_VIsual_and_resel();
"
Use After Free in function utf_ptr2char in vim/vim,CVE-2022-1968,CWE-416: Use After Free,"}

#if defined(FEAT_FIND_ID) || defined(PROTO)

/*
 * Get line ""lnum"" and copy it into ""buf[LSIZE]"".
 * The copy is made because the regexp may make the line invalid when using a
 * mark.
 */
    static char_u *
get_line_and_copy(linenr_T lnum, char_u *buf)
{
    char_u *line = ml_get(lnum);

    vim_strncpy(buf, line, LSIZE - 1);
    return buf;
}

/*
 * Find identifiers or defines in included files.
 * If p_ic && compl_status_sol() then ptr must be in lowercase.
 end_lnum = curbuf->b_ml.ml_line_count;
    if (lnum > end_lnum)  // do at least one line
 lnum = end_lnum;
    line = get_line_and_copy(lnum, file_line);

    for (;;)
    {
      {
   if (lnum >= end_lnum)
       goto exit_matched;
   line = get_line_and_copy(++lnum, file_line);
      }
      else if (vim_fgets(line = file_line,
            LSIZE, files[depth].fp))
 {
     if (++lnum > end_lnum)
  break;
     line = get_line_and_copy(lnum, file_line);
 }
 already = NULL;
    }
  close!
endfunc

"" this was using a line from ml_get() freed by the regexp
func Test_isearch_copy_line()
  new
  norm o
  norm 0
  0norm o
  sil! norm bc0
  sil! isearch \%')
  bwipe!
endfunc

"" Test for :dsearch, :dlist, :djump and :dsplit commands
"" Test for [d, ]d, [D, ]D, [ CTRL-D, ] CTRL-D and CTRL-W d commands
func Test_macro_search()

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    5050,
/**/
    5049,
/**/
"
A heap-buffer-overflow in mobi_decode_infl in index.c in bfabiszewski/libmobi,CVE-2022-1987,CWE-126: Buffer Over-read,"2022-05-05: Fix: index entry label not being zero-terminated with corrupt input
2022-05-03: Fix boundary checking error in markup search, that could cause buffer over-read with corrupt input
2022-05-02: Fix typo in macro name
2022-04-27: Fix undefined behavior when passing null to strdup
/**
 @brief Read index entry label from buffer pointing at index record data
 @param[in,out] output Output buffer (INDX_LABEL_SIZEMAX + 1 bytes)
 @param[in,out] buf MOBIBuffer structure, offset pointing at index entry label
 @param[in] length Number of bytes to be read
 @param[in] has_ligatures Decode ligatures if true
 @return Length of output string (without null terminator), on error buf->error set to MOBI_RET status
 */
size_t mobi_indx_get_label(unsigned char *output, MOBIBuffer *buf, const size_t length, const size_t has_ligatures) {
    if (!output) {
 @param[in] ordt MOBIOrdt structure (ORDT data and metadata)
 @param[in,out] buf MOBIBuffer structure with input string
 @param[in,out] output Output buffer (INDX_LABEL_SIZEMAX + 1 bytes)
 @param[in] length Length of input string contained in buf
 @return Length of output string (without null terminator)
 */
size_t mobi_getstring_ordt(const MOBIOrdt *ordt, MOBIBuffer *buf, unsigned char *output, size_t length) {
    size_t i = 0;
        debug_print(""Label length too long: %zu\n"", label_length);
        return MOBI_DATA_CORRUPT;
    }
    char text[INDX_LABEL_SIZEMAX + 1];
    /* FIXME: what is ORDT1 for? */
    if (ordt->ordt2) {
        label_length = mobi_getstring_ordt(ordt, buf, (unsigned char*) text, label_length);
    } else {
        label_length = mobi_indx_get_label((unsigned char*) text, buf, label_length, indx->ligt_entries_count);
        if (buf->error != MOBI_SUCCESS) {
            debug_print(""Buffer error reading label: %d\n"", buf->error);
            return MOBI_DATA_CORRUPT;
        }
    }
    indx->entries[entry_number].label = malloc(label_length + 1);
    if (indx->entries[entry_number].label == NULL) {
"
Out-of-bounds write in function append_command in vim/vim,CVE-2022-2000,CWE-787: Out-of-bounds Write,"    static void
append_command(char_u *cmd)
{
    size_t  len = STRLEN(IObuff);
    char_u  *s = cmd;
    char_u  *d;

    if (len > IOSIZE - 100)
    {
 // Not enough space, truncate and put in ""..."".
 d = IObuff + IOSIZE - 100;
 d -= mb_head_off(IObuff, d);
 STRCPY(d, ""..."");
    }
    STRCAT(IObuff, "": "");
    d = IObuff + STRLEN(IObuff);
    while (*s != NUL && d - IObuff + 5 < IOSIZE)
  call assert_equal('yes', caught)
endfunc

func Test_long_error_message()
  "" the error should be truncated, not overrun IObuff
  silent! norm Q00000000000000     000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000                                                                                                                                                                                                                        
endfunc

"" vim: shiftwidth=2 sts=2 expandtab

static int included_patches[] =
{   /* Add new patch number below this line */
/**/
    5063,
/**/
    5062,
/**/
"
chafa <= 4bac1466 is vulnerable to an out of bounds read vulnerability. in hpjansson/chafa,CVE-2022-2061,CWE-122: Heap-based Buffer Overflow,"  /* Code is invalid */
  return LZW_BAD_CODE;

 } else if (code_new >= 1 << LZW_CODE_MAX) {
  /* Don't access out of bound */
  return LZW_BAD_CODE;

 } else if (code_new < current_entry) {
  /* Code is in table */
  code_out = code_new;
"
NULL Pointer Dereference in function mobi_build_opf_metadata at opf.c:1161 in bfabiszewski/libmobi,CVE-2022-2279,CWE-476: NULL Pointer Dereference,"2022-04-27: Fix undefined behavior when passing null to strdup
2022-04-27: Fix wrong boundary checks in inflections parser resulting in stack buffer over-read with corrupt input
2022-04-26: Fix text formatting
2022-04-26: Fix array boundary check when parsing inflections which could result in buffer over-read with corrupt input
    if (mobi_is_dictionary(m)) {
        if (opf->metadata->x_meta->dictionary_in_lang == NULL) {
            if (m->mh && m->mh->dict_input_lang) {





                uint32_t dict_lang_in = *m->mh->dict_input_lang;
                const char *lang = mobi_get_locale_string(dict_lang_in);
                if (lang) {
                    opf->metadata->x_meta->dictionary_in_lang = calloc(OPF_META_MAX_TAGS, sizeof(char*));
                    if (opf->metadata->x_meta->dictionary_in_lang == NULL) {
                        debug_print(""%s\n"", ""Memory allocation failed"");
                        return MOBI_MALLOC_FAILED;
                    }
                    opf->metadata->x_meta->dictionary_in_lang[0] = strdup(lang);
                }
            }
        }
        if (opf->metadata->x_meta->dictionary_out_lang == NULL) {
            if (m->mh && m->mh->dict_output_lang) {
                uint32_t dict_lang_out = *m->mh->dict_output_lang;
                const char *lang = mobi_get_locale_string(dict_lang_out);
                if (lang) {
                    opf->metadata->x_meta->dictionary_out_lang = calloc(OPF_META_MAX_TAGS, sizeof(char*));
                    if (opf->metadata->x_meta->dictionary_out_lang == NULL) {
                        debug_print(""%s\n"", ""Memory allocation failed"");
                        return MOBI_MALLOC_FAILED;
                    }
                    opf->metadata->x_meta->dictionary_out_lang[0] = strdup(lang);
                }


            }
        }
        if (rawml->orth->orth_index_name) {
 See mobi_locale array.
 @param[in] locale_number Mobipocket locale number (as stored in MOBI header)
 @return Pointer to locale string in mobi_locale array or NULL on error
 */
const char * mobi_get_locale_string(const uint32_t locale_number) {
    uint8_t lang_code = locale_number & 0xffU;
            *m->mh->dict_input_lang && *m->mh->dict_output_lang) {
            const char *locale_in = mobi_get_locale_string(*m->mh->dict_input_lang);
            const char *locale_out = mobi_get_locale_string(*m->mh->dict_output_lang);
            printf("": %s => %s"", locale_in ? locale_in : ""unknown"", locale_out ? locale_out : ""unknown"");
        }
        printf(""\n"");
    }
"
Buffer Over-read in hpjansson/chafa,CVE-2022-2301,CWE-126: Buffer Over-read,"}

#define ASSERT_HEADER(x) if (!(x)) return FALSE
#define UNPACK_FIELD_U32(dest, src, field) ((dest)->field = GUINT32_FROM_BE ((src)->field))
#define UNPACK_FIELD_S32(dest, src, field) ((dest)->field = GINT32_FROM_BE ((src)->field))

static gboolean
load_header (XwdLoader *loader)
{
    XwdHeader *h = &loader->header;
    XwdHeader in;
    const XwdHeader *inp;

    if (!file_mapping_taste (loader->mapping, &in, 0, sizeof (in)))
        return FALSE;

    inp = &in;

    UNPACK_FIELD_U32 (h, inp, header_size);
    UNPACK_FIELD_U32 (h, inp, file_version);
    UNPACK_FIELD_U32 (h, inp, pixmap_format);
    UNPACK_FIELD_U32 (h, inp, pixmap_depth);
    UNPACK_FIELD_U32 (h, inp, pixmap_width);
    UNPACK_FIELD_U32 (h, inp, pixmap_height);
    UNPACK_FIELD_U32 (h, inp, x_offset);
    UNPACK_FIELD_U32 (h, inp, byte_order);
    UNPACK_FIELD_U32 (h, inp, bitmap_unit);
    UNPACK_FIELD_U32 (h, inp, bitmap_bit_order);
    UNPACK_FIELD_U32 (h, inp, bitmap_pad);
    UNPACK_FIELD_U32 (h, inp, bits_per_pixel);
    UNPACK_FIELD_U32 (h, inp, bytes_per_line);
    UNPACK_FIELD_U32 (h, inp, visual_class);
    UNPACK_FIELD_U32 (h, inp, red_mask);
    UNPACK_FIELD_U32 (h, inp, green_mask);
    UNPACK_FIELD_U32 (h, inp, blue_mask);
    UNPACK_FIELD_U32 (h, inp, bits_per_rgb);
    UNPACK_FIELD_U32 (h, inp, color_map_entries);
    UNPACK_FIELD_U32 (h, inp, n_colors);
    UNPACK_FIELD_U32 (h, inp, window_width);
    UNPACK_FIELD_U32 (h, inp, window_height);
    UNPACK_FIELD_S32 (h, inp, window_x);
    UNPACK_FIELD_S32 (h, inp, window_y);
    UNPACK_FIELD_U32 (h, inp, window_border_width);

    /* Only support the most common/useful subset of XWD files out there;
     * namely, that corresponding to screen dumps from modern X.Org servers.
     * We could check visual_class == 5 too, but the other fields convey all
     * the info we need. */

    ASSERT_HEADER (h->header_size >= sizeof (XwdHeader));
    ASSERT_HEADER (h->header_size <= 65535);
    ASSERT_HEADER (h->file_version == 7);
    ASSERT_HEADER (h->pixmap_depth == 24);

    /* Should be zero for truecolor/directcolor. Cap it to prevent overflows. */
    ASSERT_HEADER (h->color_map_entries <= 256);

    /* Xvfb sets bits_per_rgb to 8, but 'convert' uses 24 for the same image data. One
     * of them is likely misunderstanding. Let's be lenient and accept either. */
    ASSERT_HEADER (h->bits_per_rgb == 8 || h->bits_per_rgb == 24);

    /* These are the pixel formats we allow. */
    ASSERT_HEADER (h->bits_per_pixel == 24 || h->bits_per_pixel == 32);

    /* Enforce sane dimensions. */
    ASSERT_HEADER (h->pixmap_width >= 1 && h->pixmap_width <= 65535);
    ASSERT_HEADER (h->pixmap_height >= 1 && h->pixmap_height <= 65535);

    /* Make sure rowstride can actually hold a row's worth of data but is not padded to
     * something ridiculous. */
    ASSERT_HEADER (h->bytes_per_line >= h->pixmap_width * (h->bits_per_pixel / 8));
    ASSERT_HEADER (h->bytes_per_line <= h->pixmap_width * (h->bits_per_pixel / 8) + 1024);

    /* Make sure the total allocation/map is not too big. */
    ASSERT_HEADER (h->bytes_per_line * h->pixmap_height < (1UL << 31) - 65536 - 256 * 32);

    ASSERT_HEADER (compute_pixel_type (loader) < CHAFA_PIXEL_MAX);

    loader->file_data = file_mapping_get_data (loader->mapping, &loader->file_data_len);
    if (!loader->file_data)
        return FALSE;

    ASSERT_HEADER (loader->file_data_len >= h->header_size
                   + h->color_map_entries * sizeof (XwdColor)
                   + h->pixmap_height * (gsize) h->bytes_per_line);

    loader->image_data = (const guint8 *) loader->file_data
        + h->header_size + h->color_map_entries * sizeof (XwdColor);

    return TRUE;
}
"
Heap Use After Free in function Q_IsTypeOn in gpac/gpac,CVE-2022-2453,CWE-416: Use After Free,"   e = gf_bifs_dec_sf_field(codec, bs, node, &sffield, GF_FALSE);
   if (e) return e;
  }
  return GF_OK;
 }















 e = GF_OK;
 last = NULL;
 for (i=0; i<nbFields; i++) {
  GF_Node *new_node = gf_bifs_dec_node(codec, bs, field->NDTtype);
  if (new_node) {
   e = gf_node_register(new_node, is_mem_com ? NULL : node);
   if (e) goto exit;

   if (node) {
    /*special case for QP, register as the current QP*/
    if (gf_node_get_tag(new_node) == TAG_MPEG4_QuantizationParameter) {
     qp_local = ((M_QuantizationParameter *)new_node)->isLocal;
     /*we have a QP in the same scope, remove previous
     NB: we assume this is the right behavior, the spec doesn't say
     whether QP is cumulative or not*/
     if (qp_on) gf_bifs_dec_qp_remove(codec, GF_FALSE);

     e = gf_bifs_dec_qp_set(codec, new_node);
     if (e) goto exit;
     qp_on = 1;
     if (qp_local) qp_local = 2;
     if (codec->force_keep_qp) {
      e = gf_node_list_add_child_last(field->far_ptr, new_node, &last);
      if (e) goto exit;
     } else {
      gf_node_register(new_node, NULL);
      gf_node_unregister(new_node, node);
     }
    } else {
     e = gf_node_list_add_child_last(field->far_ptr, new_node, &last);
     if (e) goto exit;
    }








   }
   /*proto coding*/
   else if (codec->pCurrentProto) {
    /*TO DO: what happens if this is a QP node on the interface ?*/
    e = gf_node_list_add_child_last( (GF_ChildNodeItem **)field->far_ptr, new_node, &last);
    if (e)goto exit;
   }
  } else {
   e = codec->LastError ? codec->LastError : GF_NON_COMPLIANT_BITSTREAM;
   goto exit;
  }
 }

exit:

 /*according to the spec, the QP applies to the current node itself, not just children.
 If IsLocal is TRUE remove the node*/
 if (qp_on && qp_local) {
  if (qp_local == 2) {
//    qp_local = 1;
  } else {
   //ask to get rid of QP and reactivate if we had a QP when entering the node
   gf_bifs_dec_qp_remove(codec, initial_qp);
//    qp_local = 0;

  }
 }

 /*finally delete the QP if any (local or not) as we get out of this node*/
 if (qp_on) gf_bifs_dec_qp_remove(codec, GF_TRUE);
 return e;
}


"
Integer Overflow in function lsr_translate_coords in gpac/gpac,CVE-2022-2454,CWE-190: Integer Overflow or Wraparound,"
static Fixed lsr_translate_coords(GF_LASeRCodec *lsr, u32 val, u32 nb_bits)
{
 if (!nb_bits) return 0;

#ifdef GPAC_FIXED_POINT
 if (val >> (nb_bits-1) ) {
  s32 neg = (s32) val - (1<<nb_bits);
"
Null Pointer Dereference Caused Segmentation Fault in gpac/gpac,CVE-2022-2549,CWE-476: NULL Pointer Dereference,"  } else {
   StartAttribute(sdump, ""value"");
  }
  for (i=0; mffield && (i<mffield->count); i++) {
   if (i) gf_fprintf(sdump->trace, "" "");
   gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);
   /*this is to cope with single MFString which shall appear as SF in XMT*/
  }

  if (!sdump->XMLDump) gf_fprintf(sdump->trace, ""["");
  for (i=0; mffield && (i<mffield->count); i++) {
   if (i) gf_fprintf(sdump->trace, "" "");
   gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);
   gf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, node);


  }
  if (!sdump->XMLDump) gf_fprintf(sdump->trace, ""]"");

     sdump->indent--;
     DUMP_IND(sdump);
    } else {
     for (i=0; mffield && (i<mffield->count); i++) {
      if (i) gf_fprintf(sdump->trace, "" "");
      if (field.fieldType != GF_SG_VRML_MFNODE) {
       gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);
     } else {
      gf_fprintf(sdump->trace, "" %s=\"""", GetXMTFieldTypeValueName(field.fieldType));
     }
     for (i=0; mffield && (i<mffield->count); i++) {
      if (i) gf_fprintf(sdump->trace, "" "");
      if (field.fieldType != GF_SG_VRML_MFNODE) {
       gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);
    } else {
     gf_fprintf(sdump->trace, "" %s=\"""", GetXMTFieldTypeValueName(field.fieldType));
    }
    for (i=0; mffield && (i<mffield->count); i++) {
     if (i) gf_fprintf(sdump->trace, "" "");
     if (field.fieldType != GF_SG_VRML_MFNODE) {
      gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);
      gf_dump_vrml_sffield(sdump, sf_type, slot_ptr, (mffield->count>1) ? 1 : 0, node);


     }
    }
    gf_fprintf(sdump->trace, ""\""/>\n"");
"
Format string modifiers in card label in umlaeute/v4l2loopback,CVE-2022-2652,CWE-134: Use of Externally-Controlled Format String," __u32 capabilities = V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;

 strlcpy(cap->driver, ""v4l2 loopback"", sizeof(cap->driver));
 snprintf(cap->card, labellen, ""%s"", dev->card_label);
 snprintf(cap->bus_info, sizeof(cap->bus_info),
   ""platform:v4l2loopback-%03d"", device_nr);

 }

 MARK();
 snprintf(dev->vdev->name, sizeof(dev->vdev->name), ""%s"", dev->card_label);

 vdev_priv->device_nr = nr;

"
Buffer Over Read in gf_utf8_wcslen in gpac/gpac,CVE-2022-3178,CWE-126: Buffer Over-read,"   prop_type = gf_bs_read_u16(bs);
   prop_size -= 6;
   ISOM_DECREASE_SIZE_NO_ERR(ptr, prop_size)
   //add 3 extra bytes for UTF16 case string dump (3 because we need 0-aligned short value)
   data2 = gf_malloc(sizeof(char) * (prop_size+3));
   gf_bs_read_data(bs, data2, prop_size);
   data2[prop_size] = 0;
   data2[prop_size+1] = 0;
   data2[prop_size+2] = 0;
   tag_size-=prop_size;
  } else {
   prop_size = 0;
"
Segmentation Fault in SFS_Expression in gpac/gpac,CVE-2022-3222,CWE-674: Uncontrolled Recursion,"     /usr/local/lib,
     /opt/local/lib,
    );
    MACOSX_DEPLOYMENT_TARGET = 10.9;
    ONLY_ACTIVE_ARCH = YES;
    OTHER_LDFLAGS = ""-lSDL2"";
    PRODUCT_NAME = ""$(TARGET_NAME)"";
     /usr/local/lib,
     /opt/local/lib,
    );
    MACOSX_DEPLOYMENT_TARGET = 10.9;
    OTHER_LDFLAGS = ""-lSDL2"";
    PRODUCT_NAME = ""$(TARGET_NAME)"";
    SDKROOT = macosx;
 GF_List *identifiers;
 char *new_line;
 u32 indent;
 u32 expr_stack_size;
} ScriptParser;


 e = GF_OK;
 if (gf_node_get_tag(n) != TAG_MPEG4_Script) return GF_NON_COMPLIANT_BITSTREAM;

 memset(&parser, 0, sizeof(ScriptParser));
 parser.codec = codec;
 parser.script = n;
 parser.bs = bs;
  SFS_Space(&parser);
  SFS_StatementBlock(&parser, GF_TRUE);
  SFS_Line(&parser);
  if (codec->LastError) {
   e = codec->LastError;
   goto exit;
  }
 }

 SFS_Line(&parser);
 if (parser->codec->LastError) return;
 SFS_Expression(parser);
 if (! gf_bs_read_int(parser->bs, 1)) return;
 if (parser->codec->LastError) return;
 SFS_AddString(parser, "","");
 SFS_CompoundExpression(parser);
}
 }
}

#define MAX_EXPR_STACK 500
void SFS_Expression(ScriptParser *parser)
{
 u32 val = gf_bs_read_int(parser->bs, NUMBITS_EXPR_TYPE);
 if (parser->codec->LastError) return;

 //limit max expression stack size
 parser->expr_stack_size++;
 if (parser->expr_stack_size>MAX_EXPR_STACK) {
  GF_LOG(GF_LOG_ERROR, GF_LOG_CODEC, (""[BIFS] Max stack size %d reached for expressions, not supported\n"", MAX_EXPR_STACK))
  parser->codec->LastError = GF_NON_COMPLIANT_BITSTREAM;
  return;
 }

 switch(val) {
 case ET_CURVED_EXPR:
  SFS_AddString(parser, ""("");
  parser->codec->LastError = GF_NON_COMPLIANT_BITSTREAM;
  break;
 }
 parser->expr_stack_size--;
}

void SFS_NewObject(ScriptParser *parser)
{
 if (parser->codec->LastError) return;
 SFS_Expression(parser);
 if (parser->codec->LastError) return;
 SFS_AddString(parser, ""["");
 SFS_CompoundExpression(parser);
 SFS_AddString(parser, ""]"");
{
 if (parser->codec->LastError) return;
 SFS_Expression(parser);
 if (parser->codec->LastError) return;
 SFS_AddString(parser, ""."");
 SFS_Identifier(parser);
}
{
 if (parser->codec->LastError) return;
 SFS_Expression(parser);
 if (parser->codec->LastError) return;
 SFS_AddString(parser, ""."");
 SFS_Identifier(parser);
 SFS_AddString(parser, ""("");
 val = gf_bs_read_int(parser->bs, 1);
 while (val) {
  SFS_Expression(parser);
  if (parser->codec->LastError) return;
  val = gf_bs_read_int(parser->bs, 1);
  if(val) SFS_AddString(parser, "","");
 }
"
Integer overflow in realloc call in radareorg/radare2,CVE-2022-4398,CWE-190: Integer Overflow or Wraparound,"  bison \
  pkg-config \
  make \
  python3 \
  python3-pip \
  sudo \
  glib-2.0 \
  libc6:i386 \
  libncurses5:i386 \
    filestr = r_file_slurp_line (file, line, 0);
    if (filestr) {
     int flen = strlen (filestr);
     if (idx < 0 || ST32_ADD_OVFCHK (idx, flen + 8)) {
      R_LOG_WARN (""integer overflow detected"");
      break;
     }
     cmdstr = realloc (cmdstr, idx + flen + 8);
     memcpy (cmdstr + idx, filestr, flen);
     idx += flen;
"
NULL Pointer Dereference in radareorg/radare2,CVE-2022-4843,CWE-476: NULL Pointer Dereference,"  const ut64 buf_off = R_MAX (addr, r_io_submap_from (sm)) - addr;
  const int read_len = R_MIN (r_io_submap_to ((&fake_sm)),
          r_io_submap_to (sm)) - (addr + buf_off) + 1;
  if (map->perm & R_PERM_RELOC && map->reloc_map) {
   ret &= map->reloc_map->read (io, map, addr + buf_off, &buf[buf_off], read_len);
  } else {
   const ut64 paddr = addr + buf_off - r_io_map_from (map) + map->delta;
  return -1;
 }
 const int read_len = R_MIN (len, r_io_submap_to (sm) - addr + 1);
 if (map->perm & R_PERM_RELOC && map->reloc_map) {
  return map->reloc_map->read (io, map, addr, buf, read_len);
 }
 const ut64 paddr = addr - r_io_map_from (map) + map->delta;
"
ANSI Escape Sequence Injection in radareorg/radare2,CVE-2023-0302,CWE-75: Failure to Sanitize Special Elements into a Different Plane (Special Element Injection)," item->subtype = subtype;
 item->space = space;
 free (item->str);
 if (R_STR_ISNOTEMPTY (str)) {
  item->str = strdup (str);
  // this breaks the `ecHw` command
  // (highlights word in current instruction, which uses ansi
  // r_str_ansi_strip (item->str);
 } else {
  item->str = NULL;
 }
 R_DIRTY (a);
 if (!node) {
 int i = 0;
 size_t count;
 const ut8 *tmp_buf = NULL;
 char *fn = NULL;

 if (mode == R_MODE_PRINT) {
  print ("" The Directory Table:\n"");

 for (i = 0; i < 2; i++) {
  while (buf + 1 < buf_end) {

   size_t maxlen = R_MIN ((size_t) (buf_end - buf - 1), 0xfff);
   ut64 id_idx, mod_time, file_len;
   free (fn);
   fn = r_str_ndup ((const char *)buf, maxlen);
   r_str_ansi_strip (fn);
   size_t len = strlen (fn);

   if (!len) {
    buf++;
    }

    if (hdr->file_names) {
     hdr->file_names[count].name = r_str_newf(""%s/%s"", r_str_get (include_dir), fn);
     hdr->file_names[count].id_idx = id_idx;
     hdr->file_names[count].mod_time = mod_time;
     hdr->file_names[count].file_len = file_len;
   }
   count++;
   if (mode == R_MODE_PRINT && i) {
    print (""  %d     %"" PFMT64d ""       %"" PFMT64d ""         %"" PFMT64d ""          %s\n"",
      entry_index++, id_idx, mod_time, file_len, fn);
   }
  }
  if (i == 0) {
 }

beach:
 free (fn);
 sdb_free (sdb);

 return buf;

static inline void add_sdb_addrline(Sdb *s, ut64 addr, const char *file, ut64 line, int mode, PrintfCallback print) {
 const char *p;

 char offset[SDB_NUM_BUFSZ];
 char *offset_ptr;

#else
 p = file;
#endif
 char *fileline = r_str_newf (""%s|%""PFMT64d, p, line);
 r_str_ansi_strip (fileline);
 r_str_replace_ch (fileline, '\n', 0, true);
 r_str_replace_ch (fileline, '\t', 0, true);
 offset_ptr = sdb_itoa (addr, 16, offset, sizeof (offset));
 sdb_add (s, offset_ptr, fileline, 0);
 sdb_add (s, fileline, offset_ptr, 0);
  break;
 case DW_FORM_string:
  value->kind = DW_AT_KIND_STRING;
  if (*buf) {
   char *name = r_str_ndup ((const char *)buf, buf_end - buf);
   r_str_ansi_strip (name);
   r_str_replace_ch (name, '\n', 0, true);
   r_str_replace_ch (name, '\t', 0, true);
   value->string.content = name;
  } else {
   value->string.content = NULL;
  }
  if (value->string.content) {
   buf += strlen (value->string.content) + 1;
  }
  value->kind = DW_AT_KIND_STRING;
  value->string.offset = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);
  if (debug_str && value->string.offset < debug_str_len) {
   char *ds = r_str_ndup ((const char *)(debug_str + value->string.offset), debug_str_len);
   if (ds) {
    r_str_ansi_strip (ds);
    r_str_replace_ch (ds, '\n', 0, true);
    r_str_replace_ch (ds, '\t', 0, true);
    value->string.content = ds;
   } else {
    value->string.content = NULL;
   }
  } else {
   value->string.content = NULL; // Means malformed DWARF, should we print error message?
  }
  // Or atleast it needs to rework becase there will be
  // more comp units -> more comp dirs and only the last one will be kept
  if (attribute->attr_name == DW_AT_comp_dir && is_valid_string_form) {
   char *name = strdup (attribute->string.content);
   r_str_ansi_strip (name);
   r_str_replace_ch (name, '\n', 0, true);
   r_str_replace_ch (name, '\t', 0, true);
   sdb_set_owned (sdb, ""DW_AT_comp_dir"", name, 0);
  }
  die->count++;
 }
/* radare - LGPL - Copyright 2008-2023 - pancake */

#include <r_cons.h>
#include <ctype.h>
R_API char *r_cons_hud_file(const char *f) {
 char *s = r_file_slurp (f, NULL);
 if (s) {
  r_str_ansi_strip (s);
  char *ret = r_cons_hud_string (s);
  free (s);
  return ret;
 }
 r_str_replace_ch (o, '\r', 0, true);
 r_str_replace_ch (o, '\t', 0, true);
 r_str_ansi_strip (o);
 RList *fl = r_list_new ();
 int i;
 if (!fl) {
 if (!o) {
  return NULL;
 }
 r_str_ansi_strip (o);
 r_str_replace_ch (o, '\r', 0, true);
 r_str_replace_ch (o, '\t', 0, true);
 RList *fl = r_list_new ();
  break;
 case '!':
  {

   const char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);
   char *out = r_core_editor (core, NULL, comment);
   if (out) {
    r_str_ansi_strip (out);
    //r_meta_set (core->anal->meta, R_META_TYPE_COMMENT, addr, 0, out);
    r_core_cmdf (core, ""CC-@0x%08""PFMT64x, addr);
    //r_meta_del (core->anal->meta, input[0], addr, addr+1);
  char *text;
  char *nc = strdup (newcomment);
  r_str_unescape (nc);
  r_str_ansi_strip (nc);
  if (comment) {
   text = malloc (strlen (comment) + strlen (newcomment) + 2);
   if (text) {
/* radare - LGPL - Copyright 2009-2023 - pancake */

#include <r_core.h>
#include <limits.h>
}

// remove ansi escape codes from string, decolorizing it
// TODO : optimize by just using two counter variables instead of strcpy()
R_API size_t r_str_ansi_strip(char *str) {
 size_t i = 0;
 while (str[i]) {
  size_t chlen = __str_ansi_length (str + i);
  if (chlen > 1) {
   r_str_cpy (str + i, str + i + chlen);
  } else {
   i++;
  }

 }
 return i;
}
NAME=""ansi injection via dwarf""
FILE=bins/elf/dwarf_test_func_patched
ARGS=-AA
CMDS=<<EOF
CL
xc
EOF
EXPECT=<<EOF
file: /_test.c
line: 5
addr: 0x00001159
file: /_test.c
line: 11
addr: 0x00001184
file: /_test.c
line: 6
addr: 0x00001165
file: /_test.c
line: 11
addr: 0x00001186
file: /_test.c
line: 9
addr: 0x00001170
file: /_test.c
line: 8
addr: 0x00001168
file: /_test.c
line: 4
addr: 0x00001149
file: /_test.c
line: 10
addr: 0x0000117f
- offset -  6061 6263 6465 6667 6869 6A6B 6C6D 6E6F  0123456789ABCDEF  comment
0x00001060  f30f 1efa 31ed 4989 d15e 4889 e248 83e4  ....1.I..^H..H..  ; rip ; [16] -r-x section size 294 named .text ; arg3
0x00001070  f050 5445 31c0 31c9 488d 3de9 0000 00ff  .PTE1.1.H.=.....
0x00001080  1553 2f00 00f4 662e 0f1f 8400 0000 0000  .S/...f.........
0x00001090  488d 3d79 2f00 0048 8d05 722f 0000 4839  H.=y/..H..r/..H9  ; sym.deregister_tm_clones
0x000010a0  f874 1548 8b05 362f 0000 4885 c074 09ff  .t.H..6/..H..t..
0x000010b0  e00f 1f80 0000 0000 c30f 1f80 0000 0000  ................
0x000010c0  488d 3d49 2f00 0048 8d35 422f 0000 4829  H.=I/..H.5B/..H)  ; sym.register_tm_clones
0x000010d0  fe48 89f0 48c1 ee3f 48c1 f803 4801 c648  .H..H..?H...H..H
0x000010e0  d1fe 7414 488b 0505 2f00 0048 85c0 7408  ..t.H.../..H..t.
0x000010f0  ffe0 660f 1f44 0000 c30f 1f80 0000 0000  ..f..D..........
0x00001100  f30f 1efa 803d 052f 0000 0075 2b55 4883  .....=./...u+UH.  ; sym.__do_global_dtors_aux
0x00001110  3de2 2e00 0000 4889 e574 0c48 8b3d e62e  =.....H..t.H.=..
0x00001120  0000 e819 ffff ffe8 64ff ffff c605 dd2e  ........d.......
0x00001130  0000 015d c30f 1f00 c30f 1f80 0000 0000  ...]............
0x00001140  f30f 1efa e977 ffff fff3 0f1e fa55 4889  .....w.......UH.  ; sym.frame_dummy  ; dbg._func ; void _func(char * msg);
0x00001150  e548 83ec 1048 897d f848 8b45 f848 89c7  .H...H.}.H.E.H.. ; arg1 ; const char *s
EOF
RUN

NAME=""open companion file for macho dwarf""
FILE=bins/mach0/dwarf/a.out
CMDS=<<EOF
"
heap-use-after-free in gf_odf_vvc_cfg_read_bs in gpac/gpac,CVE-2023-0358,CWE-416: Use After Free,"   gf_list_add(cfg->param_array, ar);
   break;
  default:
   GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (""[VVC] Invalid NALU type %d in vvcC - ignoring\n"", ar->type));
   gf_free(ar);
   break;
  }

  if (!valid || ((ar->type != GF_VVC_NALU_DEC_PARAM) && (ar->type != GF_VVC_NALU_OPI)))
   nalucount = gf_bs_read_int(bs, 16);
  else
   nalucount = 1;
"
Heap Buffer Overflow in function gf_isom_box_size at src/isomedia/box_funcs.c:1997 in gpac/gpac,CVE-2023-0760,CWE-122: Heap-based Buffer Overflow,"
 /*VVC*/
 gf_isom_check_position(s, (GF_Box *)ptr->vvc_config, &pos);

 /*AV1*/
 gf_isom_check_position(s, (GF_Box *)ptr->av1_config, &pos);

 e = gf_isom_box_write_header(s, bs);
 if (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DAC3;
 if (e) return e;

 e = gf_odf_ac3_cfg_write_bs(&ptr->cfg, bs);
 if (e) return e;

  }
  return ptr;
 }
 case 0:
  GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] sgpd entry null grouping_type is invalid\n"") );
  return NULL;
 default:
  break;
 }
 GF_Box *newBox;
 Bool skip_logs = (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_NO_LOGS ) ? GF_TRUE : GF_FALSE;
 Bool is_special = GF_TRUE;

 if ((bs == NULL) || (outBox == NULL) ) return GF_BAD_PARAM;
 *outBox = NULL;
 if (gf_bs_available(bs) < 8) {
 BOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YVYU, video_sample_entry, ""stsd"", ""apple""),
 BOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_RGBA, video_sample_entry, ""stsd"", ""apple""),
 BOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_ABGR, video_sample_entry, ""stsd"", ""apple""),

 FBOX_DEFINE_S(GF_QT_BOX_TYPE_STPS, stss, ""stbl"", 0, ""apple""),

 //dolby boxes

 s32 cur_pos = gf_list_find(s->child_boxes, child);

 //happens when partially cloning boxes
 if (cur_pos < 0) return;

 if (cur_pos != (s32) *pos) {
 if (!a) return GF_BAD_PARAM;
 //box has been disabled, do not write
 if (!a->size) return GF_OK;

 if (a->registry->disabled) {
  GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[iso file] Box %s disabled registry, skip write\n"", gf_4cc_to_str(a->type)));
  return GF_OK;
 }
 if (static_sample && ! (*sample)->alloc_size )
   (*sample)->alloc_size =  (*sample)->dataLength;

 return GF_OK;
}

 if (!map) return NULL;
 tsel = (GF_TrackSelectionBox*)gf_list_get(map->boxes, group_index-1);
 if (!tsel) return NULL;

 *switchGroupID = tsel->switchGroup;
 *criteriaListSize = tsel->attributeListCount;
 return (const u32 *) tsel->attributeList;
 if (skip_byte_block) *skip_byte_block = 0;
 if (key_info) *key_info = NULL;
 if (key_info_size) *key_info_size = 0;

 if (!trak) return GF_BAD_PARAM;

#ifdef GPAC_DISABLE_ISOM_FRAGMENTS
"
Stack-Based Buffer Overflow in gf_sg_proto_field_is_sftime_offset in gpac/gpac,CVE-2023-0770,CWE-121: Stack-based Buffer Overflow,"
  gf_node_get_field(r->ToNode, r->ToField.fieldIndex, &inf);
  /*IS to another proto*/
  if (r->ToNode->sgprivate->tag == TAG_ProtoNode) {
   if (r->ToNode==node) continue;
   return gf_sg_proto_field_is_sftime_offset(r->ToNode, &inf);
  }
  /*IS to a startTime/stopTime field*/
  if (!stricmp(inf.name, ""startTime"") || !stricmp(inf.name, ""stopTime"")) return 1;
 }
"
buffer over-read in function mhas_dmx_process filters/reframe_mhas.c in gpac/gpac,CVE-2023-0817,CWE-126: Buffer Over-read,"   if (!mhas_last_cfg) mhas_sap = 0;
  //config
  } else if (mhas_type==1) {

   /*u32 pl = */gf_bs_read_u8(bs);
   u32 idx = gf_bs_read_int(bs, 5);
   if (idx==0x1f)
    duration.den = gf_bs_read_int(bs, 24);
   else if (idx < nb_usac_sr) {
    duration.den = USACSampleRates[idx];
   }
   idx = gf_bs_read_int(bs, 3);
   u32 idx = gf_bs_read_int(ctx->bs, 5);
   if (idx==0x1f)
    sr = gf_bs_read_int(ctx->bs, 24);
   else if (idx < nb_usac_sr) {
    sr = USACSampleRates[idx];
   }
   ctx->nb_unknown_pck = 0;
"
off-by-one error in function gf_text_get_utf8_line filters/load_text.c in gpac/gpac,CVE-2023-0818,CWE-193: Off-by-one Error,"   if (!unicode_type && (szLine[i] & 0x80)) {
    /*non UTF8 (likely some win-CP)*/
    if ((szLine[i+1] & 0xc0) != 0x80) {
     if (j >= GF_ARRAY_LENGTH(szLineConv))
      break;
     szLineConv[j] = 0xc0 | ( (szLine[i] >> 6) & 0x3 );
     j++;
     szLine[i] &= 0xbf;
    }
    /*UTF8 2 bytes char*/
    else if ( (szLine[i] & 0xe0) == 0xc0) {
     if (j >= GF_ARRAY_LENGTH(szLineConv))
      break;
     szLineConv[j] = szLine[i];
     i++;
     j++;
    }
    /*UTF8 3 bytes char*/
    else if ( (szLine[i] & 0xf0) == 0xe0) {
     if (j+1 >= GF_ARRAY_LENGTH(szLineConv))
      break;
     szLineConv[j] = szLine[i];
     i++;
     j++;
    }
    /*UTF8 4 bytes char*/
    else if ( (szLine[i] & 0xf8) == 0xf0) {
     if (j+2 >= GF_ARRAY_LENGTH(szLineConv))
      break;
     szLineConv[j] = szLine[i];
     i++;
     j++;
     continue;
    }
   }

   if (j >= GF_ARRAY_LENGTH(szLineConv))
    break;

   szLineConv[j] = szLine[i];
   j++;






  }
  if ( j >= GF_ARRAY_LENGTH(szLineConv) ) {
   GF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (""[TXTIn] Line too long to convert to utf8 (len: %d)\n"", len));
   j = GF_ARRAY_LENGTH(szLineConv) -1 ;
  }
  szLineConv[j] = 0;
  strcpy(szLine, szLineConv);
"
heap-buffer-overflow in function gf_m2ts_process_tdt_tot media_tools/mpegts.c in gpac/gpac,CVE-2023-0819,CWE-122: Heap-based Buffer Overflow,"  return;
 }

 if (data_size < 5) {
  GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[MPEG-2 TS] Section data size too small to read date (len: %u)\n"", data_size));
  return;
 }

 /*UTC_time - see annex C of DVB-SI ETSI EN 300468*/
/* decodes an Modified Julian Date (MJD) into a Co-ordinated Universal Time (UTC)
See annex C of DVB-SI ETSI EN 300468 */
"
heap-buffer-overflow in function adts_dmx_process filters/reframe_adts.c in gpac/gpac,CVE-2023-0866,CWE-122: Heap-based Buffer Overflow,"   }
  }
 }

 p = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILE_CACHED);
 if (p && p->value.boolean) ctx->file_loaded = GF_TRUE;
}
  }

  if (!ctx->in_seek) {

   if (sync_pos + offset + size > remain) {
    GF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (""[ADTSDmx] truncated frame\n""));
    break;
   }

   dst_pck = gf_filter_pck_new_alloc(ctx->opid, size, &output);
   if (!dst_pck) return GF_OUT_OF_MEM;
   if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
"
SIGSEGV at libr/bin/p/bin_coff.c:509 in patch_relocs() in radareorg/radare2,CVE-2023-1605,CWE-400: Denial of Service,"
 size_t nimports = 0;
 int i;
 if (bin->symbols) {
  for (i = 0; i < bin->hdr.f_nsyms; i++) {
   if (is_imported_symbol (&bin->symbols[i])) {
    nimports++;
   }
   i += bin->symbols[i].n_numaux;
  }

 }
 ut64 m_vaddr = UT64_MAX;
 if (nimports) {
"
Unhandled SWF Tags in MP4Box: Potential Vulnerability in GPAC in gpac/gpac,CVE-2023-1654,CWE-400: Denial of Service," gf_list_del(pidinst->pck_reassembly);
 if (pidinst->props) {
  assert(pidinst->props->reference_count);
  gf_mx_p(pidinst->pid->filter->tasks_mx);
  //not in parent pid, may happen when reattaching a pid inst to a different pid
  //in this case do NOT delete the props
  if (gf_list_find(pidinst->pid->properties, pidinst->props)>=0) {
   if (safe_int_dec(&pidinst->props->reference_count) == 0) {
    //see \ref gf_filter_pid_merge_properties_internal for mutex
    gf_list_del_item(pidinst->pid->properties, pidinst->props);
    gf_props_del(pidinst->props);
   }
  }
  gf_mx_v(pidinst->pid->filter->tasks_mx);
 }
 gf_free(pidinst);
}
      if (!target->detached_pid_inst) {
       target->detached_pid_inst = gf_list_new();
      }
      //detach props
      if (filter->swap_pidinst_dst->props) {
       GF_FilterPidInst *swap_pidi = filter->swap_pidinst_dst;
       if (safe_int_dec(&swap_pidi->props->reference_count)==0) {
        gf_mx_p(swap_pidi->pid->filter->tasks_mx);
        gf_list_del_item(swap_pidi->pid->properties, pidinst->props);
        gf_mx_v(swap_pidi->pid->filter->tasks_mx);
        gf_props_del(pidinst->props);
       }
       filter->swap_pidinst_dst->props = NULL;
      }
      filter->swap_pidinst_dst->pid = NULL;
 //first connection of this PID to this filter
 if (!pidinst) {
  GF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (""Trying to detach PID %s not present in filter %s inputs\n"",  pid->name, filter->name));
  //when swaping encoder, we may have swap_pidinst_dst not NULL so only check swap_pidinst_src
  assert(!new_chain_input->swap_pidinst_src);
  new_chain_input->swap_needs_init = GF_FALSE;
  return;
  }
  src_props = pidi->props;
 }
 //move to real pid
 src_pid = src_pid->pid;
 //this is a copy props on output pid
 if (!src_props) {
"
Heap Use-After-Free in GPAC MP4Box's ogg_stream_clear Function When Processing OGG Files in gpac/gpac,CVE-2023-1655,CWE-122: Heap-based Buffer Overflow,"
 if (ctx->probe_wave==1) {
  Bool wav_ok = GF_TRUE;
  Bool hdr_found = GF_FALSE;
  GF_BitStream *bs;
  if (ctx->probe_data) {
   ctx->probe_data = gf_realloc(ctx->probe_data, ctx->probe_data_size+pck_size);
    continue;
   }
   //parse fmt
   hdr_found = GF_TRUE;
   u16 atype = gf_bs_read_u16_le(bs);
   ctx->ch = gf_bs_read_u16_le(bs);
   ctx->sr = gf_bs_read_u32_le(bs);
    memcpy(ctx->probe_data, data, pck_size);
    ctx->probe_data_size = pck_size;
   }
   if (!hdr_found) {
    if (ctx->probe_data_size<=10000) {
     gf_filter_pid_drop_packet(ctx->ipid);
     return GF_OK;
    }
    GF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (""[PCMReframe] Cannot find wave data chunk after %d bytes, aborting\n"", ctx->probe_data_size));
   }

   wav_ok = GF_FALSE;
  }

   }
  } else {
   bs->position += nbBytes;
   if (bs->position>bs->size) {
    bs->position = bs->size;
    bs->overflow_state = 1;
   }
  }
  return;
 }
"
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
,,,
