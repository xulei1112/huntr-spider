https://huntr.dev/bounties/05f1d1de-bbfd-43fe-bdf9-7f73419ce7c9/,Heap Use-After-Free in GPAC MP4Box's ogg_stream_clear Function When Processing OGG Files in gpac/gpac,Reproduce : ./bin/gcc/MP4Box -dash 1000 POC,CVE-2023-1655,CWE-122: Heap-based Buffer Overflow,https://www.github.com/gpac/gpac/commit/e7f96c2d3774e4ea25f952bcdf55af1dd6e919f4,"@@ -250,6 +250,7 @@ GF_Err pcmreframe_process(GF_Filter *filter)

 if (ctx->probe_wave==1) {
  Bool wav_ok = GF_TRUE;

  GF_BitStream *bs;
  if (ctx->probe_data) {
   ctx->probe_data = gf_realloc(ctx->probe_data, ctx->probe_data_size+pck_size);
@@ -280,6 +281,7 @@ GF_Err pcmreframe_process(GF_Filter *filter)
    continue;
   }
   //parse fmt

   u16 atype = gf_bs_read_u16_le(bs);
   ctx->ch = gf_bs_read_u16_le(bs);
   ctx->sr = gf_bs_read_u32_le(bs);
@@ -312,11 +314,13 @@ GF_Err pcmreframe_process(GF_Filter *filter)
    memcpy(ctx->probe_data, data, pck_size);
    ctx->probe_data_size = pck_size;
   }
   if (ctx->probe_data_size<=10000) {
    gf_filter_pid_drop_packet(ctx->ipid);
    return GF_OK;



   }
   GF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (""[PCMReframe] Cannot find wave data chink afetr %d bytes, aborting\n"", ctx->probe_data_size));
   wav_ok = GF_FALSE;
  }


@@ -1266,6 +1266,10 @@ void gf_bs_skip_bytes(GF_BitStream *bs, u64 nbBytes)
   }
  } else {
   bs->position += nbBytes;




  }
  return;
 }

","12
src/filters/reframe_rawpcm.c
@@ -250,6 +250,7 @@ GF_Err pcmreframe_process(GF_Filter *filter)

 if (ctx->probe_wave==1) {
  Bool wav_ok = GF_TRUE;
  Bool hdr_found = GF_FALSE;
  GF_BitStream *bs;
  if (ctx->probe_data) {
   ctx->probe_data = gf_realloc(ctx->probe_data, ctx->probe_data_size+pck_size);
@@ -280,6 +281,7 @@ GF_Err pcmreframe_process(GF_Filter *filter)
    continue;
   }
   //parse fmt
   hdr_found = GF_TRUE;
   u16 atype = gf_bs_read_u16_le(bs);
   ctx->ch = gf_bs_read_u16_le(bs);
   ctx->sr = gf_bs_read_u32_le(bs);
@@ -312,11 +314,13 @@ GF_Err pcmreframe_process(GF_Filter *filter)
    memcpy(ctx->probe_data, data, pck_size);
    ctx->probe_data_size = pck_size;
   }
   if (ctx->probe_data_size<=10000) {
    gf_filter_pid_drop_packet(ctx->ipid);
    return GF_OK;
   if (!hdr_found) {
    if (ctx->probe_data_size<=10000) {
     gf_filter_pid_drop_packet(ctx->ipid);
     return GF_OK;
    }
    GF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (""[PCMReframe] Cannot find wave data chunk after %d bytes, aborting\n"", ctx->probe_data_size));
   }
   GF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (""[PCMReframe] Cannot find wave data chink afetr %d bytes, aborting\n"", ctx->probe_data_size));
   wav_ok = GF_FALSE;
  }

4
src/utils/bitstream.c
@@ -1266,6 +1266,10 @@ void gf_bs_skip_bytes(GF_BitStream *bs, u64 nbBytes)
   }
  } else {
   bs->position += nbBytes;
   if (bs->position>bs->size) {
    bs->position = bs->size;
    bs->overflow_state = 1;
   }
  }
  return;
 }"
https://huntr.dev/bounties/33652b56-128f-41a7-afcc-10641f69ff14/,Unhandled SWF Tags in MP4Box: Potential Vulnerability in GPAC in gpac/gpac,POC: # ./MP4Box -dash 1000 POC4 LINK: https://drive.google.com/file/d/1hHzxolxklZDG_wtowwUEmel9-HAya9Az/view?usp=share_link,CVE-2023-1654,CWE-400: Denial of Service,https://www.github.com/gpac/gpac/commit/2c055153d401b8c49422971e3a0159869652d3da,"@@ -62,13 +62,17 @@ void gf_filter_pid_inst_del(GF_FilterPidInst *pidinst)
 gf_list_del(pidinst->pck_reassembly);
 if (pidinst->props) {
  assert(pidinst->props->reference_count);
  if (safe_int_dec(&pidinst->props->reference_count) == 0) {
   //see \ref gf_filter_pid_merge_properties_internal for mutex
   gf_mx_p(pidinst->pid->filter->tasks_mx);
   gf_list_del_item(pidinst->pid->properties, pidinst->props);
   gf_mx_v(pidinst->pid->filter->tasks_mx);
   gf_props_del(pidinst->props);



  }

 }
 gf_free(pidinst);
}
@@ -1044,8 +1048,15 @@ static GF_Err gf_filter_pid_configure(GF_Filter *filter, GF_FilterPid *pid, GF_P
      if (!target->detached_pid_inst) {
       target->detached_pid_inst = gf_list_new();
      }
      //detach props but don't delete them
      if (filter->swap_pidinst_dst->props) {







       filter->swap_pidinst_dst->props = NULL;
      }
      filter->swap_pidinst_dst->pid = NULL;
@@ -1308,7 +1319,7 @@ void gf_filter_pid_detach_task(GF_FSTask *task)
 //first connection of this PID to this filter
 if (!pidinst) {
  GF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (""Trying to detach PID %s not present in filter %s inputs\n"",  pid->name, filter->name));
  //assert(!new_chain_input->swap_pidinst_dst);
  assert(!new_chain_input->swap_pidinst_src);
  new_chain_input->swap_needs_init = GF_FALSE;
  return;
@@ -5943,7 +5954,7 @@ static GF_Err gf_filter_pid_merge_properties_internal(GF_FilterPid *dst_pid, GF_
  }
  src_props = pidi->props;
 }
 //move to rela pid
 src_pid = src_pid->pid;
 //this is a copy props on output pid
 if (!src_props) {

","29
src/filter_core/filter_pid.c
@@ -62,13 +62,17 @@ void gf_filter_pid_inst_del(GF_FilterPidInst *pidinst)
 gf_list_del(pidinst->pck_reassembly);
 if (pidinst->props) {
  assert(pidinst->props->reference_count);
  if (safe_int_dec(&pidinst->props->reference_count) == 0) {
   //see \ref gf_filter_pid_merge_properties_internal for mutex
   gf_mx_p(pidinst->pid->filter->tasks_mx);
   gf_list_del_item(pidinst->pid->properties, pidinst->props);
   gf_mx_v(pidinst->pid->filter->tasks_mx);
   gf_props_del(pidinst->props);
  gf_mx_p(pidinst->pid->filter->tasks_mx);
  //not in parent pid, may happen when reattaching a pid inst to a different pid
  //in this case do NOT delete the props
  if (gf_list_find(pidinst->pid->properties, pidinst->props)>=0) {
   if (safe_int_dec(&pidinst->props->reference_count) == 0) {
    //see \ref gf_filter_pid_merge_properties_internal for mutex
    gf_list_del_item(pidinst->pid->properties, pidinst->props);
    gf_props_del(pidinst->props);
   }
  }
  gf_mx_v(pidinst->pid->filter->tasks_mx);
 }
 gf_free(pidinst);
}
@@ -1044,8 +1048,15 @@ static GF_Err gf_filter_pid_configure(GF_Filter *filter, GF_FilterPid *pid, GF_P
      if (!target->detached_pid_inst) {
       target->detached_pid_inst = gf_list_new();
      }
      //detach props but don't delete them
      //detach props
      if (filter->swap_pidinst_dst->props) {
       GF_FilterPidInst *swap_pidi = filter->swap_pidinst_dst;
       if (safe_int_dec(&swap_pidi->props->reference_count)==0) {
        gf_mx_p(swap_pidi->pid->filter->tasks_mx);
        gf_list_del_item(swap_pidi->pid->properties, pidinst->props);
        gf_mx_v(swap_pidi->pid->filter->tasks_mx);
        gf_props_del(pidinst->props);
       }
       filter->swap_pidinst_dst->props = NULL;
      }
      filter->swap_pidinst_dst->pid = NULL;
@@ -1308,7 +1319,7 @@ void gf_filter_pid_detach_task(GF_FSTask *task)
 //first connection of this PID to this filter
 if (!pidinst) {
  GF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (""Trying to detach PID %s not present in filter %s inputs\n"",  pid->name, filter->name));
  //assert(!new_chain_input->swap_pidinst_dst);
  //when swaping encoder, we may have swap_pidinst_dst not NULL so only check swap_pidinst_src
  assert(!new_chain_input->swap_pidinst_src);
  new_chain_input->swap_needs_init = GF_FALSE;
  return;
@@ -5943,7 +5954,7 @@ static GF_Err gf_filter_pid_merge_properties_internal(GF_FilterPid *dst_pid, GF_
  }
  src_props = pidi->props;
 }
 //move to rela pid
 //move to real pid
 src_pid = src_pid->pid;
 //this is a copy props on output pid
 if (!src_props) {"
https://huntr.dev/bounties/9dddcf5b-7dd4-46cc-abf9-172dce20bab2/,SIGSEGV at libr/bin/p/bin_coff.c:509 in patch_relocs() in radareorg/radare2,"radare2 5.8.2 misparses symbol information in COFF files, causing a segmentation fault in patch_relocs at libr/bin/p/bin_coff.c:509",CVE-2023-1605,CWE-400: Denial of Service,https://www.github.com/radareorg/radare2/commit/508a6307045441defd1bef0999a1f7052097613f,"@@ -505,11 +505,13 @@ static RList *patch_relocs(RBin *b) {

 size_t nimports = 0;
 int i;
 for (i = 0; i < bin->hdr.f_nsyms; i++) {
  if (is_imported_symbol (&bin->symbols[i])) {
   nimports++;



  }
  i += bin->symbols[i].n_numaux;
 }
 ut64 m_vaddr = UT64_MAX;
 if (nimports) {

","10
libr/bin/p/bin_coff.c
@@ -505,11 +505,13 @@ static RList *patch_relocs(RBin *b) {

 size_t nimports = 0;
 int i;
 for (i = 0; i < bin->hdr.f_nsyms; i++) {
  if (is_imported_symbol (&bin->symbols[i])) {
   nimports++;
 if (bin->symbols) {
  for (i = 0; i < bin->hdr.f_nsyms; i++) {
   if (is_imported_symbol (&bin->symbols[i])) {
    nimports++;
   }
   i += bin->symbols[i].n_numaux;
  }
  i += bin->symbols[i].n_numaux;
 }
 ut64 m_vaddr = UT64_MAX;
 if (nimports) {"
https://huntr.dev/bounties/7d3c5792-d20b-4cb6-9c6d-bb14f3430d7f/,heap-buffer-overflow in function adts_dmx_process filters/reframe_adts.c in gpac/gpac,MP4Box - GPAC version 2.3-DEV-rev44-gbe9f8d395-master,CVE-2023-0866,CWE-122: Heap-based Buffer Overflow,https://www.github.com/gpac/gpac/commit/b964fe4226f1424cf676d5822ef898b6b01f5937,"@@ -300,7 +300,7 @@ static void adts_dmx_check_dur(GF_Filter *filter, GF_ADTSDmxCtx *ctx)
   }
  }
 }
 
 p = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILE_CACHED);
 if (p && p->value.boolean) ctx->file_loaded = GF_TRUE;
}
@@ -824,6 +824,12 @@ GF_Err adts_dmx_process(GF_Filter *filter)
  }

  if (!ctx->in_seek) {






   dst_pck = gf_filter_pck_new_alloc(ctx->opid, size, &output);
   if (!dst_pck) return GF_OUT_OF_MEM;
   if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);

","8
src/filters/reframe_adts.c
@@ -300,7 +300,7 @@ static void adts_dmx_check_dur(GF_Filter *filter, GF_ADTSDmxCtx *ctx)
   }
  }
 }
 
 p = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILE_CACHED);
 if (p && p->value.boolean) ctx->file_loaded = GF_TRUE;
}
@@ -824,6 +824,12 @@ GF_Err adts_dmx_process(GF_Filter *filter)
  }

  if (!ctx->in_seek) {

   if (sync_pos + offset + size > remain) {
    GF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (""[ADTSDmx] truncated frame\n""));
    break;
   }

   dst_pck = gf_filter_pck_new_alloc(ctx->opid, size, &output);
   if (!dst_pck) return GF_OUT_OF_MEM;
   if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);"
https://huntr.dev/bounties/35793610-dccc-46c8-9f55-6a24c621e4ef/,heap-buffer-overflow in function gf_m2ts_process_tdt_tot media_tools/mpegts.c in gpac/gpac,./MP4Box -version,CVE-2023-0819,CWE-122: Heap-based Buffer Overflow,https://www.github.com/gpac/gpac/commit/d067ab3ccdeaa340e8c045a0fd5bcfc22b809e8f,"@@ -946,6 +946,11 @@ static void gf_m2ts_process_tdt_tot(GF_M2TS_Demuxer *ts, GF_M2TS_SECTION_ES *tdt
  return;
 }






 /*UTC_time - see annex C of DVB-SI ETSI EN 300468*/
/* decodes an Modified Julian Date (MJD) into a Co-ordinated Universal Time (UTC)
See annex C of DVB-SI ETSI EN 300468 */

","5
src/media_tools/mpegts.c
@@ -946,6 +946,11 @@ static void gf_m2ts_process_tdt_tot(GF_M2TS_Demuxer *ts, GF_M2TS_SECTION_ES *tdt
  return;
 }

 if (data_size < 5) {
  GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[MPEG-2 TS] Section data size too small to read date (len: %u)\n"", data_size));
  return;
 }

 /*UTC_time - see annex C of DVB-SI ETSI EN 300468*/
/* decodes an Modified Julian Date (MJD) into a Co-ordinated Universal Time (UTC)
See annex C of DVB-SI ETSI EN 300468 */"
https://huntr.dev/bounties/038e7472-f3e9-46c2-9aea-d6dafb62a18a/,off-by-one error in function gf_text_get_utf8_line filters/load_text.c in gpac/gpac,MP4Box - GPAC version 2.3-DEV-rev40-g3602a5ded-master,CVE-2023-0818,CWE-193: Off-by-one Error,https://www.github.com/gpac/gpac/commit/377ab25f3e502db2934a9cf4b54739e1c89a02ff,"@@ -315,18 +315,24 @@ char *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicod
   if (!unicode_type && (szLine[i] & 0x80)) {
    /*non UTF8 (likely some win-CP)*/
    if ((szLine[i+1] & 0xc0) != 0x80) {


     szLineConv[j] = 0xc0 | ( (szLine[i] >> 6) & 0x3 );
     j++;
     szLine[i] &= 0xbf;
    }
    /*UTF8 2 bytes char*/
    else if ( (szLine[i] & 0xe0) == 0xc0) {


     szLineConv[j] = szLine[i];
     i++;
     j++;
    }
    /*UTF8 3 bytes char*/
    else if ( (szLine[i] & 0xf0) == 0xe0) {


     szLineConv[j] = szLine[i];
     i++;
     j++;
@@ -336,6 +342,8 @@ char *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicod
    }
    /*UTF8 4 bytes char*/
    else if ( (szLine[i] & 0xf8) == 0xf0) {


     szLineConv[j] = szLine[i];
     i++;
     j++;
@@ -350,14 +358,18 @@ char *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicod
     continue;
    }
   }




   szLineConv[j] = szLine[i];
   j++;

   if (j >= GF_ARRAY_LENGTH(szLineConv) - 1) {
    GF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (""[TXTIn] Line too long to convert to utf8 (len: %d)\n"", len));
    break;
   }





  }
  szLineConv[j] = 0;
  strcpy(szLine, szLineConv);

","20
src/filters/load_text.c
@@ -315,18 +315,24 @@ char *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicod
   if (!unicode_type && (szLine[i] & 0x80)) {
    /*non UTF8 (likely some win-CP)*/
    if ((szLine[i+1] & 0xc0) != 0x80) {
     if (j >= GF_ARRAY_LENGTH(szLineConv))
      break;
     szLineConv[j] = 0xc0 | ( (szLine[i] >> 6) & 0x3 );
     j++;
     szLine[i] &= 0xbf;
    }
    /*UTF8 2 bytes char*/
    else if ( (szLine[i] & 0xe0) == 0xc0) {
     if (j >= GF_ARRAY_LENGTH(szLineConv))
      break;
     szLineConv[j] = szLine[i];
     i++;
     j++;
    }
    /*UTF8 3 bytes char*/
    else if ( (szLine[i] & 0xf0) == 0xe0) {
     if (j+1 >= GF_ARRAY_LENGTH(szLineConv))
      break;
     szLineConv[j] = szLine[i];
     i++;
     j++;
@@ -336,6 +342,8 @@ char *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicod
    }
    /*UTF8 4 bytes char*/
    else if ( (szLine[i] & 0xf8) == 0xf0) {
     if (j+2 >= GF_ARRAY_LENGTH(szLineConv))
      break;
     szLineConv[j] = szLine[i];
     i++;
     j++;
@@ -350,14 +358,18 @@ char *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicod
     continue;
    }
   }

   if (j >= GF_ARRAY_LENGTH(szLineConv))
    break;

   szLineConv[j] = szLine[i];
   j++;

   if (j >= GF_ARRAY_LENGTH(szLineConv) - 1) {
    GF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (""[TXTIn] Line too long to convert to utf8 (len: %d)\n"", len));
    break;
   }

  }
  if ( j >= GF_ARRAY_LENGTH(szLineConv) ) {
   GF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (""[TXTIn] Line too long to convert to utf8 (len: %d)\n"", len));
   j = GF_ARRAY_LENGTH(szLineConv) -1 ;
  }
  szLineConv[j] = 0;
  strcpy(szLine, szLineConv);"
https://huntr.dev/bounties/cb730bc5-d79c-4de6-9e57-10e8c3ce2cf3/,buffer over-read in function mhas_dmx_process filters/reframe_mhas.c in gpac/gpac,➜  gcc git:(master) ✗ ./MP4Box -version                  ,CVE-2023-0817,CWE-126: Buffer Over-read,https://www.github.com/gpac/gpac/commit/be9f8d395bbd196e3812e9cd80708f06bcc206f7,"@@ -198,12 +198,11 @@ static void mhas_dmx_check_dur(GF_Filter *filter, GF_MHASDmxCtx *ctx)
   if (!mhas_last_cfg) mhas_sap = 0;
  //config
  } else if (mhas_type==1) {
   u32 sr = 0;
   /*u32 pl = */gf_bs_read_u8(bs);
   u32 idx = gf_bs_read_int(bs, 5);
   if (idx==0x1f)
    duration.den = gf_bs_read_int(bs, 24);
   else if (sr < nb_usac_sr) {
    duration.den = USACSampleRates[idx];
   }
   idx = gf_bs_read_int(bs, 3);
@@ -621,7 +620,7 @@ GF_Err mhas_dmx_process(GF_Filter *filter)
   u32 idx = gf_bs_read_int(ctx->bs, 5);
   if (idx==0x1f)
    sr = gf_bs_read_int(ctx->bs, 24);
   else if (sr < nb_usac_sr) {
    sr = USACSampleRates[idx];
   }
   ctx->nb_unknown_pck = 0;

","5
src/filters/reframe_mhas.c
@@ -198,12 +198,11 @@ static void mhas_dmx_check_dur(GF_Filter *filter, GF_MHASDmxCtx *ctx)
   if (!mhas_last_cfg) mhas_sap = 0;
  //config
  } else if (mhas_type==1) {
   u32 sr = 0;
   /*u32 pl = */gf_bs_read_u8(bs);
   u32 idx = gf_bs_read_int(bs, 5);
   if (idx==0x1f)
    duration.den = gf_bs_read_int(bs, 24);
   else if (sr < nb_usac_sr) {
   else if (idx < nb_usac_sr) {
    duration.den = USACSampleRates[idx];
   }
   idx = gf_bs_read_int(bs, 3);
@@ -621,7 +620,7 @@ GF_Err mhas_dmx_process(GF_Filter *filter)
   u32 idx = gf_bs_read_int(ctx->bs, 5);
   if (idx==0x1f)
    sr = gf_bs_read_int(ctx->bs, 24);
   else if (sr < nb_usac_sr) {
   else if (idx < nb_usac_sr) {
    sr = USACSampleRates[idx];
   }
   ctx->nb_unknown_pck = 0;"
https://huntr.dev/bounties/d06223df-a473-4c82-96d0-23726b844b21/,Heap Buffer Overflow in function gf_isom_box_size at src/isomedia/box_funcs.c:1997 in gpac/gpac,Heap Buffer Overflow in function gf_isom_box_size at src/isomedia/box_funcs.c:1997,CVE-2023-0760,CWE-122: Heap-based Buffer Overflow,https://www.github.com/gpac/gpac/commit/ea7395f39f601a7750d48d606e9d10ea0b7beefe,"@@ -4429,7 +4429,7 @@ GF_Err video_sample_entry_box_size(GF_Box *s)

 /*VVC*/
 gf_isom_check_position(s, (GF_Box *)ptr->vvc_config, &pos);
 
 /*AV1*/
 gf_isom_check_position(s, (GF_Box *)ptr->av1_config, &pos);

@@ -8857,7 +8857,7 @@ GF_Err dac3_box_write(GF_Box *s, GF_BitStream *bs)
 e = gf_isom_box_write_header(s, bs);
 if (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DAC3;
 if (e) return e;
 
 e = gf_odf_ac3_cfg_write_bs(&ptr->cfg, bs);
 if (e) return e;

@@ -9983,6 +9983,9 @@ static void *sgpd_parse_entry(u32 grouping_type, GF_BitStream *bs, s32 bytes_in_
  }
  return ptr;
 }



 default:
  break;
 }

@@ -104,7 +104,7 @@ GF_Err gf_isom_box_parse_ex(GF_Box **outBox, GF_BitStream *bs, u32 parent_type,
 GF_Box *newBox;
 Bool skip_logs = (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_NO_LOGS ) ? GF_TRUE : GF_FALSE;
 Bool is_special = GF_TRUE;
 
 if ((bs == NULL) || (outBox == NULL) ) return GF_BAD_PARAM;
 *outBox = NULL;
 if (gf_bs_available(bs) < 8) {
@@ -1528,7 +1528,7 @@ static struct box_registry_entry {
 BOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YVYU, video_sample_entry, ""stsd"", ""apple""),
 BOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_RGBA, video_sample_entry, ""stsd"", ""apple""),
 BOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_ABGR, video_sample_entry, ""stsd"", ""apple""),
 
 FBOX_DEFINE_S(GF_QT_BOX_TYPE_STPS, stss, ""stbl"", 0, ""apple""),

 //dolby boxes
@@ -1918,7 +1918,7 @@ void gf_isom_check_position(GF_Box *s, GF_Box *child, u32 *pos)

 s32 cur_pos = gf_list_find(s->child_boxes, child);

 //happens when partially cloning boxes 
 if (cur_pos < 0) return;

 if (cur_pos != (s32) *pos) {
@@ -1949,7 +1949,7 @@ GF_Err gf_isom_box_write(GF_Box *a, GF_BitStream *bs)
 if (!a) return GF_BAD_PARAM;
 //box has been disabled, do not write
 if (!a->size) return GF_OK;
 
 if (a->registry->disabled) {
  GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[iso file] Box %s disabled registry, skip write\n"", gf_4cc_to_str(a->type)));
  return GF_OK;

@@ -2304,7 +2304,7 @@ GF_Err gf_isom_get_sample_for_media_time(GF_ISOFile *the_file, u32 trackNumber,
 }
 if (static_sample && ! (*sample)->alloc_size )
   (*sample)->alloc_size =  (*sample)->dataLength;
   
 return GF_OK;
}

@@ -4674,7 +4674,7 @@ const u32 *gf_isom_get_track_switch_parameter(GF_ISOFile *movie, u32 trackNumber
 if (!map) return NULL;
 tsel = (GF_TrackSelectionBox*)gf_list_get(map->boxes, group_index-1);
 if (!tsel) return NULL;
 
 *switchGroupID = tsel->switchGroup;
 *criteriaListSize = tsel->attributeListCount;
 return (const u32 *) tsel->attributeList;
@@ -5409,7 +5409,7 @@ GF_Err gf_isom_get_sample_cenc_info_internal(GF_TrackBox *trak, void *traf, GF_S
 if (skip_byte_block) *skip_byte_block = 0;
 if (key_info) *key_info = NULL;
 if (key_info_size) *key_info_size = 0;
 
 if (!trak) return GF_BAD_PARAM;

#ifdef GPAC_DISABLE_ISOM_FRAGMENTS

","7
src/isomedia/box_code_base.c
@@ -4429,7 +4429,7 @@ GF_Err video_sample_entry_box_size(GF_Box *s)

 /*VVC*/
 gf_isom_check_position(s, (GF_Box *)ptr->vvc_config, &pos);
 
 /*AV1*/
 gf_isom_check_position(s, (GF_Box *)ptr->av1_config, &pos);

@@ -8857,7 +8857,7 @@ GF_Err dac3_box_write(GF_Box *s, GF_BitStream *bs)
 e = gf_isom_box_write_header(s, bs);
 if (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DAC3;
 if (e) return e;
 
 e = gf_odf_ac3_cfg_write_bs(&ptr->cfg, bs);
 if (e) return e;

@@ -9983,6 +9983,9 @@ static void *sgpd_parse_entry(u32 grouping_type, GF_BitStream *bs, s32 bytes_in_
  }
  return ptr;
 }
 case 0:
  GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] sgpd entry null grouping_type is invalid\n"") );
  return NULL;
 default:
  break;
 }
8
src/isomedia/box_funcs.c
@@ -104,7 +104,7 @@ GF_Err gf_isom_box_parse_ex(GF_Box **outBox, GF_BitStream *bs, u32 parent_type,
 GF_Box *newBox;
 Bool skip_logs = (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_NO_LOGS ) ? GF_TRUE : GF_FALSE;
 Bool is_special = GF_TRUE;
 
 if ((bs == NULL) || (outBox == NULL) ) return GF_BAD_PARAM;
 *outBox = NULL;
 if (gf_bs_available(bs) < 8) {
@@ -1528,7 +1528,7 @@ static struct box_registry_entry {
 BOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_YVYU, video_sample_entry, ""stsd"", ""apple""),
 BOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_RGBA, video_sample_entry, ""stsd"", ""apple""),
 BOX_DEFINE_S_CHILD( GF_QT_SUBTYPE_ABGR, video_sample_entry, ""stsd"", ""apple""),
 
 FBOX_DEFINE_S(GF_QT_BOX_TYPE_STPS, stss, ""stbl"", 0, ""apple""),

 //dolby boxes
@@ -1918,7 +1918,7 @@ void gf_isom_check_position(GF_Box *s, GF_Box *child, u32 *pos)

 s32 cur_pos = gf_list_find(s->child_boxes, child);

 //happens when partially cloning boxes 
 //happens when partially cloning boxes
 if (cur_pos < 0) return;

 if (cur_pos != (s32) *pos) {
@@ -1949,7 +1949,7 @@ GF_Err gf_isom_box_write(GF_Box *a, GF_BitStream *bs)
 if (!a) return GF_BAD_PARAM;
 //box has been disabled, do not write
 if (!a->size) return GF_OK;
 
 if (a->registry->disabled) {
  GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[iso file] Box %s disabled registry, skip write\n"", gf_4cc_to_str(a->type)));
  return GF_OK;
6
src/isomedia/isom_read.c
@@ -2304,7 +2304,7 @@ GF_Err gf_isom_get_sample_for_media_time(GF_ISOFile *the_file, u32 trackNumber,
 }
 if (static_sample && ! (*sample)->alloc_size )
   (*sample)->alloc_size =  (*sample)->dataLength;
   
 return GF_OK;
}

@@ -4674,7 +4674,7 @@ const u32 *gf_isom_get_track_switch_parameter(GF_ISOFile *movie, u32 trackNumber
 if (!map) return NULL;
 tsel = (GF_TrackSelectionBox*)gf_list_get(map->boxes, group_index-1);
 if (!tsel) return NULL;
 
 *switchGroupID = tsel->switchGroup;
 *criteriaListSize = tsel->attributeListCount;
 return (const u32 *) tsel->attributeList;
@@ -5409,7 +5409,7 @@ GF_Err gf_isom_get_sample_cenc_info_internal(GF_TrackBox *trak, void *traf, GF_S
 if (skip_byte_block) *skip_byte_block = 0;
 if (key_info) *key_info = NULL;
 if (key_info_size) *key_info_size = 0;
 
 if (!trak) return GF_BAD_PARAM;

#ifdef GPAC_DISABLE_ISOM_FRAGMENTS"
https://huntr.dev/bounties/93e128ed-253f-4c42-81ff-fbac7fd8f355/,heap-use-after-free in gf_odf_vvc_cfg_read_bs in gpac/gpac,heap-use-after-free in gf_odf_vvc_cfg_read_bs at odf/descriptors.c:1403,CVE-2023-0358,CWE-416: Use After Free,https://www.github.com/gpac/gpac/commit/9971fb125cf91cefd081a080c417b90bbe4a467b,"@@ -1395,12 +1395,12 @@ GF_VVCConfig *gf_odf_vvc_cfg_read_bs(GF_BitStream *bs)
   gf_list_add(cfg->param_array, ar);
   break;
  default:
   GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (""[VVC] Invalid NALU type in vvcC - ignoring\n"", ar->nalus));
   gf_free(ar);
   break;
  }

  if ((ar->type != GF_VVC_NALU_DEC_PARAM) && (ar->type != GF_VVC_NALU_OPI))
   nalucount = gf_bs_read_int(bs, 16);
  else
   nalucount = 1;

","4
src/odf/descriptors.c
@@ -1395,12 +1395,12 @@ GF_VVCConfig *gf_odf_vvc_cfg_read_bs(GF_BitStream *bs)
   gf_list_add(cfg->param_array, ar);
   break;
  default:
   GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (""[VVC] Invalid NALU type in vvcC - ignoring\n"", ar->nalus));
   GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (""[VVC] Invalid NALU type %d in vvcC - ignoring\n"", ar->type));
   gf_free(ar);
   break;
  }

  if ((ar->type != GF_VVC_NALU_DEC_PARAM) && (ar->type != GF_VVC_NALU_OPI))
  if (!valid || ((ar->type != GF_VVC_NALU_DEC_PARAM) && (ar->type != GF_VVC_NALU_OPI)))
   nalucount = gf_bs_read_int(bs, 16);
  else
   nalucount = 1;"
https://huntr.dev/bounties/583133af-7ae6-4a21-beef-a4b0182cf82e/,ANSI Escape Sequence Injection in radareorg/radare2,"Injection of escape sequences opens up the possibility for concealing / modifying viewed data, and code execution (as some esc seqs feed data back to stdin).",CVE-2023-0302,CWE-75: Failure to Sanitize Special Elements into a Different Plane (Special Element Injection),https://www.github.com/radareorg/radare2/commit/961f0e723903011d4f54c2396e44efa91fcc74ce,"@@ -111,12 +111,13 @@ static bool meta_set(RAnal *a, RAnalMetaType type, int subtype, ut64 from, ut64
 item->subtype = subtype;
 item->space = space;
 free (item->str);
 item->str = str ? strdup (str) : NULL;
 if (str && !item->str) {
  if (!node) { // If we just created this
   free (item);
  }
  return false;

 }
 R_DIRTY (a);
 if (!node) {

@@ -431,6 +431,7 @@ static const ut8 *parse_line_header_source(RBinFile *bf, const ut8 *buf, const u
 int i = 0;
 size_t count;
 const ut8 *tmp_buf = NULL;


 if (mode == R_MODE_PRINT) {
  print ("" The Directory Table:\n"");
@@ -464,10 +465,12 @@ static const ut8 *parse_line_header_source(RBinFile *bf, const ut8 *buf, const u

 for (i = 0; i < 2; i++) {
  while (buf + 1 < buf_end) {
   const char *filename = (const char *)buf;
   size_t maxlen = R_MIN ((size_t) (buf_end - buf - 1), 0xfff);
   ut64 id_idx, mod_time, file_len;
   size_t len = r_str_nlen (filename, maxlen);




   if (!len) {
    buf++;
@@ -512,7 +515,7 @@ static const ut8 *parse_line_header_source(RBinFile *bf, const ut8 *buf, const u
    }

    if (hdr->file_names) {
     hdr->file_names[count].name = r_str_newf(""%s/%s"", r_str_get (include_dir), filename);
     hdr->file_names[count].id_idx = id_idx;
     hdr->file_names[count].mod_time = mod_time;
     hdr->file_names[count].file_len = file_len;
@@ -525,7 +528,8 @@ static const ut8 *parse_line_header_source(RBinFile *bf, const ut8 *buf, const u
   }
   count++;
   if (mode == R_MODE_PRINT && i) {
    print (""  %d     %"" PFMT64d ""       %"" PFMT64d ""         %"" PFMT64d ""          %s\n"", entry_index++, id_idx, mod_time, file_len, filename);

   }
  }
  if (i == 0) {
@@ -544,6 +548,7 @@ static const ut8 *parse_line_header_source(RBinFile *bf, const ut8 *buf, const u
 }

beach:

 sdb_free (sdb);

 return buf;
@@ -677,7 +682,6 @@ static const ut8 *parse_line_header(

static inline void add_sdb_addrline(Sdb *s, ut64 addr, const char *file, ut64 line, int mode, PrintfCallback print) {
 const char *p;
 char *fileline;
 char offset[SDB_NUM_BUFSZ];
 char *offset_ptr;

@@ -706,7 +710,10 @@ static inline void add_sdb_addrline(Sdb *s, ut64 addr, const char *file, ut64 li
#else
 p = file;
#endif
 fileline = r_str_newf (""%s|%""PFMT64d, p, line);



 offset_ptr = sdb_itoa (addr, 16, offset, sizeof (offset));
 sdb_add (s, offset_ptr, fileline, 0);
 sdb_add (s, fileline, offset_ptr, 0);
@@ -1666,7 +1673,15 @@ static const ut8 *parse_attr_value(const ut8 *obuf, int obuf_len,
  break;
 case DW_FORM_string:
  value->kind = DW_AT_KIND_STRING;
  value->string.content = *buf ? r_str_ndup ((const char *)buf, buf_end - buf) : NULL;








  if (value->string.content) {
   buf += strlen (value->string.content) + 1;
  }
@@ -1711,8 +1726,15 @@ static const ut8 *parse_attr_value(const ut8 *obuf, int obuf_len,
  value->kind = DW_AT_KIND_STRING;
  value->string.offset = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);
  if (debug_str && value->string.offset < debug_str_len) {
   const char *ds = (const char *)(debug_str + value->string.offset);
   value->string.content = strdup (ds); // r_str_ndup (ds, debug_str_len - value->string.offset);







  } else {
   value->string.content = NULL; // Means malformed DWARF, should we print error message?
  }
@@ -1903,8 +1925,11 @@ static const ut8 *parse_die(const ut8 *buf, const ut8 *buf_end, RBinDwarfAbbrevD
  // Or atleast it needs to rework becase there will be
  // more comp units -> more comp dirs and only the last one will be kept
  if (attribute->attr_name == DW_AT_comp_dir && is_valid_string_form) {
   const char *name = attribute->string.content;
   sdb_set (sdb, ""DW_AT_comp_dir"", name, 0);



  }
  die->count++;
 }

@@ -1,4 +1,4 @@
/* radare - LGPL - Copyright 2008-2021 - pancake */

#include <r_cons.h>
#include <ctype.h>
@@ -9,6 +9,7 @@
R_API char *r_cons_hud_file(const char *f) {
 char *s = r_file_slurp (f, NULL);
 if (s) {

  char *ret = r_cons_hud_string (s);
  free (s);
  return ret;
@@ -29,6 +30,7 @@ R_API char *r_cons_hud_line_string(const char *s) {
 }
 r_str_replace_ch (o, '\r', 0, true);
 r_str_replace_ch (o, '\t', 0, true);

 RList *fl = r_list_new ();
 int i;
 if (!fl) {
@@ -66,6 +68,7 @@ R_API char *r_cons_hud_string(const char *s) {
 if (!o) {
  return NULL;
 }

 r_str_replace_ch (o, '\r', 0, true);
 r_str_replace_ch (o, '\t', 0, true);
 RList *fl = r_list_new ();

@@ -539,10 +539,10 @@ static int cmd_meta_comment(RCore *core, const char *input) {
  break;
 case '!':
  {
   char *out;
   const char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);
   out = r_core_editor (core, NULL, comment);
   if (out) {

    //r_meta_set (core->anal->meta, R_META_TYPE_COMMENT, addr, 0, out);
    r_core_cmdf (core, ""CC-@0x%08""PFMT64x, addr);
    //r_meta_del (core->anal->meta, input[0], addr, addr+1);
@@ -560,6 +560,7 @@ static int cmd_meta_comment(RCore *core, const char *input) {
  char *text;
  char *nc = strdup (newcomment);
  r_str_unescape (nc);

  if (comment) {
   text = malloc (strlen (comment) + strlen (newcomment) + 2);
   if (text) {

@@ -1,4 +1,4 @@
/* radare - LGPL - Copyright 2009-2022 - pancake */

#include <r_core.h>
#include <limits.h>

@@ -1957,14 +1957,16 @@ R_API size_t r_str_ansi_nlen(const char *str, size_t slen) {
}

// remove ansi escape codes from string, decolorizing it

R_API size_t r_str_ansi_strip(char *str) {
 size_t i = 0;
 while (str[i]) {
  size_t chlen = __str_ansi_length (str + i);
  if (chlen > 1) {
   r_str_cpy (str + i + 1, str + i + chlen);


  }
  i++;
 }
 return i;
}

@@ -1,3 +1,55 @@




















































NAME=""open companion file for macho dwarf""
FILE=bins/mach0/dwarf/a.out
CMDS=<<EOF

","13
libr/anal/meta.c
@@ -111,12 +111,13 @@ static bool meta_set(RAnal *a, RAnalMetaType type, int subtype, ut64 from, ut64
 item->subtype = subtype;
 item->space = space;
 free (item->str);
 item->str = str ? strdup (str) : NULL;
 if (str && !item->str) {
  if (!node) { // If we just created this
   free (item);
  }
  return false;
 if (R_STR_ISNOTEMPTY (str)) {
  item->str = strdup (str);
  // this breaks the `ecHw` command
  // (highlights word in current instruction, which uses ansi
  // r_str_ansi_strip (item->str);
 } else {
  item->str = NULL;
 }
 R_DIRTY (a);
 if (!node) {
47
libr/bin/dwarf.c
@@ -431,6 +431,7 @@ static const ut8 *parse_line_header_source(RBinFile *bf, const ut8 *buf, const u
 int i = 0;
 size_t count;
 const ut8 *tmp_buf = NULL;
 char *fn = NULL;

 if (mode == R_MODE_PRINT) {
  print ("" The Directory Table:\n"");
@@ -464,10 +465,12 @@ static const ut8 *parse_line_header_source(RBinFile *bf, const ut8 *buf, const u

 for (i = 0; i < 2; i++) {
  while (buf + 1 < buf_end) {
   const char *filename = (const char *)buf;
   size_t maxlen = R_MIN ((size_t) (buf_end - buf - 1), 0xfff);
   ut64 id_idx, mod_time, file_len;
   size_t len = r_str_nlen (filename, maxlen);
   free (fn);
   fn = r_str_ndup ((const char *)buf, maxlen);
   r_str_ansi_strip (fn);
   size_t len = strlen (fn);

   if (!len) {
    buf++;
@@ -512,7 +515,7 @@ static const ut8 *parse_line_header_source(RBinFile *bf, const ut8 *buf, const u
    }

    if (hdr->file_names) {
     hdr->file_names[count].name = r_str_newf(""%s/%s"", r_str_get (include_dir), filename);
     hdr->file_names[count].name = r_str_newf(""%s/%s"", r_str_get (include_dir), fn);
     hdr->file_names[count].id_idx = id_idx;
     hdr->file_names[count].mod_time = mod_time;
     hdr->file_names[count].file_len = file_len;
@@ -525,7 +528,8 @@ static const ut8 *parse_line_header_source(RBinFile *bf, const ut8 *buf, const u
   }
   count++;
   if (mode == R_MODE_PRINT && i) {
    print (""  %d     %"" PFMT64d ""       %"" PFMT64d ""         %"" PFMT64d ""          %s\n"", entry_index++, id_idx, mod_time, file_len, filename);
    print (""  %d     %"" PFMT64d ""       %"" PFMT64d ""         %"" PFMT64d ""          %s\n"",
      entry_index++, id_idx, mod_time, file_len, fn);
   }
  }
  if (i == 0) {
@@ -544,6 +548,7 @@ static const ut8 *parse_line_header_source(RBinFile *bf, const ut8 *buf, const u
 }

beach:
 free (fn);
 sdb_free (sdb);

 return buf;
@@ -677,7 +682,6 @@ static const ut8 *parse_line_header(

static inline void add_sdb_addrline(Sdb *s, ut64 addr, const char *file, ut64 line, int mode, PrintfCallback print) {
 const char *p;
 char *fileline;
 char offset[SDB_NUM_BUFSZ];
 char *offset_ptr;

@@ -706,7 +710,10 @@ static inline void add_sdb_addrline(Sdb *s, ut64 addr, const char *file, ut64 li
#else
 p = file;
#endif
 fileline = r_str_newf (""%s|%""PFMT64d, p, line);
 char *fileline = r_str_newf (""%s|%""PFMT64d, p, line);
 r_str_ansi_strip (fileline);
 r_str_replace_ch (fileline, '\n', 0, true);
 r_str_replace_ch (fileline, '\t', 0, true);
 offset_ptr = sdb_itoa (addr, 16, offset, sizeof (offset));
 sdb_add (s, offset_ptr, fileline, 0);
 sdb_add (s, fileline, offset_ptr, 0);
@@ -1666,7 +1673,15 @@ static const ut8 *parse_attr_value(const ut8 *obuf, int obuf_len,
  break;
 case DW_FORM_string:
  value->kind = DW_AT_KIND_STRING;
  value->string.content = *buf ? r_str_ndup ((const char *)buf, buf_end - buf) : NULL;
  if (*buf) {
   char *name = r_str_ndup ((const char *)buf, buf_end - buf);
   r_str_ansi_strip (name);
   r_str_replace_ch (name, '\n', 0, true);
   r_str_replace_ch (name, '\t', 0, true);
   value->string.content = name;
  } else {
   value->string.content = NULL;
  }
  if (value->string.content) {
   buf += strlen (value->string.content) + 1;
  }
@@ -1711,8 +1726,15 @@ static const ut8 *parse_attr_value(const ut8 *obuf, int obuf_len,
  value->kind = DW_AT_KIND_STRING;
  value->string.offset = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);
  if (debug_str && value->string.offset < debug_str_len) {
   const char *ds = (const char *)(debug_str + value->string.offset);
   value->string.content = strdup (ds); // r_str_ndup (ds, debug_str_len - value->string.offset);
   char *ds = r_str_ndup ((const char *)(debug_str + value->string.offset), debug_str_len);
   if (ds) {
    r_str_ansi_strip (ds);
    r_str_replace_ch (ds, '\n', 0, true);
    r_str_replace_ch (ds, '\t', 0, true);
    value->string.content = ds;
   } else {
    value->string.content = NULL;
   }
  } else {
   value->string.content = NULL; // Means malformed DWARF, should we print error message?
  }
@@ -1903,8 +1925,11 @@ static const ut8 *parse_die(const ut8 *buf, const ut8 *buf_end, RBinDwarfAbbrevD
  // Or atleast it needs to rework becase there will be
  // more comp units -> more comp dirs and only the last one will be kept
  if (attribute->attr_name == DW_AT_comp_dir && is_valid_string_form) {
   const char *name = attribute->string.content;
   sdb_set (sdb, ""DW_AT_comp_dir"", name, 0);
   char *name = strdup (attribute->string.content);
   r_str_ansi_strip (name);
   r_str_replace_ch (name, '\n', 0, true);
   r_str_replace_ch (name, '\t', 0, true);
   sdb_set_owned (sdb, ""DW_AT_comp_dir"", name, 0);
  }
  die->count++;
 }
5
libr/cons/hud.c
@@ -1,4 +1,4 @@
/* radare - LGPL - Copyright 2008-2021 - pancake */
/* radare - LGPL - Copyright 2008-2023 - pancake */

#include <r_cons.h>
#include <ctype.h>
@@ -9,6 +9,7 @@
R_API char *r_cons_hud_file(const char *f) {
 char *s = r_file_slurp (f, NULL);
 if (s) {
  r_str_ansi_strip (s);
  char *ret = r_cons_hud_string (s);
  free (s);
  return ret;
@@ -29,6 +30,7 @@ R_API char *r_cons_hud_line_string(const char *s) {
 }
 r_str_replace_ch (o, '\r', 0, true);
 r_str_replace_ch (o, '\t', 0, true);
 r_str_ansi_strip (o);
 RList *fl = r_list_new ();
 int i;
 if (!fl) {
@@ -66,6 +68,7 @@ R_API char *r_cons_hud_string(const char *s) {
 if (!o) {
  return NULL;
 }
 r_str_ansi_strip (o);
 r_str_replace_ch (o, '\r', 0, true);
 r_str_replace_ch (o, '\t', 0, true);
 RList *fl = r_list_new ();
5
libr/core/cmd_meta.c
@@ -539,10 +539,10 @@ static int cmd_meta_comment(RCore *core, const char *input) {
  break;
 case '!':
  {
   char *out;
   const char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);
   out = r_core_editor (core, NULL, comment);
   char *out = r_core_editor (core, NULL, comment);
   if (out) {
    r_str_ansi_strip (out);
    //r_meta_set (core->anal->meta, R_META_TYPE_COMMENT, addr, 0, out);
    r_core_cmdf (core, ""CC-@0x%08""PFMT64x, addr);
    //r_meta_del (core->anal->meta, input[0], addr, addr+1);
@@ -560,6 +560,7 @@ static int cmd_meta_comment(RCore *core, const char *input) {
  char *text;
  char *nc = strdup (newcomment);
  r_str_unescape (nc);
  r_str_ansi_strip (nc);
  if (comment) {
   text = malloc (strlen (comment) + strlen (newcomment) + 2);
   if (text) {
2
libr/core/cmd_print.c
@@ -1,4 +1,4 @@
/* radare - LGPL - Copyright 2009-2022 - pancake */
/* radare - LGPL - Copyright 2009-2023 - pancake */

#include <r_core.h>
#include <limits.h>
6
libr/util/str.c
@@ -1957,14 +1957,16 @@ R_API size_t r_str_ansi_nlen(const char *str, size_t slen) {
}

// remove ansi escape codes from string, decolorizing it
// TODO : optimize by just using two counter variables instead of strcpy()
R_API size_t r_str_ansi_strip(char *str) {
 size_t i = 0;
 while (str[i]) {
  size_t chlen = __str_ansi_length (str + i);
  if (chlen > 1) {
   r_str_cpy (str + i + 1, str + i + chlen);
   r_str_cpy (str + i, str + i + chlen);
  } else {
   i++;
  }
  i++;
 }
 return i;
}
52
test/db/cmd/dwarf
@@ -1,3 +1,55 @@
NAME=""ansi injection via dwarf""
FILE=bins/elf/dwarf_test_func_patched
ARGS=-AA
CMDS=<<EOF
CL
xc
EOF
EXPECT=<<EOF
file: /_test.c
line: 5
addr: 0x00001159
file: /_test.c
line: 11
addr: 0x00001184
file: /_test.c
line: 6
addr: 0x00001165
file: /_test.c
line: 11
addr: 0x00001186
file: /_test.c
line: 9
addr: 0x00001170
file: /_test.c
line: 8
addr: 0x00001168
file: /_test.c
line: 4
addr: 0x00001149
file: /_test.c
line: 10
addr: 0x0000117f
- offset -  6061 6263 6465 6667 6869 6A6B 6C6D 6E6F  0123456789ABCDEF  comment
0x00001060  f30f 1efa 31ed 4989 d15e 4889 e248 83e4  ....1.I..^H..H..  ; rip ; [16] -r-x section size 294 named .text ; arg3
0x00001070  f050 5445 31c0 31c9 488d 3de9 0000 00ff  .PTE1.1.H.=.....
0x00001080  1553 2f00 00f4 662e 0f1f 8400 0000 0000  .S/...f.........
0x00001090  488d 3d79 2f00 0048 8d05 722f 0000 4839  H.=y/..H..r/..H9  ; sym.deregister_tm_clones
0x000010a0  f874 1548 8b05 362f 0000 4885 c074 09ff  .t.H..6/..H..t..
0x000010b0  e00f 1f80 0000 0000 c30f 1f80 0000 0000  ................
0x000010c0  488d 3d49 2f00 0048 8d35 422f 0000 4829  H.=I/..H.5B/..H)  ; sym.register_tm_clones
0x000010d0  fe48 89f0 48c1 ee3f 48c1 f803 4801 c648  .H..H..?H...H..H
0x000010e0  d1fe 7414 488b 0505 2f00 0048 85c0 7408  ..t.H.../..H..t.
0x000010f0  ffe0 660f 1f44 0000 c30f 1f80 0000 0000  ..f..D..........
0x00001100  f30f 1efa 803d 052f 0000 0075 2b55 4883  .....=./...u+UH.  ; sym.__do_global_dtors_aux
0x00001110  3de2 2e00 0000 4889 e574 0c48 8b3d e62e  =.....H..t.H.=..
0x00001120  0000 e819 ffff ffe8 64ff ffff c605 dd2e  ........d.......
0x00001130  0000 015d c30f 1f00 c30f 1f80 0000 0000  ...]............
0x00001140  f30f 1efa e977 ffff fff3 0f1e fa55 4889  .....w.......UH.  ; sym.frame_dummy  ; dbg._func ; void _func(char * msg);
0x00001150  e548 83ec 1048 897d f848 8b45 f848 89c7  .H...H.}.H.E.H.. ; arg1 ; const char *s
EOF
RUN

NAME=""open companion file for macho dwarf""
FILE=bins/mach0/dwarf/a.out
CMDS=<<EOF"
https://huntr.dev/bounties/e0fdeee5-7909-446e-9bd0-db80fd80e8dd/,Stack-Based Buffer Overflow in gf_sg_proto_field_is_sftime_offset in gpac/gpac,Stack-Based Buffer Overflow in gf_sg_proto_field_is_sftime_offset at vrml_proto.c:1295.,CVE-2023-0770,CWE-121: Stack-based Buffer Overflow,https://www.github.com/gpac/gpac/commit/c31941822ee275a35bc148382bafef1c53ec1c26,"@@ -1292,7 +1292,10 @@ Bool gf_sg_proto_field_is_sftime_offset(GF_Node *node, GF_FieldInfo *field)

  gf_node_get_field(r->ToNode, r->ToField.fieldIndex, &inf);
  /*IS to another proto*/
  if (r->ToNode->sgprivate->tag == TAG_ProtoNode) return gf_sg_proto_field_is_sftime_offset(r->ToNode, &inf);



  /*IS to a startTime/stopTime field*/
  if (!stricmp(inf.name, ""startTime"") || !stricmp(inf.name, ""stopTime"")) return 1;
 }

","5
src/scenegraph/vrml_proto.c
@@ -1292,7 +1292,10 @@ Bool gf_sg_proto_field_is_sftime_offset(GF_Node *node, GF_FieldInfo *field)

  gf_node_get_field(r->ToNode, r->ToField.fieldIndex, &inf);
  /*IS to another proto*/
  if (r->ToNode->sgprivate->tag == TAG_ProtoNode) return gf_sg_proto_field_is_sftime_offset(r->ToNode, &inf);
  if (r->ToNode->sgprivate->tag == TAG_ProtoNode) {
   if (r->ToNode==node) continue;
   return gf_sg_proto_field_is_sftime_offset(r->ToNode, &inf);
  }
  /*IS to a startTime/stopTime field*/
  if (!stricmp(inf.name, ""startTime"") || !stricmp(inf.name, ""stopTime"")) return 1;
 }"
https://huntr.dev/bounties/bc91aa7e-576d-46bb-ad84-16b8f59f5b42/,heap-buffer-overflow in gf_isom_box_write_header in gpac/gpac,heap-buffer-overflow in gf_isom_box_write_header at isomedia/box_funcs.c:408.,,CWE-122: Heap-based Buffer Overflow,https://www.github.com/gpac/gpac/commit/000c84a87f73b901d267e6f96446e9bfc78d1214,"@@ -815,6 +815,7 @@ GF_Err unkn_box_write(GF_Box *s, GF_BitStream *bs)
 u32 type;
 GF_UnknownBox *ptr = (GF_UnknownBox *)s;
 if (!s) return GF_BAD_PARAM;

 type = s->type;
 ptr->type = ptr->original_4cc;
 e = gf_isom_box_write_header(s, bs);
@@ -1526,6 +1527,7 @@ GF_Err gnrm_box_write(GF_Box *s, GF_BitStream *bs)
 GF_GenericSampleEntryBox *ptr = (GF_GenericSampleEntryBox *)s;

 //careful we are not writing the box type but the entry type so switch for write

 ptr->type = ptr->EntryType;
 e = gf_isom_box_write_header(s, bs);
 if (e) return e;
@@ -1576,6 +1578,7 @@ GF_Err gnrv_box_write(GF_Box *s, GF_BitStream *bs)
 GF_GenericVisualSampleEntryBox *ptr = (GF_GenericVisualSampleEntryBox *)s;

 //careful we are not writing the box type but the entry type so switch for write

 ptr->type = ptr->EntryType;
 e = gf_isom_box_write_header(s, bs);
 if (e) return e;
@@ -1627,6 +1630,7 @@ GF_Err gnra_box_write(GF_Box *s, GF_BitStream *bs)
 GF_GenericAudioSampleEntryBox *ptr = (GF_GenericAudioSampleEntryBox *)s;

 //careful we are not writing the box type but the entry type so switch for write

 ptr->type = ptr->EntryType;
 e = gf_isom_box_write_header(s, bs);
 if (e) return e;
@@ -7257,6 +7261,7 @@ GF_Err reftype_box_write(GF_Box *s, GF_BitStream *bs)
 GF_Err e;
 u32 i;
 GF_TrackReferenceTypeBox *ptr = (GF_TrackReferenceTypeBox *)s;

 ptr->type = ptr->reference_type;
 e = gf_isom_box_write_header(s, bs);
 ptr->type = GF_ISOM_BOX_TYPE_REFT;
@@ -10663,6 +10668,7 @@ GF_Err trgt_box_write(GF_Box *s, GF_BitStream *bs)
 GF_Err e;
 GF_TrackGroupTypeBox *ptr = (GF_TrackGroupTypeBox *) s;
 if (!s) return GF_BAD_PARAM;

 s->type = ptr->group_type;
 e = gf_isom_full_box_write(s, bs);
 s->type = GF_ISOM_BOX_TYPE_TRGT;

","6
src/isomedia/box_code_base.c
@@ -815,6 +815,7 @@ GF_Err unkn_box_write(GF_Box *s, GF_BitStream *bs)
 u32 type;
 GF_UnknownBox *ptr = (GF_UnknownBox *)s;
 if (!s) return GF_BAD_PARAM;
 if (ptr->original_4cc == GF_ISOM_BOX_TYPE_UUID) return GF_BAD_PARAM;
 type = s->type;
 ptr->type = ptr->original_4cc;
 e = gf_isom_box_write_header(s, bs);
@@ -1526,6 +1527,7 @@ GF_Err gnrm_box_write(GF_Box *s, GF_BitStream *bs)
 GF_GenericSampleEntryBox *ptr = (GF_GenericSampleEntryBox *)s;

 //careful we are not writing the box type but the entry type so switch for write
 if (ptr->EntryType == GF_ISOM_BOX_TYPE_UUID) return GF_BAD_PARAM;
 ptr->type = ptr->EntryType;
 e = gf_isom_box_write_header(s, bs);
 if (e) return e;
@@ -1576,6 +1578,7 @@ GF_Err gnrv_box_write(GF_Box *s, GF_BitStream *bs)
 GF_GenericVisualSampleEntryBox *ptr = (GF_GenericVisualSampleEntryBox *)s;

 //careful we are not writing the box type but the entry type so switch for write
 if (ptr->EntryType == GF_ISOM_BOX_TYPE_UUID) return GF_BAD_PARAM;
 ptr->type = ptr->EntryType;
 e = gf_isom_box_write_header(s, bs);
 if (e) return e;
@@ -1627,6 +1630,7 @@ GF_Err gnra_box_write(GF_Box *s, GF_BitStream *bs)
 GF_GenericAudioSampleEntryBox *ptr = (GF_GenericAudioSampleEntryBox *)s;

 //careful we are not writing the box type but the entry type so switch for write
 if (ptr->EntryType == GF_ISOM_BOX_TYPE_UUID) return GF_BAD_PARAM;
 ptr->type = ptr->EntryType;
 e = gf_isom_box_write_header(s, bs);
 if (e) return e;
@@ -7257,6 +7261,7 @@ GF_Err reftype_box_write(GF_Box *s, GF_BitStream *bs)
 GF_Err e;
 u32 i;
 GF_TrackReferenceTypeBox *ptr = (GF_TrackReferenceTypeBox *)s;
 if (ptr->reference_type == GF_ISOM_BOX_TYPE_UUID) return GF_BAD_PARAM;
 ptr->type = ptr->reference_type;
 e = gf_isom_box_write_header(s, bs);
 ptr->type = GF_ISOM_BOX_TYPE_REFT;
@@ -10663,6 +10668,7 @@ GF_Err trgt_box_write(GF_Box *s, GF_BitStream *bs)
 GF_Err e;
 GF_TrackGroupTypeBox *ptr = (GF_TrackGroupTypeBox *) s;
 if (!s) return GF_BAD_PARAM;
 if (ptr->group_type == GF_ISOM_BOX_TYPE_UUID) return GF_BAD_PARAM;
 s->type = ptr->group_type;
 e = gf_isom_full_box_write(s, bs);
 s->type = GF_ISOM_BOX_TYPE_TRGT;"
https://huntr.dev/bounties/075b2760-66a0-4d38-b3b5-e9934956ab7f/,NULL Pointer Dereference in radareorg/radare2,Distributor ID: Debian,CVE-2022-4843,CWE-476: NULL Pointer Dereference,https://www.github.com/radareorg/radare2/commit/842f809d4ec6a12af2906f948657281c9ebc8a24,"@@ -786,7 +786,7 @@ R_API bool r_io_bank_read_at(RIO *io, const ut32 bankid, ut64 addr, ut8 *buf, in
  const ut64 buf_off = R_MAX (addr, r_io_submap_from (sm)) - addr;
  const int read_len = R_MIN (r_io_submap_to ((&fake_sm)),
          r_io_submap_to (sm)) - (addr + buf_off) + 1;
  if (map->perm & R_PERM_RELOC) {
   ret &= map->reloc_map->read (io, map, addr + buf_off, &buf[buf_off], read_len);
  } else {
   const ut64 paddr = addr + buf_off - r_io_map_from (map) + map->delta;
@@ -875,7 +875,7 @@ R_API int r_io_bank_read_from_submap_at(RIO *io, const ut32 bankid, ut64 addr, u
  return -1;
 }
 const int read_len = R_MIN (len, r_io_submap_to (sm) - addr + 1);
 if (map->perm & R_PERM_RELOC) {
  return map->reloc_map->read (io, map, addr, buf, read_len);
 }
 const ut64 paddr = addr - r_io_map_from (map) + map->delta;

","4
libr/io/io_bank.c
@@ -786,7 +786,7 @@ R_API bool r_io_bank_read_at(RIO *io, const ut32 bankid, ut64 addr, ut8 *buf, in
  const ut64 buf_off = R_MAX (addr, r_io_submap_from (sm)) - addr;
  const int read_len = R_MIN (r_io_submap_to ((&fake_sm)),
          r_io_submap_to (sm)) - (addr + buf_off) + 1;
  if (map->perm & R_PERM_RELOC) {
  if (map->perm & R_PERM_RELOC && map->reloc_map) {
   ret &= map->reloc_map->read (io, map, addr + buf_off, &buf[buf_off], read_len);
  } else {
   const ut64 paddr = addr + buf_off - r_io_map_from (map) + map->delta;
@@ -875,7 +875,7 @@ R_API int r_io_bank_read_from_submap_at(RIO *io, const ut32 bankid, ut64 addr, u
  return -1;
 }
 const int read_len = R_MIN (len, r_io_submap_to (sm) - addr + 1);
 if (map->perm & R_PERM_RELOC) {
 if (map->perm & R_PERM_RELOC && map->reloc_map) {
  return map->reloc_map->read (io, map, addr, buf, read_len);
 }
 const ut64 paddr = addr - r_io_map_from (map) + map->delta;"
https://huntr.dev/bounties/c6f8d3ef-5420-4eba-9a5f-aba5e2b5fea2/,Integer overflow in realloc call in radareorg/radare2,"Integer overflow in realloc and memcpy calls in core_anal_graph_label. In the process of concatenating source lines based on DWARF data, the resulting size (32bit signed int) can overflow. The sizes of the realloc and memcpy calls differ, and potentially can lead to writes in an unintended location.",CVE-2022-4398,CWE-190: Integer Overflow or Wraparound,https://www.github.com/radareorg/radare2/commit/b53a1583d05c3a5bfe5fa60da133fe59dfbb02b8,"@@ -70,6 +70,9 @@ RUN DEBIAN_FRONTEND=noninteractive dpkg --add-architecture i386 && \
  bison \
  pkg-config \
  make \



  glib-2.0 \
  libc6:i386 \
  libncurses5:i386 \

@@ -1390,6 +1390,10 @@ static char *core_anal_graph_label(RCore *core, RAnalBlock *bb, int opts) {
    filestr = r_file_slurp_line (file, line, 0);
    if (filestr) {
     int flen = strlen (filestr);




     cmdstr = realloc (cmdstr, idx + flen + 8);
     memcpy (cmdstr + idx, filestr, flen);
     idx += flen;

","3
dist/docker/Dockerfile
@@ -70,6 +70,9 @@ RUN DEBIAN_FRONTEND=noninteractive dpkg --add-architecture i386 && \
  bison \
  pkg-config \
  make \
  python3 \
  python3-pip \
  sudo \
  glib-2.0 \
  libc6:i386 \
  libncurses5:i386 \
4
libr/core/canal.c
@@ -1390,6 +1390,10 @@ static char *core_anal_graph_label(RCore *core, RAnalBlock *bb, int opts) {
    filestr = r_file_slurp_line (file, line, 0);
    if (filestr) {
     int flen = strlen (filestr);
     if (idx < 0 || ST32_ADD_OVFCHK (idx, flen + 8)) {
      R_LOG_WARN (""integer overflow detected"");
      break;
     }
     cmdstr = realloc (cmdstr, idx + flen + 8);
     memcpy (cmdstr + idx, filestr, flen);
     idx += flen;"
https://huntr.dev/bounties/a939a0de-5330-48f2-9fda-8df938e81529/,Uncontrolled Memory Allocation in function lodepng_realloc in hpjansson/chafa,Uncontrolled Memory Allocation in function lodepng_realloc at lodepng/lodepng.c:86,,CWE-770: Allocation of Resources Without Limits or Throttling,https://www.github.com/hpjansson/chafa/commit/c9a893d16ac7bc761a0a115667ad6fc1066c01a3,"@@ -4975,16 +4975,30 @@ static void decodeGeneric(unsigned char** out, unsigned* w, unsigned* h,
      expected_size += lodepng_get_raw_size_idat((*w + 0), (*h + 0) >> 1, bpp);
    }







    state->error = zlib_decompress(&scanlines, &scanlines_size, expected_size, idat, idatsize, &state->decoder.zlibsettings);
  }

  if(!state->error && scanlines_size != expected_size) state->error = 91; /*decompressed size doesn't match prediction*/
  lodepng_free(idat);

  if(!state->error) {
    outsize = lodepng_get_raw_size(*w, *h, &state->info_png.color);






    *out = (unsigned char*)lodepng_malloc(outsize);
    if(!*out) state->error = 83; /*alloc fail*/
  }

  if(!state->error) {
    lodepng_memset(*out, 0, outsize);
    state->error = postProcessScanlines(*out, scanlines, *w, *h, &state->info_png);
@@ -6302,6 +6316,8 @@ const char* lodepng_error_text(unsigned code) {
    /*max ICC size limit can be configured in LodePNGDecoderSettings. This error prevents
    unreasonable memory consumption when decoding due to impossibly large ICC profile*/
    case 113: return ""ICC profile unreasonably large"";


  }
  return ""unknown error code"";
}

@@ -30,6 +30,10 @@ freely, subject to the following restrictions:

extern const char* LODEPNG_VERSION_STRING;





/*
The following #defines are used to create code sections. They can be disabled
to disable code sections, which can give faster compile time and smaller binary.

","16
lodepng/lodepng.c
@@ -4975,16 +4975,30 @@ static void decodeGeneric(unsigned char** out, unsigned* w, unsigned* h,
      expected_size += lodepng_get_raw_size_idat((*w + 0), (*h + 0) >> 1, bpp);
    }

    if(expected_size > LODEPNG_IMAGE_DATA_SIZE_MAX) {
      state->error = 114;
    }
  }

  if (!state->error) {
    state->error = zlib_decompress(&scanlines, &scanlines_size, expected_size, idat, idatsize, &state->decoder.zlibsettings);
  }

  if(!state->error && scanlines_size != expected_size) state->error = 91; /*decompressed size doesn't match prediction*/
  lodepng_free(idat);

  if(!state->error) {
    outsize = lodepng_get_raw_size(*w, *h, &state->info_png.color);
    if (outsize > LODEPNG_IMAGE_DATA_SIZE_MAX) {
      state->error = 114;
    }
  }

  if(!state->error) {
    *out = (unsigned char*)lodepng_malloc(outsize);
    if(!*out) state->error = 83; /*alloc fail*/
  }

  if(!state->error) {
    lodepng_memset(*out, 0, outsize);
    state->error = postProcessScanlines(*out, scanlines, *w, *h, &state->info_png);
@@ -6302,6 +6316,8 @@ const char* lodepng_error_text(unsigned code) {
    /*max ICC size limit can be configured in LodePNGDecoderSettings. This error prevents
    unreasonable memory consumption when decoding due to impossibly large ICC profile*/
    case 113: return ""ICC profile unreasonably large"";
    /*max size of an in-memory image buffer*/
    case 114: return ""image data unreasonably large"";
  }
  return ""unknown error code"";
}
4
lodepng/lodepng.h
@@ -30,6 +30,10 @@ freely, subject to the following restrictions:

extern const char* LODEPNG_VERSION_STRING;

/*Hard upper limit on size of an uncompressed in-memory image buffer. The
total memory consumption may be higher, e.g. during postProcessScanlines().*/
#define LODEPNG_IMAGE_DATA_SIZE_MAX 0xffffffffU

/*
The following #defines are used to create code sections. They can be disabled
to disable code sections, which can give faster compile time and smaller binary."
https://huntr.dev/bounties/bd81f4cc-a849-4c90-9210-f606c3b492e9/,Null Pointer Dereference Caused Segmentation Fault in gpac/gpac,Null pointer dereference caused segmentation fault. This can cause Denial-of -service attack.,,CWE-476: NULL Pointer Dereference,https://www.github.com/gpac/gpac/commit/4c7730384f0ec26b79d536ba79fbbfc746fda87a,"@@ -3358,9 +3358,9 @@ void DumpTrackInfo(GF_ISOFile *file, GF_ISOTrackID trackID, Bool full_dump, Bool
  fprintf(stderr, ""\t3GPP DIMS stream - size %d x %d - Profile %d - Level %d\n"", w, h, dims.profile, dims.level);
  fprintf(stderr, ""\tpathComponents: %d - useFullRequestHost: %s\n"", dims.pathComponents, dims.fullRequestHost ? ""yes"" : ""no"");
  fprintf(stderr, ""\tstream type: %s - redundant: %s\n"", dims.streamType ? ""primary"" : ""secondary"", (dims.containsRedundant==1) ? ""main"" : ((dims.containsRedundant==2) ? ""redundant"" : ""main+redundant"") );
  if (dims.textEncoding[0]) fprintf(stderr, ""\ttext encoding %s\n"", dims.textEncoding);
  if (dims.contentEncoding[0]) fprintf(stderr, ""\tcontent encoding %s\n"", dims.contentEncoding);
  if (dims.content_script_types) fprintf(stderr, ""\tscript languages %s\n"", dims.content_script_types);
 } else if (mtype==GF_ISOM_MEDIA_HINT) {
  u32 refTrack;
  s32 refCount = gf_isom_get_reference_count(file, trackNum, GF_ISOM_REF_HINT);

","6
applications/mp4box/filedump.c
@@ -3358,9 +3358,9 @@ void DumpTrackInfo(GF_ISOFile *file, GF_ISOTrackID trackID, Bool full_dump, Bool
  fprintf(stderr, ""\t3GPP DIMS stream - size %d x %d - Profile %d - Level %d\n"", w, h, dims.profile, dims.level);
  fprintf(stderr, ""\tpathComponents: %d - useFullRequestHost: %s\n"", dims.pathComponents, dims.fullRequestHost ? ""yes"" : ""no"");
  fprintf(stderr, ""\tstream type: %s - redundant: %s\n"", dims.streamType ? ""primary"" : ""secondary"", (dims.containsRedundant==1) ? ""main"" : ((dims.containsRedundant==2) ? ""redundant"" : ""main+redundant"") );
  if (dims.textEncoding[0]) fprintf(stderr, ""\ttext encoding %s\n"", dims.textEncoding);
  if (dims.contentEncoding[0]) fprintf(stderr, ""\tcontent encoding %s\n"", dims.contentEncoding);
  if (dims.content_script_types) fprintf(stderr, ""\tscript languages %s\n"", dims.content_script_types);
  if (dims.textEncoding && dims.textEncoding[0]) fprintf(stderr, ""\ttext encoding %s\n"", dims.textEncoding);
  if (dims.contentEncoding && dims.contentEncoding[0]) fprintf(stderr, ""\tcontent encoding %s\n"", dims.contentEncoding);
  if (dims.content_script_types && dims.content_script_types[0]) fprintf(stderr, ""\tscript languages %s\n"", dims.content_script_types);
 } else if (mtype==GF_ISOM_MEDIA_HINT) {
  u32 refTrack;
  s32 refCount = gf_isom_get_reference_count(file, trackNum, GF_ISOM_REF_HINT);"
https://huntr.dev/bounties/b29c69fa-3eac-41e4-9d4f-d861aba18235/,Segmentation Fault in SFS_Expression in gpac/gpac,Version,CVE-2022-3222,CWE-674: Uncontrolled Recursion,https://www.github.com/gpac/gpac/commit/4e7736d7ec7bf64026daa611da951993bb42fdaf,"@@ -3339,7 +3339,7 @@
     /usr/local/lib,
     /opt/local/lib,
    );
    MACOSX_DEPLOYMENT_TARGET = 10.6;
    ONLY_ACTIVE_ARCH = YES;
    OTHER_LDFLAGS = ""-lSDL2"";
    PRODUCT_NAME = ""$(TARGET_NAME)"";
@@ -3378,7 +3378,7 @@
     /usr/local/lib,
     /opt/local/lib,
    );
    MACOSX_DEPLOYMENT_TARGET = 10.6;
    OTHER_LDFLAGS = ""-lSDL2"";
    PRODUCT_NAME = ""$(TARGET_NAME)"";
    SDKROOT = macosx;

@@ -40,6 +40,7 @@ typedef struct
 GF_List *identifiers;
 char *new_line;
 u32 indent;

} ScriptParser;


@@ -169,6 +170,7 @@ GF_Err SFScript_Parse(GF_BifsDecoder *codec, SFScript *script_field, GF_BitStrea
 e = GF_OK;
 if (gf_node_get_tag(n) != TAG_MPEG4_Script) return GF_NON_COMPLIANT_BITSTREAM;


 parser.codec = codec;
 parser.script = n;
 parser.bs = bs;
@@ -209,6 +211,10 @@ GF_Err SFScript_Parse(GF_BifsDecoder *codec, SFScript *script_field, GF_BitStrea
  SFS_Space(&parser);
  SFS_StatementBlock(&parser, GF_TRUE);
  SFS_Line(&parser);




 }

 SFS_Line(&parser);
@@ -418,6 +424,7 @@ void SFS_CompoundExpression(ScriptParser *parser)
 if (parser->codec->LastError) return;
 SFS_Expression(parser);
 if (! gf_bs_read_int(parser->bs, 1)) return;

 SFS_AddString(parser, "","");
 SFS_CompoundExpression(parser);
}
@@ -430,12 +437,20 @@ void SFS_OptionalExpression(ScriptParser *parser)
 }
}


void SFS_Expression(ScriptParser *parser)
{
 u32 val = gf_bs_read_int(parser->bs, NUMBITS_EXPR_TYPE);
 if (parser->codec->LastError) return;









 switch(val) {
 case ET_CURVED_EXPR:
  SFS_AddString(parser, ""("");
@@ -675,6 +690,7 @@ void SFS_Expression(ScriptParser *parser)
  parser->codec->LastError = GF_NON_COMPLIANT_BITSTREAM;
  break;
 }

}

void SFS_NewObject(ScriptParser *parser)
@@ -691,6 +707,7 @@ void SFS_ArrayDeref(ScriptParser *parser)
{
 if (parser->codec->LastError) return;
 SFS_Expression(parser);

 SFS_AddString(parser, ""["");
 SFS_CompoundExpression(parser);
 SFS_AddString(parser, ""]"");
@@ -709,6 +726,7 @@ void SFS_ObjectMemberAccess(ScriptParser *parser)
{
 if (parser->codec->LastError) return;
 SFS_Expression(parser);

 SFS_AddString(parser, ""."");
 SFS_Identifier(parser);
}
@@ -718,6 +736,7 @@ void SFS_ObjectMethodCall(ScriptParser *parser)
{
 if (parser->codec->LastError) return;
 SFS_Expression(parser);

 SFS_AddString(parser, ""."");
 SFS_Identifier(parser);
 SFS_AddString(parser, ""("");
@@ -732,6 +751,7 @@ void SFS_Params(ScriptParser *parser)
 val = gf_bs_read_int(parser->bs, 1);
 while (val) {
  SFS_Expression(parser);

  val = gf_bs_read_int(parser->bs, 1);
  if(val) SFS_AddString(parser, "","");
 }

","4
build/xcode/gpac.xcodeproj/project.pbxproj
@@ -3339,7 +3339,7 @@
     /usr/local/lib,
     /opt/local/lib,
    );
    MACOSX_DEPLOYMENT_TARGET = 10.6;
    MACOSX_DEPLOYMENT_TARGET = 10.9;
    ONLY_ACTIVE_ARCH = YES;
    OTHER_LDFLAGS = ""-lSDL2"";
    PRODUCT_NAME = ""$(TARGET_NAME)"";
@@ -3378,7 +3378,7 @@
     /usr/local/lib,
     /opt/local/lib,
    );
    MACOSX_DEPLOYMENT_TARGET = 10.6;
    MACOSX_DEPLOYMENT_TARGET = 10.9;
    OTHER_LDFLAGS = ""-lSDL2"";
    PRODUCT_NAME = ""$(TARGET_NAME)"";
    SDKROOT = macosx;
22
src/bifs/script_dec.c
@@ -40,6 +40,7 @@ typedef struct
 GF_List *identifiers;
 char *new_line;
 u32 indent;
 u32 expr_stack_size;
} ScriptParser;


@@ -169,6 +170,7 @@ GF_Err SFScript_Parse(GF_BifsDecoder *codec, SFScript *script_field, GF_BitStrea
 e = GF_OK;
 if (gf_node_get_tag(n) != TAG_MPEG4_Script) return GF_NON_COMPLIANT_BITSTREAM;

 memset(&parser, 0, sizeof(ScriptParser));
 parser.codec = codec;
 parser.script = n;
 parser.bs = bs;
@@ -209,6 +211,10 @@ GF_Err SFScript_Parse(GF_BifsDecoder *codec, SFScript *script_field, GF_BitStrea
  SFS_Space(&parser);
  SFS_StatementBlock(&parser, GF_TRUE);
  SFS_Line(&parser);
  if (codec->LastError) {
   e = codec->LastError;
   goto exit;
  }
 }

 SFS_Line(&parser);
@@ -418,6 +424,7 @@ void SFS_CompoundExpression(ScriptParser *parser)
 if (parser->codec->LastError) return;
 SFS_Expression(parser);
 if (! gf_bs_read_int(parser->bs, 1)) return;
 if (parser->codec->LastError) return;
 SFS_AddString(parser, "","");
 SFS_CompoundExpression(parser);
}
@@ -430,12 +437,20 @@ void SFS_OptionalExpression(ScriptParser *parser)
 }
}


#define MAX_EXPR_STACK 500
void SFS_Expression(ScriptParser *parser)
{
 u32 val = gf_bs_read_int(parser->bs, NUMBITS_EXPR_TYPE);
 if (parser->codec->LastError) return;

 //limit max expression stack size
 parser->expr_stack_size++;
 if (parser->expr_stack_size>MAX_EXPR_STACK) {
  GF_LOG(GF_LOG_ERROR, GF_LOG_CODEC, (""[BIFS] Max stack size %d reached for expressions, not supported\n"", MAX_EXPR_STACK))
  parser->codec->LastError = GF_NON_COMPLIANT_BITSTREAM;
  return;
 }

 switch(val) {
 case ET_CURVED_EXPR:
  SFS_AddString(parser, ""("");
@@ -675,6 +690,7 @@ void SFS_Expression(ScriptParser *parser)
  parser->codec->LastError = GF_NON_COMPLIANT_BITSTREAM;
  break;
 }
 parser->expr_stack_size--;
}

void SFS_NewObject(ScriptParser *parser)
@@ -691,6 +707,7 @@ void SFS_ArrayDeref(ScriptParser *parser)
{
 if (parser->codec->LastError) return;
 SFS_Expression(parser);
 if (parser->codec->LastError) return;
 SFS_AddString(parser, ""["");
 SFS_CompoundExpression(parser);
 SFS_AddString(parser, ""]"");
@@ -709,6 +726,7 @@ void SFS_ObjectMemberAccess(ScriptParser *parser)
{
 if (parser->codec->LastError) return;
 SFS_Expression(parser);
 if (parser->codec->LastError) return;
 SFS_AddString(parser, ""."");
 SFS_Identifier(parser);
}
@@ -718,6 +736,7 @@ void SFS_ObjectMethodCall(ScriptParser *parser)
{
 if (parser->codec->LastError) return;
 SFS_Expression(parser);
 if (parser->codec->LastError) return;
 SFS_AddString(parser, ""."");
 SFS_Identifier(parser);
 SFS_AddString(parser, ""("");
@@ -732,6 +751,7 @@ void SFS_Params(ScriptParser *parser)
 val = gf_bs_read_int(parser->bs, 1);
 while (val) {
  SFS_Expression(parser);
  if (parser->codec->LastError) return;
  val = gf_bs_read_int(parser->bs, 1);
  if(val) SFS_AddString(parser, "","");
 }"
https://huntr.dev/bounties/f022fc50-3dfd-450a-ab47-3d75d2bf44c0/,Buffer Over Read in gf_utf8_wcslen in gpac/gpac,Buffer Over Read in function gf_utf8_wcslen at gpac/src/utils/utf.c:442 .,CVE-2022-3178,CWE-126: Buffer Over-read,https://www.github.com/gpac/gpac/commit/77510778516803b7f7402d7423c6d6bef50254c3,"@@ -12886,11 +12886,12 @@ GF_Err xtra_box_read(GF_Box *s, GF_BitStream *bs)
   prop_type = gf_bs_read_u16(bs);
   prop_size -= 6;
   ISOM_DECREASE_SIZE_NO_ERR(ptr, prop_size)
   //add 2 extra bytes for UTF16 case string dump
   data2 = gf_malloc(sizeof(char) * (prop_size+2));
   gf_bs_read_data(bs, data2, prop_size);
   data2[prop_size] = 0;
   data2[prop_size+1] = 0;

   tag_size-=prop_size;
  } else {
   prop_size = 0;

","5
src/isomedia/box_code_base.c
@@ -12886,11 +12886,12 @@ GF_Err xtra_box_read(GF_Box *s, GF_BitStream *bs)
   prop_type = gf_bs_read_u16(bs);
   prop_size -= 6;
   ISOM_DECREASE_SIZE_NO_ERR(ptr, prop_size)
   //add 2 extra bytes for UTF16 case string dump
   data2 = gf_malloc(sizeof(char) * (prop_size+2));
   //add 3 extra bytes for UTF16 case string dump (3 because we need 0-aligned short value)
   data2 = gf_malloc(sizeof(char) * (prop_size+3));
   gf_bs_read_data(bs, data2, prop_size);
   data2[prop_size] = 0;
   data2[prop_size+1] = 0;
   data2[prop_size+2] = 0;
   tag_size-=prop_size;
  } else {
   prop_size = 0;"
https://huntr.dev/bounties/4adb2417-9a7d-4167-bcd8-6f9674ad2590/,BufferOverflow in arnoldaldrin/binaries,"Buffer Overflow is most commonly found in languages such as C and C ++, where there is the need for prior definition of the memory size of the buffer to be used. The program calls a gets() function, which does not checks against overflowing the size assigned to buffer. As a result, it is possible to intentionally or unintentionally store more data in the buffer, which will cause a stack based overflow.",,CWE-121: Stack-based Buffer Overflow,https://www.github.com/arnoldaldrin/binaries/commit/be8e7c8bd11c0f2fefdbaba51d0509ed442297ee,"@@ -3,7 +3,8 @@ int main()
{
 int n,j,i;
 printf(""Enter the no. of processes:"");
 gets();

 int a[n],bt[n],tat[n],wt[n],ct[n],at[n];
 float awt,wts=0;
 printf(""enter burst time:"");

","3
FCFS.c
@@ -3,7 +3,8 @@ int main()
{
 int n,j,i;
 printf(""Enter the no. of processes:"");
 gets();
 printf(""enter no of proccess you want:"");
    scanf(""%d"",&n);
 int a[n],bt[n],tat[n],wt[n],ct[n],at[n];
 float awt,wts=0;
 printf(""enter burst time:"");"
https://huntr.dev/bounties/5a5092df-1699-4497-a8b2-38318bce0c4e/,Floating point exception in mruby/mruby,Floating point exception in udiv(),,CWE-1077: Floating Point Comparison with Incorrect Operator,https://www.github.com/mruby/mruby/commit/ef1974099deeb3df3f41026e02d6ac93cd4684ee,"@@ -1380,15 +1380,18 @@ mrb_bint_powm(mrb_state *mrb, mrb_value x, mrb_int exp, mrb_value mod)
  switch (mrb_type(mod)) {
  case MRB_TT_INTEGER:
    {


      struct RBigint *b2 = bint_new(mrb);
      struct RBigint *b3 = bint_new_int(mrb, mrb_integer(mod));
      mpz_powm(mrb, &b2->mp, &b->mp, exp, &b3->mp);
      return mrb_obj_value(b3);
    }
  case MRB_TT_BIGINT:
    {
      struct RBigint *b2 = bint_new(mrb);
      struct RBigint *b3 = RBIGINT(mod);

      mpz_powm(mrb, &b2->mp, &b->mp, exp, &b3->mp);
      return bint_norm(mrb, b3);
    }

","5
mrbgems/mruby-bigint/core/bigint.c
@@ -1380,15 +1380,18 @@ mrb_bint_powm(mrb_state *mrb, mrb_value x, mrb_int exp, mrb_value mod)
  switch (mrb_type(mod)) {
  case MRB_TT_INTEGER:
    {
      mrb_int m = mrb_integer(mod);
      if (m == 0) mrb_int_zerodiv(mrb);
      struct RBigint *b2 = bint_new(mrb);
      struct RBigint *b3 = bint_new_int(mrb, mrb_integer(mod));
      struct RBigint *b3 = bint_new_int(mrb, m);
      mpz_powm(mrb, &b2->mp, &b->mp, exp, &b3->mp);
      return mrb_obj_value(b3);
    }
  case MRB_TT_BIGINT:
    {
      struct RBigint *b2 = bint_new(mrb);
      struct RBigint *b3 = RBIGINT(mod);
      if (uzero(&b3->mp)) mrb_int_zerodiv(mrb);
      mpz_powm(mrb, &b2->mp, &b->mp, exp, &b3->mp);
      return bint_norm(mrb, b3);
    }"
https://huntr.dev/bounties/06c3a442-5fa6-45d1-8756-facaef718dca/,Global overflow in pppdump leads to RCE in ppp-project/ppp,"A global overflow vulnerability is present in the pppdump utility of the ppp repo which may lead to code execution. Specifically when the -p flag is given for enabling the pppmodeon the pppdump command, a malicious crafted pppdump file can trigger a global overflow which can be exploited to gain code execution.",,CWE-120: Classic Buffer Overflow,https://www.github.com/ppp-project/ppp/commit/a75fb7b198eed50d769c80c36629f38346882cbf,"@@ -297,6 +297,10 @@ dumpppp(f)
       printf(""%s aborted packet:\n     "", dir);
       q = ""    "";
   }




   nb = pkt->cnt;
   p = pkt->buf;
   pkt->cnt = 0;
@@ -400,7 +404,8 @@ dumpppp(f)
   c ^= 0x20;
   pkt->esc = 0;
      }
      pkt->buf[pkt->cnt++] = c;

      break;
  }
     }

","7
pppdump/pppdump.c
@@ -297,6 +297,10 @@ dumpppp(f)
       printf(""%s aborted packet:\n     "", dir);
       q = ""    "";
   }
   if (pkt->cnt >= sizeof(pkt->buf)) {
       printf(""%s over-long packet truncated:\n     "", dir);
       q = ""    "";
   }
   nb = pkt->cnt;
   p = pkt->buf;
   pkt->cnt = 0;
@@ -400,7 +404,8 @@ dumpppp(f)
   c ^= 0x20;
   pkt->esc = 0;
      }
      pkt->buf[pkt->cnt++] = c;
      if (pkt->cnt < sizeof(pkt->buf))
   pkt->buf[pkt->cnt++] = c;
      break;
  }
     }"
https://huntr.dev/bounties/1b055da5-7a9e-4409-99d7-030280d242d5/,Format string modifiers in card label in umlaeute/v4l2loopback,"When adding a new video device with v4l2loopback-ctl that contains a card label with format string modifiers the kernel driver interprets these when querying the device capabilities, thus leaking kernel memory (stack contents).",CVE-2022-2652,CWE-134: Use of Externally-Controlled Format String,https://www.github.com/umlaeute/v4l2loopback/commit/e4cd225557486c420f6a34411f98c575effd43dd,"@@ -756,7 +756,7 @@ static int vidioc_querycap(struct file *file, void *priv,
 __u32 capabilities = V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;

 strlcpy(cap->driver, ""v4l2 loopback"", sizeof(cap->driver));
 snprintf(cap->card, labellen, dev->card_label);
 snprintf(cap->bus_info, sizeof(cap->bus_info),
   ""platform:v4l2loopback-%03d"", device_nr);

@@ -2494,7 +2494,7 @@ static int v4l2_loopback_add(struct v4l2_loopback_config *conf, int *ret_nr)
 }

 MARK();
 snprintf(dev->vdev->name, sizeof(dev->vdev->name), dev->card_label);

 vdev_priv->device_nr = nr;


","4
v4l2loopback.c
@@ -756,7 +756,7 @@ static int vidioc_querycap(struct file *file, void *priv,
 __u32 capabilities = V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;

 strlcpy(cap->driver, ""v4l2 loopback"", sizeof(cap->driver));
 snprintf(cap->card, labellen, dev->card_label);
 snprintf(cap->card, labellen, ""%s"", dev->card_label);
 snprintf(cap->bus_info, sizeof(cap->bus_info),
   ""platform:v4l2loopback-%03d"", device_nr);

@@ -2494,7 +2494,7 @@ static int v4l2_loopback_add(struct v4l2_loopback_config *conf, int *ret_nr)
 }

 MARK();
 snprintf(dev->vdev->name, sizeof(dev->vdev->name), dev->card_label);
 snprintf(dev->vdev->name, sizeof(dev->vdev->name), ""%s"", dev->card_label);

 vdev_priv->device_nr = nr;"
https://huntr.dev/bounties/c93083dc-177c-4ba0-ba83-9d7fb29a5537/,Null Pointer Dereference Caused Segmentation Fault in gpac/gpac,Null pointer dereference caused segmentation fault. This can cause Denial-of -service attack.,CVE-2022-2549,CWE-476: NULL Pointer Dereference,https://www.github.com/gpac/gpac/commit/0102c5d4db7fdbf08b5b591b2a6264de33867a07,"@@ -785,7 +785,7 @@ static void gf_dump_vrml_simple_field(GF_SceneDumper *sdump, GF_FieldInfo field,
  } else {
   StartAttribute(sdump, ""value"");
  }
  for (i=0; i<mffield->count; i++) {
   if (i) gf_fprintf(sdump->trace, "" "");
   gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);
   /*this is to cope with single MFString which shall appear as SF in XMT*/
@@ -938,12 +938,10 @@ static void gf_dump_vrml_field(GF_SceneDumper *sdump, GF_Node *node, GF_FieldInf
  }

  if (!sdump->XMLDump) gf_fprintf(sdump->trace, ""["");
  if (mffield) {
   for (i=0; i<mffield->count; i++) {
    if (i) gf_fprintf(sdump->trace, "" "");
    gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);
    gf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, node);
   }
  }
  if (!sdump->XMLDump) gf_fprintf(sdump->trace, ""]"");

@@ -1150,7 +1148,7 @@ static void gf_dump_vrml_dyn_field(GF_SceneDumper *sdump, GF_Node *node, GF_Fiel
     sdump->indent--;
     DUMP_IND(sdump);
    } else {
     for (i=0; i<mffield->count; i++) {
      if (i) gf_fprintf(sdump->trace, "" "");
      if (field.fieldType != GF_SG_VRML_MFNODE) {
       gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);
@@ -1191,7 +1189,7 @@ static void gf_dump_vrml_dyn_field(GF_SceneDumper *sdump, GF_Node *node, GF_Fiel
     } else {
      gf_fprintf(sdump->trace, "" %s=\"""", GetXMTFieldTypeValueName(field.fieldType));
     }
     for (i=0; i<mffield->count; i++) {
      if (i) gf_fprintf(sdump->trace, "" "");
      if (field.fieldType != GF_SG_VRML_MFNODE) {
       gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);
@@ -1262,13 +1260,11 @@ static void gf_dump_vrml_proto_field(GF_SceneDumper *sdump, GF_Node *node, GF_Fi
    } else {
     gf_fprintf(sdump->trace, "" %s=\"""", GetXMTFieldTypeValueName(field.fieldType));
    }
    if (mffield) {
     for (i=0; i<mffield->count; i++) {
      if (i) gf_fprintf(sdump->trace, "" "");
      if (field.fieldType != GF_SG_VRML_MFNODE) {
       gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);
       gf_dump_vrml_sffield(sdump, sf_type, slot_ptr, (mffield->count>1) ? 1 : 0, node);
      }
     }
    }
    gf_fprintf(sdump->trace, ""\""/>\n"");

","28
src/scene_manager/scene_dump.c
@@ -785,7 +785,7 @@ static void gf_dump_vrml_simple_field(GF_SceneDumper *sdump, GF_FieldInfo field,
  } else {
   StartAttribute(sdump, ""value"");
  }
  for (i=0; i<mffield->count; i++) {
  for (i=0; mffield && (i<mffield->count); i++) {
   if (i) gf_fprintf(sdump->trace, "" "");
   gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);
   /*this is to cope with single MFString which shall appear as SF in XMT*/
@@ -938,12 +938,10 @@ static void gf_dump_vrml_field(GF_SceneDumper *sdump, GF_Node *node, GF_FieldInf
  }

  if (!sdump->XMLDump) gf_fprintf(sdump->trace, ""["");
  if (mffield) {
   for (i=0; i<mffield->count; i++) {
    if (i) gf_fprintf(sdump->trace, "" "");
    gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);
    gf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, node);
   }
  for (i=0; mffield && (i<mffield->count); i++) {
   if (i) gf_fprintf(sdump->trace, "" "");
   gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);
   gf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, node);
  }
  if (!sdump->XMLDump) gf_fprintf(sdump->trace, ""]"");

@@ -1150,7 +1148,7 @@ static void gf_dump_vrml_dyn_field(GF_SceneDumper *sdump, GF_Node *node, GF_Fiel
     sdump->indent--;
     DUMP_IND(sdump);
    } else {
     for (i=0; i<mffield->count; i++) {
     for (i=0; mffield && (i<mffield->count); i++) {
      if (i) gf_fprintf(sdump->trace, "" "");
      if (field.fieldType != GF_SG_VRML_MFNODE) {
       gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);
@@ -1191,7 +1189,7 @@ static void gf_dump_vrml_dyn_field(GF_SceneDumper *sdump, GF_Node *node, GF_Fiel
     } else {
      gf_fprintf(sdump->trace, "" %s=\"""", GetXMTFieldTypeValueName(field.fieldType));
     }
     for (i=0; i<mffield->count; i++) {
     for (i=0; mffield && (i<mffield->count); i++) {
      if (i) gf_fprintf(sdump->trace, "" "");
      if (field.fieldType != GF_SG_VRML_MFNODE) {
       gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);
@@ -1262,13 +1260,11 @@ static void gf_dump_vrml_proto_field(GF_SceneDumper *sdump, GF_Node *node, GF_Fi
    } else {
     gf_fprintf(sdump->trace, "" %s=\"""", GetXMTFieldTypeValueName(field.fieldType));
    }
    if (mffield) {
     for (i=0; i<mffield->count; i++) {
      if (i) gf_fprintf(sdump->trace, "" "");
      if (field.fieldType != GF_SG_VRML_MFNODE) {
       gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);
       gf_dump_vrml_sffield(sdump, sf_type, slot_ptr, (mffield->count>1) ? 1 : 0, node);
      }
    for (i=0; mffield && (i<mffield->count); i++) {
     if (i) gf_fprintf(sdump->trace, "" "");
     if (field.fieldType != GF_SG_VRML_MFNODE) {
      gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);
      gf_dump_vrml_sffield(sdump, sf_type, slot_ptr, (mffield->count>1) ? 1 : 0, node);
     }
    }
    gf_fprintf(sdump->trace, ""\""/>\n"");"
https://huntr.dev/bounties/c8c964de-046a-41b2-9ff5-e25cfdb36b5a/,Heap Use After Free in function Q_IsTypeOn in gpac/gpac,Heap Use After Free in function Q_IsTypeOn at src/bifs/unquantize.c:169,CVE-2022-2453,CWE-416: Use After Free,https://www.github.com/gpac/gpac/commit/dc7de8d3d604426c7a6e628d90cb9fb88e7b4c2c,"@@ -427,64 +427,71 @@ GF_Err BD_DecMFFieldVec(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node,
   e = gf_bifs_dec_sf_field(codec, bs, node, &sffield, GF_FALSE);
   if (e) return e;
  }
 } else {
  last = NULL;
  for (i=0; i<nbFields; i++) {
   GF_Node *new_node = gf_bifs_dec_node(codec, bs, field->NDTtype);
   if (new_node) {
    e = gf_node_register(new_node, is_mem_com ? NULL : node);
    if (e) return e;

    if (node) {
     /*special case for QP, register as the current QP*/
     if (gf_node_get_tag(new_node) == TAG_MPEG4_QuantizationParameter) {
      qp_local = ((M_QuantizationParameter *)new_node)->isLocal;
      /*we have a QP in the same scope, remove previous
      NB: we assume this is the right behavior, the spec doesn't say
      whether QP is cumulative or not*/
      if (qp_on) gf_bifs_dec_qp_remove(codec, GF_FALSE);

      e = gf_bifs_dec_qp_set(codec, new_node);
      if (e) return e;
      qp_on = 1;
      if (qp_local) qp_local = 2;
      if (codec->force_keep_qp) {
       e = gf_node_list_add_child_last(field->far_ptr, new_node, &last);
       if (e) return e;
      } else {
       gf_node_register(new_node, NULL);
       gf_node_unregister(new_node, node);
      }
     } else {










      e = gf_node_list_add_child_last(field->far_ptr, new_node, &last);
      if (e) return e;



     }



    }
    /*proto coding*/
    else if (codec->pCurrentProto) {
     /*TO DO: what happens if this is a QP node on the interface ?*/
     e = gf_node_list_add_child_last( (GF_ChildNodeItem **)field->far_ptr, new_node, &last);
     if (e) return e;
    }
   } else {
    return codec->LastError ? codec->LastError : GF_NON_COMPLIANT_BITSTREAM;
   }









  }
  /*according to the spec, the QP applies to the current node itself, not just children.
  If IsLocal is TRUE remove the node*/
  if (qp_on && qp_local) {
   if (qp_local == 2) {




//    qp_local = 1;
   } else {
    //ask to get rid of QP and reactivate if we had a QP when entering the node
    gf_bifs_dec_qp_remove(codec, initial_qp);
//    qp_local = 0;
   }
  }
 }

 /*finally delete the QP if any (local or not) as we get out of this node*/
 if (qp_on) gf_bifs_dec_qp_remove(codec, GF_TRUE);
 return GF_OK;
}



","99
src/bifs/field_decode.c
@@ -427,64 +427,71 @@ GF_Err BD_DecMFFieldVec(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node,
   e = gf_bifs_dec_sf_field(codec, bs, node, &sffield, GF_FALSE);
   if (e) return e;
  }
 } else {
  last = NULL;
  for (i=0; i<nbFields; i++) {
   GF_Node *new_node = gf_bifs_dec_node(codec, bs, field->NDTtype);
   if (new_node) {
    e = gf_node_register(new_node, is_mem_com ? NULL : node);
    if (e) return e;

    if (node) {
     /*special case for QP, register as the current QP*/
     if (gf_node_get_tag(new_node) == TAG_MPEG4_QuantizationParameter) {
      qp_local = ((M_QuantizationParameter *)new_node)->isLocal;
      /*we have a QP in the same scope, remove previous
      NB: we assume this is the right behavior, the spec doesn't say
      whether QP is cumulative or not*/
      if (qp_on) gf_bifs_dec_qp_remove(codec, GF_FALSE);
  return GF_OK;
 }

      e = gf_bifs_dec_qp_set(codec, new_node);
      if (e) return e;
      qp_on = 1;
      if (qp_local) qp_local = 2;
      if (codec->force_keep_qp) {
       e = gf_node_list_add_child_last(field->far_ptr, new_node, &last);
       if (e) return e;
      } else {
       gf_node_register(new_node, NULL);
       gf_node_unregister(new_node, node);
      }
     } else {
 e = GF_OK;
 last = NULL;
 for (i=0; i<nbFields; i++) {
  GF_Node *new_node = gf_bifs_dec_node(codec, bs, field->NDTtype);
  if (new_node) {
   e = gf_node_register(new_node, is_mem_com ? NULL : node);
   if (e) goto exit;

   if (node) {
    /*special case for QP, register as the current QP*/
    if (gf_node_get_tag(new_node) == TAG_MPEG4_QuantizationParameter) {
     qp_local = ((M_QuantizationParameter *)new_node)->isLocal;
     /*we have a QP in the same scope, remove previous
     NB: we assume this is the right behavior, the spec doesn't say
     whether QP is cumulative or not*/
     if (qp_on) gf_bifs_dec_qp_remove(codec, GF_FALSE);

     e = gf_bifs_dec_qp_set(codec, new_node);
     if (e) goto exit;
     qp_on = 1;
     if (qp_local) qp_local = 2;
     if (codec->force_keep_qp) {
      e = gf_node_list_add_child_last(field->far_ptr, new_node, &last);
      if (e) return e;
      if (e) goto exit;
     } else {
      gf_node_register(new_node, NULL);
      gf_node_unregister(new_node, node);
     }
    } else {
     e = gf_node_list_add_child_last(field->far_ptr, new_node, &last);
     if (e) goto exit;
    }
    /*proto coding*/
    else if (codec->pCurrentProto) {
     /*TO DO: what happens if this is a QP node on the interface ?*/
     e = gf_node_list_add_child_last( (GF_ChildNodeItem **)field->far_ptr, new_node, &last);
     if (e) return e;
    }
   } else {
    return codec->LastError ? codec->LastError : GF_NON_COMPLIANT_BITSTREAM;
   }
   /*proto coding*/
   else if (codec->pCurrentProto) {
    /*TO DO: what happens if this is a QP node on the interface ?*/
    e = gf_node_list_add_child_last( (GF_ChildNodeItem **)field->far_ptr, new_node, &last);
    if (e)goto exit;
   }
  } else {
   e = codec->LastError ? codec->LastError : GF_NON_COMPLIANT_BITSTREAM;
   goto exit;
  }
  /*according to the spec, the QP applies to the current node itself, not just children.
  If IsLocal is TRUE remove the node*/
  if (qp_on && qp_local) {
   if (qp_local == 2) {
 }

exit:

 /*according to the spec, the QP applies to the current node itself, not just children.
 If IsLocal is TRUE remove the node*/
 if (qp_on && qp_local) {
  if (qp_local == 2) {
//    qp_local = 1;
   } else {
    //ask to get rid of QP and reactivate if we had a QP when entering the node
    gf_bifs_dec_qp_remove(codec, initial_qp);
  } else {
   //ask to get rid of QP and reactivate if we had a QP when entering the node
   gf_bifs_dec_qp_remove(codec, initial_qp);
//    qp_local = 0;
   }
  }
 }

 /*finally delete the QP if any (local or not) as we get out of this node*/
 if (qp_on) gf_bifs_dec_qp_remove(codec, GF_TRUE);
 return GF_OK;
 return e;
}"
https://huntr.dev/bounties/105d40d0-46d7-461e-9f8e-20c4cdea925f/,Integer Overflow in function lsr_translate_coords in gpac/gpac,Integer Overflow in function lsr_translate_coords at laser/lsr_dec.c:853,CVE-2022-2454,CWE-190: Integer Overflow or Wraparound,https://www.github.com/gpac/gpac/commit/faa75edde3dfeba1e2cf6ffa48e45a50f1042096,"@@ -838,6 +838,8 @@ static void lsr_read_id(GF_LASeRCodec *lsr, GF_Node *n)

static Fixed lsr_translate_coords(GF_LASeRCodec *lsr, u32 val, u32 nb_bits)
{


#ifdef GPAC_FIXED_POINT
 if (val >> (nb_bits-1) ) {
  s32 neg = (s32) val - (1<<nb_bits);

","2
src/laser/lsr_dec.c
@@ -838,6 +838,8 @@ static void lsr_read_id(GF_LASeRCodec *lsr, GF_Node *n)

static Fixed lsr_translate_coords(GF_LASeRCodec *lsr, u32 val, u32 nb_bits)
{
 if (!nb_bits) return 0;

#ifdef GPAC_FIXED_POINT
 if (val >> (nb_bits-1) ) {
  s32 neg = (s32) val - (1<<nb_bits);"
https://huntr.dev/bounties/007a7784-c211-4847-9cc3-aec38e7d5157/,heap-buffer-overflow in dex_parse in virustotal/yara,There exists a heap based out of bounds read vulnerability in dex_parse,,CWE-122: Heap-based Buffer Overflow,https://www.github.com/virustotal/yara/commit/599481b9494ff9fa298ab26fa5e1cd50d70a871d,"@@ -619,7 +619,7 @@ uint32_t load_encoded_field(
  {
#ifdef DEBUG_DEX_MODULE
    printf(
        ""[DEX]\tFIELD_NAME %s NAME_IDX 0x%x\n"", field_name->c_string, name_idx);
#endif

    set_sized_string(
@@ -643,7 +643,7 @@ uint32_t load_encoded_field(
  {
#ifdef DEBUG_DEX_MODULE
    printf(
        ""[DEX]\tCLASS_NAME %s CLASS_IDX 0x%x DESCRIPTOR_IDX 0x%x\n"",
        class_name->c_string,
        class_idx,
        descriptor_idx);
@@ -748,7 +748,7 @@ uint32_t load_encoded_method(
    return 0;

#ifdef DEBUG_DEX_MODULE
  printf(""[DEX]\tNAME_IDX 0x%x\n"", name_idx);
#endif

#ifdef DEBUG_DEX_MODULE
@@ -768,7 +768,7 @@ uint32_t load_encoded_method(
  {
#ifdef DEBUG_DEX_MODULE
    printf(
        ""[DEX]\tMETHOD_NAME %s NAME_IDX 0x%x\n"",
        method_name->c_string,
        name_idx);
#endif
@@ -794,7 +794,7 @@ uint32_t load_encoded_method(
  {
#ifdef DEBUG_DEX_MODULE
    printf(
        ""[DEX]\tCLASS_NAME %s CLASS_IDX 0x%x DESCRIPTOR_IDX:0x%x\n"",
        class_name->c_string,
        class_idx,
        descriptor_idx);
@@ -821,7 +821,7 @@ uint32_t load_encoded_method(
  {
#ifdef DEBUG_DEX_MODULE
    printf(
        ""[DEX]\tPROTO_NAME %s CLASS_IDX 0x%x DESCRIPTOR_IDX:0x%x\n"",
        proto_name->c_string,
        class_idx,
        descriptor_idx);
@@ -842,7 +842,7 @@ uint32_t load_encoded_method(
#endif

    if (struct_fits_in_dex(
            dex, dex->data + encoded_method.code_off, sizeof(code_item_t)))
    {
      code_item_t* code_item =
          (code_item_t*) (dex->data + encoded_method.code_off);
@@ -954,7 +954,7 @@ void dex_parse(DEX* dex, uint64_t base_address)

    if (!fits_in_dex(
            dex,
            dex->data + yr_le32toh(string_id_item->string_data_offset),
            value))
      continue;

@@ -967,8 +967,8 @@ void dex_parse(DEX* dex, uint64_t base_address)
    set_integer(value, dex->object, ""string_ids[%i].size"", i);

    set_sized_string(
        (const char*) ((
            dex->data + yr_le32toh(string_id_item->string_data_offset) + 1)),
        value,
        dex->object,
        ""string_ids[%i].value"",
@@ -1124,6 +1124,9 @@ void dex_parse(DEX* dex, uint64_t base_address)
      map_item_t* map_item =
          (map_item_t*) (dex->data + yr_le32toh(dex_header->map_offset) + sizeof(uint32_t) + i * sizeof(map_item_t));




      set_integer(
          yr_le16toh(map_item->type),
          dex->object,

","23
libyara/modules/dex/dex.c
@@ -619,7 +619,7 @@ uint32_t load_encoded_field(
  {
#ifdef DEBUG_DEX_MODULE
    printf(
        ""[DEX]\tFIELD_NAME %s NAME_IDX 0x%x\n"", field_name->c_string, name_idx);
        ""[DEX]\tFIELD_NAME %s NAME_IDX 0x%llx\n"", field_name->c_string, name_idx);
#endif

    set_sized_string(
@@ -643,7 +643,7 @@ uint32_t load_encoded_field(
  {
#ifdef DEBUG_DEX_MODULE
    printf(
        ""[DEX]\tCLASS_NAME %s CLASS_IDX 0x%x DESCRIPTOR_IDX 0x%x\n"",
        ""[DEX]\tCLASS_NAME %s CLASS_IDX 0x%llx DESCRIPTOR_IDX 0x%llx\n"",
        class_name->c_string,
        class_idx,
        descriptor_idx);
@@ -748,7 +748,7 @@ uint32_t load_encoded_method(
    return 0;

#ifdef DEBUG_DEX_MODULE
  printf(""[DEX]\tNAME_IDX 0x%x\n"", name_idx);
  printf(""[DEX]\tNAME_IDX 0x%llx\n"", name_idx);
#endif

#ifdef DEBUG_DEX_MODULE
@@ -768,7 +768,7 @@ uint32_t load_encoded_method(
  {
#ifdef DEBUG_DEX_MODULE
    printf(
        ""[DEX]\tMETHOD_NAME %s NAME_IDX 0x%x\n"",
        ""[DEX]\tMETHOD_NAME %s NAME_IDX 0x%llx\n"",
        method_name->c_string,
        name_idx);
#endif
@@ -794,7 +794,7 @@ uint32_t load_encoded_method(
  {
#ifdef DEBUG_DEX_MODULE
    printf(
        ""[DEX]\tCLASS_NAME %s CLASS_IDX 0x%x DESCRIPTOR_IDX:0x%x\n"",
        ""[DEX]\tCLASS_NAME %s CLASS_IDX 0x%llx DESCRIPTOR_IDX:0x%llx\n"",
        class_name->c_string,
        class_idx,
        descriptor_idx);
@@ -821,7 +821,7 @@ uint32_t load_encoded_method(
  {
#ifdef DEBUG_DEX_MODULE
    printf(
        ""[DEX]\tPROTO_NAME %s CLASS_IDX 0x%x DESCRIPTOR_IDX:0x%x\n"",
        ""[DEX]\tPROTO_NAME %s CLASS_IDX 0x%llx DESCRIPTOR_IDX:0x%llx\n"",
        proto_name->c_string,
        class_idx,
        descriptor_idx);
@@ -842,7 +842,7 @@ uint32_t load_encoded_method(
#endif

    if (struct_fits_in_dex(
            dex, dex->data + encoded_method.code_off, sizeof(code_item_t)))
            dex, dex->data + encoded_method.code_off, code_item_t))
    {
      code_item_t* code_item =
          (code_item_t*) (dex->data + encoded_method.code_off);
@@ -954,7 +954,7 @@ void dex_parse(DEX* dex, uint64_t base_address)

    if (!fits_in_dex(
            dex,
            dex->data + yr_le32toh(string_id_item->string_data_offset),
            dex->data + yr_le32toh(string_id_item->string_data_offset) + 1,
            value))
      continue;

@@ -967,8 +967,8 @@ void dex_parse(DEX* dex, uint64_t base_address)
    set_integer(value, dex->object, ""string_ids[%i].size"", i);

    set_sized_string(
        (const char*) ((
            dex->data + yr_le32toh(string_id_item->string_data_offset) + 1)),
        (const char*) (
            dex->data + yr_le32toh(string_id_item->string_data_offset) + 1),
        value,
        dex->object,
        ""string_ids[%i].value"",
@@ -1124,6 +1124,9 @@ void dex_parse(DEX* dex, uint64_t base_address)
      map_item_t* map_item =
          (map_item_t*) (dex->data + yr_le32toh(dex_header->map_offset) + sizeof(uint32_t) + i * sizeof(map_item_t));

      if (!struct_fits_in_dex(dex, map_item, map_item_t))
        return;

      set_integer(
          yr_le16toh(map_item->type),
          dex->object,"
https://huntr.dev/bounties/d4db0a12-184a-429b-8f76-a3cf8ae07dc3/,NDIS Packet Buffer Overflow Due To Allocation/Copy Inconsistencies in luigirizzo/netmap,"Reading driver source code is a challenge because despite things appearing to be a vulnerability, there might be a single overlooked comment in MSDN's documentation for an obscure function that ensures that something isn't a vulnerability - in light of this challenge, I'm going to walk through my reasoning for thinking that there is a buffer-overflow vulnerability here.",,CWE-122: Heap-based Buffer Overflow,https://www.github.com/luigirizzo/netmap/commit/b6e9313b2aea64d279222e959b4f326a389baef7,"@@ -153,7 +153,9 @@ command above. The new drivers will then be called `e1000e-netmap`,
### Windows

Netmap has been ported to Windows in summer 2015 by Alessio Faina as part of
his Master thesis. Please look [here](WINDOWS/README.txt) for details.



## Applications


@@ -1,6 +1,7 @@
**************************************************************
DISCLAIMER: This documentation is currently outdated.
            It is going to be updated soon.

**************************************************************

This directory contains the Windows version of netmap, developed by

","4
README.md
@@ -153,7 +153,9 @@ command above. The new drivers will then be called `e1000e-netmap`,
### Windows

Netmap has been ported to Windows in summer 2015 by Alessio Faina as part of
his Master thesis. Please look [here](WINDOWS/README.txt) for details.
his Master thesis. You may take a look [here](WINDOWS/README.txt) for details,
but please be aware that the port has been left behind for years, and is
currently unmantained.

## Applications

5
WINDOWS/README.txt
@@ -1,6 +1,7 @@
**************************************************************
DISCLAIMER: This documentation is currently outdated.
            It is going to be updated soon.
DISCLAIMER: The Windows port of netmap is currently unmantained.  Not even
compilation is guaranteed.  Moreover, it is know to contain security-critcal
bugs.
**************************************************************

This directory contains the Windows version of netmap, developed by"
https://huntr.dev/bounties/c4eaa24d-a7e8-4ec8-bb9b-49d17d7c782f/,buffer size confusion in vastrock-huang/minivpn,"an attempt to write 2000 into a buffer of 10 bytes, while SSL_read does not add a zero at the end.",,CWE-120: Classic Buffer Overflow,https://www.github.com/vastrock-huang/minivpn/commit/9acc42de417c86e3f360762649277fc885c576f3,"@@ -295,8 +295,8 @@ void selectTunnel(SSL* ssl, int sockfd, int tunfd) {










@@ -350,4 +350,4 @@ int main(int argc, char *argv[]) {





","6
client.c
@@ -295,8 +295,8 @@ void selectTunnel(SSL* ssl, int sockfd, int tunfd) {

//获取服务端分配的虚拟IP
int recvVirtualIP(SSL* ssl) {
    char buf[10];
    SSL_read(ssl,buf,BUFF_SIZE);
    char buf[10] = {0};
    SSL_read(ssl,buf,9);
    int virtualIP = atoi(buf);
    printf(""virtualIP: 192.168.53.%d/24\n"",virtualIP);
    return virtualIP;
@@ -350,4 +350,4 @@ int main(int argc, char *argv[]) {
    SSL_free(ssl);
    close(sockfd);
    return 0;
}
}"
https://huntr.dev/bounties/365ab61f-9a63-421c-97e6-21d4653021f0/,chafa <= 4bac1466 is vulnerable to an out of bounds read vulnerability. in hpjansson/chafa,Building,CVE-2022-2061,CWE-122: Heap-based Buffer Overflow,https://www.github.com/hpjansson/chafa/commit/e6ce3746cdcf0836b9dae659a5aed15d73a080d8,"@@ -329,6 +329,10 @@ lzw_result lzw_decode(struct lzw_ctx *ctx,
  /* Code is invalid */
  return LZW_BAD_CODE;





 } else if (code_new < current_entry) {
  /* Code is in table */
  code_out = code_new;

","4
libnsgif/lzw.c
@@ -329,6 +329,10 @@ lzw_result lzw_decode(struct lzw_ctx *ctx,
  /* Code is invalid */
  return LZW_BAD_CODE;

 } else if (code_new >= 1 << LZW_CODE_MAX) {
  /* Don't access out of bound */
  return LZW_BAD_CODE;

 } else if (code_new < current_entry) {
  /* Code is in table */
  code_out = code_new;"
https://huntr.dev/bounties/cc0057f4-6055-444b-bba6-bbecde98f59b/,Null pointer dereference at chafa-pixops.c:95 in hpjansson/chafa,Null pointer dereference in hpjansson/chafa at chafa-pixops.c:95.,,CWE-476: NULL Pointer Dereference,https://www.github.com/hpjansson/chafa/commit/3497f451c37f99925328009e3fcbfaaaa16ae0be,"@@ -82,7 +82,12 @@ chafa_process_batches (gpointer ctx, GFunc batch_func, GFunc post_func, gint n_r
        }

        if (row_ofs [0] >= row_ofs [1])




            break;


        batch = &batches [i++];
        batch->first_row = row_ofs [0];

","5
chafa/internal/chafa-batch.c
@@ -82,7 +82,12 @@ chafa_process_batches (gpointer ctx, GFunc batch_func, GFunc post_func, gint n_r
        }

        if (row_ofs [0] >= row_ofs [1])
        {
            /* Save the number of batches actually produced to use in
             * post_func loop later. */
            n_batches = i;
            break;
        }

        batch = &batches [i++];
        batch->first_row = row_ofs [0];"
https://huntr.dev/bounties/ceb6ad0f-37ed-4ae9-98d0-ee7b32d41921/,"classic overflow on the stack, with the ability to intercept control. in lurcher/unixodbc","if arguments longer than 1024 were passed to program iusql, we get a classic stack overflow.",,CWE-120: Classic Buffer Overflow,https://www.github.com/lurcher/unixodbc/commit/c6c5471266c1641e2a4d47f1f5819009e10f8439,"@@ -2400,10 +2400,15 @@ int __connect_part_two( DMHDBC connection )
#endif
            if ( !(connection -> cl_handle = odbc_dlopen( name, &err )))
            {
                char txt[ 256 ];





                sprintf( txt, ""Can't open cursor lib '%s' : %s"", 
                    name, err ? err : ""NULL ERROR RETURN"" );


                dm_log_write( __FILE__,
                        __LINE__,

@@ -355,7 +355,7 @@ static int OpenDatabase( SQLHENV *phEnv, SQLHDBC *phDbc, char *szDSN, char *szUI
{
    SQLCHAR dsn[ 1024 ], uid[ 1024 ], pwd[ 1024 ];
    SQLTCHAR cstr[ 1024 ];
    char zcstr[ 1024 ], tmp[ 1024 ];
    int i;
    size_t zclen;

@@ -376,7 +376,7 @@ static int OpenDatabase( SQLHENV *phEnv, SQLHDBC *phDbc, char *szDSN, char *szUI
    if ( szDSN )
    {
        size_t DSNlen=strlen( szDSN );
        for ( i = 0; i < DSNlen; i ++ )
        {
            dsn[ i ] = szDSN[ i ];
        }
@@ -390,7 +390,7 @@ static int OpenDatabase( SQLHENV *phEnv, SQLHDBC *phDbc, char *szDSN, char *szUI
    if ( szUID )
    {
        size_t UIDlen=strlen( szUID );
        for ( i = 0; i < UIDlen; i ++ )
        {
            uid[ i ] = szUID[ i ];
        }
@@ -404,7 +404,7 @@ static int OpenDatabase( SQLHENV *phEnv, SQLHDBC *phDbc, char *szDSN, char *szUI
    if ( szPWD )
    {
        size_t PWDlen=strlen( szPWD );
        for ( i = 0; i < PWDlen; i ++ )
        {
            pwd[ i ] = szPWD[ i ];
        }

","7
DriverManager/SQLConnect.c
@@ -2400,10 +2400,15 @@ int __connect_part_two( DMHDBC connection )
#endif
            if ( !(connection -> cl_handle = odbc_dlopen( name, &err )))
            {
                char txt[ 256 ];
                char txt[ 1024 ];

#ifdef HAVE_SNPRINTF
                snprintf( txt, sizeof( txt ), ""Can't open cursor lib '%s' : %s"", 
                    name, err ? err : ""NULL ERROR RETURN"" );
#else
                sprintf( txt, ""Can't open cursor lib '%s' : %s"", 
                    name, err ? err : ""NULL ERROR RETURN"" );
#endif

                dm_log_write( __FILE__,
                        __LINE__,
8
exe/iusql.c
@@ -355,7 +355,7 @@ static int OpenDatabase( SQLHENV *phEnv, SQLHDBC *phDbc, char *szDSN, char *szUI
{
    SQLCHAR dsn[ 1024 ], uid[ 1024 ], pwd[ 1024 ];
    SQLTCHAR cstr[ 1024 ];
    char zcstr[ 1024 ], tmp[ 1024 ];
    char zcstr[ 1024 * 2 ], tmp[ 1024 * 8 ];
    int i;
    size_t zclen;

@@ -376,7 +376,7 @@ static int OpenDatabase( SQLHENV *phEnv, SQLHDBC *phDbc, char *szDSN, char *szUI
    if ( szDSN )
    {
        size_t DSNlen=strlen( szDSN );
        for ( i = 0; i < DSNlen; i ++ )
        for ( i = 0; i < DSNlen && i < sizeof( dsn ) - 1; i ++ )
        {
            dsn[ i ] = szDSN[ i ];
        }
@@ -390,7 +390,7 @@ static int OpenDatabase( SQLHENV *phEnv, SQLHDBC *phDbc, char *szDSN, char *szUI
    if ( szUID )
    {
        size_t UIDlen=strlen( szUID );
        for ( i = 0; i < UIDlen; i ++ )
        for ( i = 0; i < UIDlen && i < sizeof( uid ) - 1; i ++ )
        {
            uid[ i ] = szUID[ i ];
        }
@@ -404,7 +404,7 @@ static int OpenDatabase( SQLHENV *phEnv, SQLHDBC *phDbc, char *szDSN, char *szUI
    if ( szPWD )
    {
        size_t PWDlen=strlen( szPWD );
        for ( i = 0; i < PWDlen; i ++ )
        for ( i = 0; i < PWDlen && i < sizeof( pwd ) - 1; i ++ )
        {
            pwd[ i ] = szPWD[ i ];
        }"
https://huntr.dev/bounties/99e6df06-b9f7-4c53-a722-6bb89fbfb51f/,Use-After-Free in function hash_new_from_values in mruby/mruby,Use-After-Free in function hash_new_from_values at vm.c:1167,CVE-2022-1934,CWE-416: Use After Free,https://www.github.com/mruby/mruby/commit/aa7f98dedb68d735a1665d3a289036c88b0c47ce,"@@ -1159,18 +1159,20 @@ check_target_class(mrb_state *mrb)
  return target;
}



static mrb_value
hash_new_from_values(mrb_state *mrb, mrb_int argc, mrb_value *regs)
{
  mrb_value hash = mrb_hash_new_capa(mrb, argc);
  while (argc--) {
    mrb_hash_set(mrb, hash, regs[0], regs[1]);
    regs += 2;
  }
  return hash;
}

#define ARGUMENT_NORMALIZE(arg_base, arg_info, insn) do { \
  int n = *(arg_info)&0xf; \
  int nk = (*(arg_info)>>4)&0xf; \
  mrb_int bidx = (arg_base) + mrb_bidx(*(arg_info)); \
@@ -1179,7 +1181,7 @@ hash_new_from_values(mrb_state *mrb, mrb_int argc, mrb_value *regs)
  } \
  else if (nk > 0) {  /* pack keyword arguments */ \
    mrb_int kidx = (arg_base)+(n==CALL_MAXARGS?1:n)+1; \
    mrb_value kdict = hash_new_from_values(mrb, nk, regs+kidx); \
    regs[kidx] = kdict; \
    nk = CALL_MAXARGS; \
    *(arg_info) = n | (nk<<4); \
@@ -1242,7 +1244,6 @@ mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)
  mrb->jmp = &c_jmp;
  mrb_vm_ci_proc_set(mrb->c->ci, proc);

#define regs (mrb->c->ci->stack)
  INIT_DISPATCH {
    CASE(OP_NOP, Z) {
      /* do nothing */

","13
src/vm.c
@@ -1159,18 +1159,20 @@ check_target_class(mrb_state *mrb)
  return target;
}

#define regs (mrb->c->ci->stack)

static mrb_value
hash_new_from_values(mrb_state *mrb, mrb_int argc, mrb_value *regs)
hash_new_from_regs(mrb_state *mrb, mrb_int argc, mrb_int idx)
{
  mrb_value hash = mrb_hash_new_capa(mrb, argc);
  while (argc--) {
    mrb_hash_set(mrb, hash, regs[0], regs[1]);
    regs += 2;
    mrb_hash_set(mrb, hash, regs[idx+0], regs[idx+1]);
    idx += 2;
  }
  return hash;
}

#define ARGUMENT_NORMALIZE(arg_base, arg_info, insn) do { \
#define ARGUMENT_NORMALIZE(arg_base, arg_info, insn) do {       \
  int n = *(arg_info)&0xf; \
  int nk = (*(arg_info)>>4)&0xf; \
  mrb_int bidx = (arg_base) + mrb_bidx(*(arg_info)); \
@@ -1179,7 +1181,7 @@ hash_new_from_values(mrb_state *mrb, mrb_int argc, mrb_value *regs)
  } \
  else if (nk > 0) {  /* pack keyword arguments */ \
    mrb_int kidx = (arg_base)+(n==CALL_MAXARGS?1:n)+1; \
    mrb_value kdict = hash_new_from_values(mrb, nk, regs+kidx); \
    mrb_value kdict = hash_new_from_regs(mrb, nk, kidx); \
    regs[kidx] = kdict; \
    nk = CALL_MAXARGS; \
    *(arg_info) = n | (nk<<4); \
@@ -1242,7 +1244,6 @@ mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)
  mrb->jmp = &c_jmp;
  mrb_vm_ci_proc_set(mrb->c->ci, proc);

#define regs (mrb->c->ci->stack)
  INIT_DISPATCH {
    CASE(OP_NOP, Z) {
      /* do nothing */"
https://huntr.dev/bounties/ee2a4d67-0a2f-417a-9b21-00726b4c2869/,Null pointer dereference in index.c in bfabiszewski/libmobi,Null pointer dereference in bfabiszewski/libmobi at index.c:1076.,,CWE-476: NULL Pointer Dereference,https://www.github.com/bfabiszewski/libmobi/commit/1e4924565689f893a1d3517cc78781a9499c4397,"@@ -1,3 +1,4 @@

2022-05-23: Fix index entries count
2022-05-23: Prevent leak of index entries on corrupt data
2022-05-23: Add checks for fragments part in case of corrupt data

@@ -1019,14 +1019,14 @@ MOBI_RET mobi_decode_infl(unsigned char *decoded, int *decoded_size, const unsig
 Matches are made agains reversed string and all its substrings
 
 @param[in,out] infl_strings Array of returned strings
 @param[in,out] root Root node of the tree
 @param[in,out] string Index entry number
 @return Number of returned strings
 */
size_t mobi_trie_get_inflgroups(char **infl_strings, MOBITrie * const root, const char *string) {
    /* travers trie and get values for each substring */
    if (root == NULL) {
        return MOBI_PARAM_ERR;
    }
    size_t count = 0;
    size_t length = strlen(string);
@@ -1060,11 +1060,14 @@ size_t mobi_trie_get_inflgroups(char **infl_strings, MOBITrie * const root, cons
 @brief Insert inversed inlection string for given entry into trie structure
 
 @param[in,out] root Root node of the tree, created if NULL
 @param[in,out] indx MOBIIndx infl index records
 @param[in,out] i Index entry number
 @return MOBI_RET status code (on success MOBI_SUCCESS)
 */
MOBI_RET mobi_trie_insert_infl(MOBITrie **root, const MOBIIndx *indx, size_t i) {



    MOBIIndexEntry e = indx->entries[i];
    char *inflected = e.label;
    for (size_t j = 0; j < e.tags_count; j++) {

","1
ChangeLog
@@ -1,3 +1,4 @@
2022-05-27: Fix potential null pointer dereference on corrupt input when inflections CNCX record is not initialized
2022-05-23: Fix index entries count
2022-05-23: Prevent leak of index entries on corrupt data
2022-05-23: Add checks for fragments part in case of corrupt data
13
src/index.c
@@ -1019,14 +1019,14 @@ MOBI_RET mobi_decode_infl(unsigned char *decoded, int *decoded_size, const unsig
 Matches are made agains reversed string and all its substrings
   @param[in,out] infl_strings Array of returned strings
 @param[in,out] root Root node of the tree
 @param[in,out] string Index entry number
 @param[in] root Root node of the tree
 @param[in] string Index entry number
 @return Number of returned strings
 */
size_t mobi_trie_get_inflgroups(char **infl_strings, MOBITrie * const root, const char *string) {
    /* travers trie and get values for each substring */
    if (root == NULL) {
        return MOBI_PARAM_ERR;
        return 0;
    }
    size_t count = 0;
    size_t length = strlen(string);
@@ -1060,11 +1060,14 @@ size_t mobi_trie_get_inflgroups(char **infl_strings, MOBITrie * const root, cons
 @brief Insert inversed inlection string for given entry into trie structure
   @param[in,out] root Root node of the tree, created if NULL
 @param[in,out] indx MOBIIndx infl index records
 @param[in,out] i Index entry number
 @param[in] indx MOBIIndx infl index records
 @param[in] i Index entry number
 @return MOBI_RET status code (on success MOBI_SUCCESS)
 */
MOBI_RET mobi_trie_insert_infl(MOBITrie **root, const MOBIIndx *indx, size_t i) {
    if (indx->cncx_record == NULL) {
        return MOBI_DATA_CORRUPT;
    }
    MOBIIndexEntry e = indx->entries[i];
    char *inflected = e.label;
    for (size_t j = 0; j < e.tags_count; j++) {"
https://huntr.dev/bounties/8a3dc5cb-08b3-4807-82b2-77f08c137a04/,Out of Bounds Read in string_scan_range in radareorg/radare2,"When providing crafted input, an attacker can cause r_read_32 within string_scan_range to do an out of bounds read. This causes a segmentation fault, but could also potentially enable information disclosure.",CVE-2022-1899,CWE-125: Out-of-bounds Read,https://www.github.com/radareorg/radare2/commit/193f4fe01d7f626e2ea937450f2e0c4604420e9d,"@@ -178,27 +178,27 @@ static int string_scan_range(RList *list, RBinFile *bf, int min,
 free (charset);
 RConsIsBreaked is_breaked = (bin && bin->consb.is_breaked)? bin->consb.is_breaked: NULL;
 // may oobread
 while (needle < to) {
  if (is_breaked && is_breaked ()) {
   break;
  }
  // smol optimization
  if (needle + 4 < to) {
   ut32 n1 = r_read_le32 (buf + needle - from);
   if (!n1) {
    needle += 4;
    continue;
   }
  }
  rc = r_utf8_decode (buf + needle - from, to - needle, NULL);
  if (!rc) {
   needle++;
   continue;
  }
  bool addr_aligned = !(needle % 4);

  if (type == R_STRING_TYPE_DETECT) {
   char *w = (char *)buf + needle + rc - from;
   if (((to - needle) > 8 + rc)) {
    // TODO: support le and be
    bool is_wide32le = (needle + rc + 2 < to) && (!w[0] && !w[1] && !w[2] && w[3] && !w[4]);
@@ -248,7 +248,7 @@ static int string_scan_range(RList *list, RBinFile *bf, int min,
     rc = 2;
    }
   } else {
    rc = r_utf8_decode (buf + needle - from, to - needle, &r);
    if (rc > 1) {
     str_type = R_STRING_TYPE_UTF8;
    }

","12
libr/bin/bfile.c
@@ -178,27 +178,27 @@ static int string_scan_range(RList *list, RBinFile *bf, int min,
 free (charset);
 RConsIsBreaked is_breaked = (bin && bin->consb.is_breaked)? bin->consb.is_breaked: NULL;
 // may oobread
 while (needle < to) {
 while (needle < to && needle < UT64_MAX - 4) {
  if (is_breaked && is_breaked ()) {
   break;
  }
  // smol optimization
  if (needle + 4 < to) {
   ut32 n1 = r_read_le32 (buf + needle - from);
  if (needle < to - 4) {
   ut32 n1 = r_read_le32 (buf + (needle - from));
   if (!n1) {
    needle += 4;
    continue;
   }
  }
  rc = r_utf8_decode (buf + needle - from, to - needle, NULL);
  rc = r_utf8_decode (buf + (needle - from), to - needle, NULL);
  if (!rc) {
   needle++;
   continue;
  }
  bool addr_aligned = !(needle % 4);

  if (type == R_STRING_TYPE_DETECT) {
   char *w = (char *)buf + needle + rc - from;
   char *w = (char *)buf + (needle + rc - from);
   if (((to - needle) > 8 + rc)) {
    // TODO: support le and be
    bool is_wide32le = (needle + rc + 2 < to) && (!w[0] && !w[1] && !w[2] && w[3] && !w[4]);
@@ -248,7 +248,7 @@ static int string_scan_range(RList *list, RBinFile *bf, int min,
     rc = 2;
    }
   } else {
    rc = r_utf8_decode (buf + needle - from, to - needle, &r);
    rc = r_utf8_decode (buf + (needle - from), to - needle, &r);
    if (rc > 1) {
     str_type = R_STRING_TYPE_UTF8;
    }"
https://huntr.dev/bounties/0730a95e-c485-4ff2-9a5d-bb3abfda0b17/,Use of Uninitialized Function Pointer in radareorg/radare2,"When providing a crafted input binary to radare2, the context->read_addr function pointer is never initialized before use. This is due to the switch statement responsible for the assignment not finding a matching value for its switch cases.",CVE-2022-1809,CWE-824: Access of Uninitialized Pointer,https://www.github.com/radareorg/radare2/commit/919e3ac1a13f753c73e7a8e8d8bb4a143218732d,"@@ -58,6 +58,8 @@ R_API bool r_anal_vtable_begin(RAnal *anal, RVTableContext *context) {
  context->read_addr = be? vtable_read_addr_be64 : vtable_read_addr_le64;
  break;
 default:


  return false;
 }
 return true;
@@ -72,7 +74,7 @@ static bool vtable_addr_in_text_section(RVTableContext *context, ut64 curAddress

static bool vtable_is_value_in_text_section(RVTableContext *context, ut64 curAddress, ut64 *value) {
 //value at the current address
 ut64 curAddressValue;
 if (!context->read_addr (context->anal, curAddress, &curAddressValue)) {
  return false;
 }
@@ -132,6 +134,7 @@ static bool vtable_is_addr_vtable_start_itanium(RVTableContext *context, RBinSec
}

static bool vtable_is_addr_vtable_start_msvc(RVTableContext *context, ut64 curAddress) {

 RAnalRef *xref;
 RListIter *xrefIter;

@@ -150,19 +153,14 @@ static bool vtable_is_addr_vtable_start_msvc(RVTableContext *context, ut64 curAd
 r_list_foreach (xrefs, xrefIter, xref) {
  // section in which currenct xref lies
  if (vtable_addr_in_text_section (context, xref->addr)) {
   ut8 buf[VTABLE_BUFF_SIZE];
   context->anal->iob.read_at (context->anal->iob.io, xref->addr, buf, sizeof(buf));

   RAnalOp analop = {0};
   r_anal_op (context->anal, &analop, xref->addr, buf, sizeof(buf), R_ANAL_OP_MASK_BASIC);

   if (analop.type == R_ANAL_OP_TYPE_MOV
    || analop.type == R_ANAL_OP_TYPE_LEA) {
    r_list_free (xrefs);
    r_anal_op_fini (&analop);
    return true;
   }

   r_anal_op_fini (&analop);
  }
 }
@@ -286,7 +284,7 @@ R_API RList *r_anal_vtable_search(RVTableContext *context) {
}

R_API void r_anal_list_vtables(RAnal *anal, int rad) {
 RVTableContext context;
 r_anal_vtable_begin (anal, &context);

 const char *noMethodName = ""No Name found"";

","18
libr/anal/vtable.c
@@ -58,6 +58,8 @@ R_API bool r_anal_vtable_begin(RAnal *anal, RVTableContext *context) {
  context->read_addr = be? vtable_read_addr_be64 : vtable_read_addr_le64;
  break;
 default:
  // cant be null. assume 32bit ""->read_addr = NULL;
  context->read_addr = be? vtable_read_addr_be32 : vtable_read_addr_le32;
  return false;
 }
 return true;
@@ -72,7 +74,7 @@ static bool vtable_addr_in_text_section(RVTableContext *context, ut64 curAddress

static bool vtable_is_value_in_text_section(RVTableContext *context, ut64 curAddress, ut64 *value) {
 //value at the current address
 ut64 curAddressValue;
 ut64 curAddressValue = UT64_MAX;
 if (!context->read_addr (context->anal, curAddress, &curAddressValue)) {
  return false;
 }
@@ -132,6 +134,7 @@ static bool vtable_is_addr_vtable_start_itanium(RVTableContext *context, RBinSec
}

static bool vtable_is_addr_vtable_start_msvc(RVTableContext *context, ut64 curAddress) {
 ut8 buf[VTABLE_BUFF_SIZE];
 RAnalRef *xref;
 RListIter *xrefIter;

@@ -150,19 +153,14 @@ static bool vtable_is_addr_vtable_start_msvc(RVTableContext *context, ut64 curAd
 r_list_foreach (xrefs, xrefIter, xref) {
  // section in which currenct xref lies
  if (vtable_addr_in_text_section (context, xref->addr)) {
   ut8 buf[VTABLE_BUFF_SIZE];
   context->anal->iob.read_at (context->anal->iob.io, xref->addr, buf, sizeof(buf));

   context->anal->iob.read_at (context->anal->iob.io, xref->addr, buf, sizeof (buf));
   RAnalOp analop = {0};
   r_anal_op (context->anal, &analop, xref->addr, buf, sizeof(buf), R_ANAL_OP_MASK_BASIC);

   if (analop.type == R_ANAL_OP_TYPE_MOV
    || analop.type == R_ANAL_OP_TYPE_LEA) {
   r_anal_op (context->anal, &analop, xref->addr, buf, sizeof (buf), R_ANAL_OP_MASK_BASIC);
   if (analop.type == R_ANAL_OP_TYPE_MOV || analop.type == R_ANAL_OP_TYPE_LEA) {
    r_list_free (xrefs);
    r_anal_op_fini (&analop);
    return true;
   }

   r_anal_op_fini (&analop);
  }
 }
@@ -286,7 +284,7 @@ R_API RList *r_anal_vtable_search(RVTableContext *context) {
}

R_API void r_anal_list_vtables(RAnal *anal, int rad) {
 RVTableContext context;
 RVTableContext context = {0};
 r_anal_vtable_begin (anal, &context);

 const char *noMethodName = ""No Name found"";"
https://huntr.dev/bounties/9c312763-41a6-4fc7-827b-269eb86efcbc/,Use After Free in gpac/gpac,Use After Free in gpac,CVE-2022-1795,CWE-416: Use After Free,https://www.github.com/gpac/gpac/commit/c535bad50d5812d27ee5b22b54371bddec411514,"@@ -178,7 +178,12 @@ static GF_Err BM_ParseGlobalQuantizer(GF_BifsDecoder *codec, GF_BitStream *bs, G
 codec->scenegraph->global_qp = NULL;

 if (gf_node_get_tag(node) != TAG_MPEG4_QuantizationParameter) {
  gf_node_unregister(node, NULL);





  return GF_NON_COMPLIANT_BITSTREAM;
 }

@@ -188,7 +193,8 @@ static GF_Err BM_ParseGlobalQuantizer(GF_BifsDecoder *codec, GF_BitStream *bs, G
 codec->scenegraph->global_qp = node;

 /*register TWICE: once for the command, and for the scenegraph globalQP*/
 node->sgprivate->num_instances = 2;


 com = gf_sg_command_new(codec->current_graph, GF_SG_GLOBAL_QUANTIZER);
 inf = gf_sg_command_field_new(com);

","10
src/bifs/memory_decoder.c
@@ -178,7 +178,12 @@ static GF_Err BM_ParseGlobalQuantizer(GF_BifsDecoder *codec, GF_BitStream *bs, G
 codec->scenegraph->global_qp = NULL;

 if (gf_node_get_tag(node) != TAG_MPEG4_QuantizationParameter) {
  gf_node_unregister(node, NULL);
  //if node was just created (num_instances == 0), unregister
  //otherwise (USE node) don't do anything
  if (!node->sgprivate->num_instances) {
   node->sgprivate->num_instances = 1;
   gf_node_unregister(node, NULL);
  }
  return GF_NON_COMPLIANT_BITSTREAM;
 }

@@ -188,7 +193,8 @@ static GF_Err BM_ParseGlobalQuantizer(GF_BifsDecoder *codec, GF_BitStream *bs, G
 codec->scenegraph->global_qp = node;

 /*register TWICE: once for the command, and for the scenegraph globalQP*/
 node->sgprivate->num_instances = 2;
 gf_node_unregister(node, NULL);
 gf_node_unregister(node, NULL);

 com = gf_sg_command_new(codec->current_graph, GF_SG_GLOBAL_QUANTIZER);
 inf = gf_sg_command_field_new(com);"
https://huntr.dev/bounties/f2a7f131-ab06-42fe-9aae-0c6b9d4e1f33/,Stack buffer overflow in RTSP packet parsing in gpac/gpac,A malicious RTSP server can trigger a stack buffer overflow via an RTSP packet with an excessively long content-length due to no bounds check when copying into a fixed sized buffer.,,CWE-121: Stack-based Buffer Overflow,https://www.github.com/gpac/gpac/commit/75b371e8fac744315c1666af2502726440805452,"@@ -540,6 +540,12 @@ GF_Err gf_rtsp_get_command(GF_RTSPSession *sess, GF_RTSPCommand *com)

 //copy the body if any
 if (!e && com->Content_Length) {






  com->body = (char *) gf_malloc(sizeof(char) * (com->Content_Length));
  memcpy(com->body, sess->tcp_buffer+sess->CurrentPos + BodyStart, com->Content_Length);
 }

@@ -58,7 +58,6 @@ GF_Err gf_rtsp_read_reply(GF_RTSPSession *sess)

void gf_rtsp_get_body_info(GF_RTSPSession *sess, u32 *body_start, u32 *body_size)
{
 u32 i;
 s32 start;
 char *buffer;
 char *cl_str;
@@ -73,23 +72,21 @@ void gf_rtsp_get_body_info(GF_RTSPSession *sess, u32 *body_start, u32 *body_size

 //if found add the 2 ""\r\n"" and parse it
 *body_start = start + 4;


 //get the content length
 cl_str = strstr(buffer, ""Content-Length: "");
 if (!cl_str) cl_str = strstr(buffer, ""Content-length: "");

 if (cl_str) {
  char val[30];
  cl_str += 16;
  i = 0;
  while (cl_str[i] != '\r') {
   val[i] = cl_str[i];
   i += 1;

  }
  val[i] = 0;
  *body_size = atoi(val);
 } else {
  *body_size = 0;
 }
}


@@ -398,6 +398,12 @@ GF_Err gf_rtsp_get_response(GF_RTSPSession *sess, GF_RTSPResponse *rsp)

 //copy the body if any
 if (!e && rsp->Content_Length) {






  rsp->body = (char *)gf_malloc(sizeof(char) * (rsp->Content_Length));
  memcpy(rsp->body, sess->tcp_buffer+sess->CurrentPos + BodyStart, rsp->Content_Length);
 }

","6
src/ietf/rtsp_command.c
@@ -540,6 +540,12 @@ GF_Err gf_rtsp_get_command(GF_RTSPSession *sess, GF_RTSPCommand *com)

 //copy the body if any
 if (!e && com->Content_Length) {
  u32 rsp_size = sess->CurrentSize - sess->CurrentPos;
  if (rsp_size < com->Content_Length) {
   GF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (""[RTSP] Invalid content length %u - Response was: \n%s\n"", com->Content_Length, sess->tcp_buffer+sess->CurrentPos));
   e = GF_NON_COMPLIANT_BITSTREAM;
   goto exit;
  }
  com->body = (char *) gf_malloc(sizeof(char) * (com->Content_Length));
  memcpy(com->body, sess->tcp_buffer+sess->CurrentPos + BodyStart, com->Content_Length);
 }
17
src/ietf/rtsp_common.c
@@ -58,7 +58,6 @@ GF_Err gf_rtsp_read_reply(GF_RTSPSession *sess)

void gf_rtsp_get_body_info(GF_RTSPSession *sess, u32 *body_start, u32 *body_size)
{
 u32 i;
 s32 start;
 char *buffer;
 char *cl_str;
@@ -73,23 +72,21 @@ void gf_rtsp_get_body_info(GF_RTSPSession *sess, u32 *body_start, u32 *body_size

 //if found add the 2 ""\r\n"" and parse it
 *body_start = start + 4;
 *body_size = 0;

 //get the content length
 cl_str = strstr(buffer, ""Content-Length: "");
 if (!cl_str) cl_str = strstr(buffer, ""Content-length: "");

 if (cl_str) {
  char val[30];
  char *sep;
  cl_str += 16;
  i = 0;
  while (cl_str[i] != '\r') {
   val[i] = cl_str[i];
   i += 1;
  sep = strchr(cl_str, '\r');
  if (sep) {
   sep[0] = 0;
   *body_size = atoi(cl_str);
   sep[0] = '\r';
  }
  val[i] = 0;
  *body_size = atoi(val);
 } else {
  *body_size = 0;
 }
}

6
src/ietf/rtsp_response.c
@@ -398,6 +398,12 @@ GF_Err gf_rtsp_get_response(GF_RTSPSession *sess, GF_RTSPResponse *rsp)

 //copy the body if any
 if (!e && rsp->Content_Length) {
  u32 rsp_size = sess->CurrentSize - sess->CurrentPos;
  if (rsp_size < rsp->Content_Length) {
   GF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (""[RTSP] Invalid content length %u - Response was: \n%s\n"", rsp->Content_Length, sess->tcp_buffer+sess->CurrentPos));
   e = GF_NON_COMPLIANT_BITSTREAM;
   goto exit;
  }
  rsp->body = (char *)gf_malloc(sizeof(char) * (rsp->Content_Length));
  memcpy(rsp->body, sess->tcp_buffer+sess->CurrentPos + BodyStart, rsp->Content_Length);
 }"
https://huntr.dev/bounties/1c22055b-b015-47a8-a57b-4982978751d0/,Heap-based Buffer Overflow in radareorg/radare2,Heap-based Buffer Overflow in msp430_op,CVE-2022-1714,CWE-122: Heap-based Buffer Overflow,https://www.github.com/radareorg/radare2/commit/3ecdbf8e21186a9c5a4d3cfa3b1e9fd27045340e,"@@ -10,17 +10,13 @@
#include ""../arch/msp430/msp430_disas.h""

static int msp430_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *buf, int len, RAnalOpMask mask) {
 int ret;
 struct msp430_cmd cmd;

 memset (&cmd, 0, sizeof (cmd));
 //op->id = ???;
 op->size = -1;
 op->nopcode = 1;
 op->type = R_ANAL_OP_TYPE_UNK;
 op->family = R_ANAL_OP_FAMILY_CPU;

 ret = op->size = msp430_decode_command (buf, len, &cmd);
 if (mask & R_ANAL_OP_MASK_DISASM) {
  if (ret < 1) {
   op->mnemonic = strdup (""invalid"");
@@ -59,7 +55,9 @@ static int msp430_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *buf, int le
  case MSP430_CALL:
   op->type = R_ANAL_OP_TYPE_CALL;
   op->fail = addr + op->size;
   op->jump = r_read_at_le16 (buf, 2);


   break;
  case MSP430_RETI:
   op->type = R_ANAL_OP_TYPE_RET;
@@ -111,6 +109,7 @@ static bool set_reg_profile(RAnal *anal) {
 const char *p = \
  ""=PC pc\n""
  ""=SP sp\n""

  // this is the ""new"" ABI, the old was reverse order
  ""=A0 r12\n""
  ""=A1 r13\n""

@@ -124,7 +124,7 @@ static bool init_ehdr(ELFOBJ *bin) {
 ut8 ehdr[sizeof (Elf_(Ehdr))] = {0};
 int i, len;
 if (r_buf_read_at (bin->b, 0, e_ident, EI_NIDENT) == -1) {
  R_LOG_ERROR (""read (magic)"");
  return false;
 }
 sdb_set (bin->kv, ""elf_type.cparse"", ""enum elf_type { ET_NONE=0, ET_REL=1,""
@@ -188,7 +188,7 @@ static bool init_ehdr(ELFOBJ *bin) {
 memset (&bin->ehdr, 0, sizeof (Elf_(Ehdr)));
 len = r_buf_read_at (bin->b, 0, ehdr, sizeof (ehdr));
 if (len < 32) { // tinyelf != sizeof (Elf_(Ehdr))) {
  R_LOG_ERROR (""read (ehdr)"");
  return false;
 }
 // XXX no need to check twice
@@ -257,7 +257,7 @@ static bool read_phdr(ELFOBJ *bin, bool linux_kernel_hack) {
  const size_t rsize = bin->ehdr.e_phoff + i * sizeof (Elf_(Phdr));
  int len = r_buf_read_at (bin->b, rsize, phdr, sizeof (Elf_(Phdr)));
  if (len < 1) {
   R_LOG_ERROR (""read (phdr)"");
   R_FREE (bin->phdr);
   return false;
  }
@@ -397,7 +397,7 @@ static int init_shdr(ELFOBJ *bin) {
  j = 0;
  len = r_buf_read_at (bin->b, bin->ehdr.e_shoff + i * sizeof (Elf_(Shdr)), shdr, sizeof (Elf_(Shdr)));
  if (len < 1) {
   R_LOG_ERROR (""read (shdr) at 0x%"" PFMT64x, (ut64) bin->ehdr.e_shoff);
   R_FREE (bin->shdr);
   return false;
  }
@@ -475,7 +475,7 @@ static int init_strtab(ELFOBJ *bin) {
 int res = r_buf_read_at (bin->b, bin->shstrtab_section->sh_offset, (ut8*)bin->shstrtab,
  bin->shstrtab_section->sh_size);
 if (res < 1) {
  R_LOG_ERROR (""read (shstrtab) at 0x%"" PFMT64x, (ut64) bin->shstrtab_section->sh_offset);
  R_FREE (bin->shstrtab);
  return false;
 }
@@ -970,7 +970,7 @@ static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz)
 }
 Elf_(Verdef) *defs = calloc (shdr->sh_size, 1);
 if (!defs) {
  R_LOG_ERROR (""Cannot allocate memory (Check Elf_(Verdef))"");
  return false;
 }
 if (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {
@@ -1798,7 +1798,7 @@ ut64 Elf_(r_bin_elf_get_init_offset)(ELFOBJ *bin) {
  return UT64_MAX;
 }
 if (r_buf_read_at (bin->b, entry + 16, buf, sizeof (buf)) < 1) {
  R_LOG_ERROR (""read (init_offset)"");
  return 0;
 }
 if (buf[0] == 0x68) { // push // x86 only

","13
libr/anal/p/anal_msp430.c
@@ -10,17 +10,13 @@
#include ""../arch/msp430/msp430_disas.h""

static int msp430_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *buf, int len, RAnalOpMask mask) {
 int ret;
 struct msp430_cmd cmd;

 memset (&cmd, 0, sizeof (cmd));
 //op->id = ???;
 struct msp430_cmd cmd = {0};
 op->size = -1;
 op->nopcode = 1;
 op->type = R_ANAL_OP_TYPE_UNK;
 op->family = R_ANAL_OP_FAMILY_CPU;

 ret = op->size = msp430_decode_command (buf, len, &cmd);
 int ret = op->size = msp430_decode_command (buf, len, &cmd);
 if (mask & R_ANAL_OP_MASK_DISASM) {
  if (ret < 1) {
   op->mnemonic = strdup (""invalid"");
@@ -59,7 +55,9 @@ static int msp430_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *buf, int le
  case MSP430_CALL:
   op->type = R_ANAL_OP_TYPE_CALL;
   op->fail = addr + op->size;
   op->jump = r_read_at_le16 (buf, 2);
   if (len > 4) {
    op->jump = r_read_at_le16 (buf, 2);
   }
   break;
  case MSP430_RETI:
   op->type = R_ANAL_OP_TYPE_RET;
@@ -111,6 +109,7 @@ static bool set_reg_profile(RAnal *anal) {
 const char *p = \
  ""=PC pc\n""
  ""=SP sp\n""
  ""=SN r0\n""
  // this is the ""new"" ABI, the old was reverse order
  ""=A0 r12\n""
  ""=A1 r13\n""
14
libr/bin/format/elf/elf.c
@@ -124,7 +124,7 @@ static bool init_ehdr(ELFOBJ *bin) {
 ut8 ehdr[sizeof (Elf_(Ehdr))] = {0};
 int i, len;
 if (r_buf_read_at (bin->b, 0, e_ident, EI_NIDENT) == -1) {
  R_LOG_ERROR (""read (magic)"");
  R_LOG_DEBUG (""read (magic)"");
  return false;
 }
 sdb_set (bin->kv, ""elf_type.cparse"", ""enum elf_type { ET_NONE=0, ET_REL=1,""
@@ -188,7 +188,7 @@ static bool init_ehdr(ELFOBJ *bin) {
 memset (&bin->ehdr, 0, sizeof (Elf_(Ehdr)));
 len = r_buf_read_at (bin->b, 0, ehdr, sizeof (ehdr));
 if (len < 32) { // tinyelf != sizeof (Elf_(Ehdr))) {
  R_LOG_ERROR (""read (ehdr)"");
  R_LOG_DEBUG (""read (ehdr)"");
  return false;
 }
 // XXX no need to check twice
@@ -257,7 +257,7 @@ static bool read_phdr(ELFOBJ *bin, bool linux_kernel_hack) {
  const size_t rsize = bin->ehdr.e_phoff + i * sizeof (Elf_(Phdr));
  int len = r_buf_read_at (bin->b, rsize, phdr, sizeof (Elf_(Phdr)));
  if (len < 1) {
   R_LOG_ERROR (""read (phdr)"");
   R_LOG_DEBUG (""read (phdr)"");
   R_FREE (bin->phdr);
   return false;
  }
@@ -397,7 +397,7 @@ static int init_shdr(ELFOBJ *bin) {
  j = 0;
  len = r_buf_read_at (bin->b, bin->ehdr.e_shoff + i * sizeof (Elf_(Shdr)), shdr, sizeof (Elf_(Shdr)));
  if (len < 1) {
   R_LOG_ERROR (""read (shdr) at 0x%"" PFMT64x, (ut64) bin->ehdr.e_shoff);
   R_LOG_DEBUG (""read (shdr) at 0x%"" PFMT64x, (ut64) bin->ehdr.e_shoff);
   R_FREE (bin->shdr);
   return false;
  }
@@ -475,7 +475,7 @@ static int init_strtab(ELFOBJ *bin) {
 int res = r_buf_read_at (bin->b, bin->shstrtab_section->sh_offset, (ut8*)bin->shstrtab,
  bin->shstrtab_section->sh_size);
 if (res < 1) {
  R_LOG_ERROR (""read (shstrtab) at 0x%"" PFMT64x, (ut64) bin->shstrtab_section->sh_offset);
  R_LOG_DEBUG (""read (shstrtab) at 0x%"" PFMT64x, (ut64) bin->shstrtab_section->sh_offset);
  R_FREE (bin->shstrtab);
  return false;
 }
@@ -970,7 +970,7 @@ static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz)
 }
 Elf_(Verdef) *defs = calloc (shdr->sh_size, 1);
 if (!defs) {
  R_LOG_ERROR (""Cannot allocate memory (Check Elf_(Verdef))"");
  R_LOG_DEBUG (""Cannot allocate memory (Check Elf_(Verdef))"");
  return false;
 }
 if (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {
@@ -1798,7 +1798,7 @@ ut64 Elf_(r_bin_elf_get_init_offset)(ELFOBJ *bin) {
  return UT64_MAX;
 }
 if (r_buf_read_at (bin->b, entry + 16, buf, sizeof (buf)) < 1) {
  R_LOG_ERROR (""read (init_offset)"");
  R_LOG_DEBUG (""read (init_offset)"");
  return 0;
 }
 if (buf[0] == 0x68) { // push // x86 only"
https://huntr.dev/bounties/c07e4918-cf86-4d2e-8969-5fb63575b449/,Null pointer dereference in libr/bin/format/mach0/mach0.c in radareorg/radare2 in radareorg/radare2,"4578                            ut64 page_end_idx = (R_MIN (limit_end, end) - start) / page_size;",CVE-2022-1649,CWE-476: NULL Pointer Dereference,https://www.github.com/radareorg/radare2/commit/a5aafb99c3965259c84ddcf45a91144bf7eb4cf1,"@@ -4580,6 +4580,9 @@ void MACH0_(iterate_chained_fixups)(struct MACH0_(obj_t) *bin, ut64 limit_start,
    if (page_idx >= bin->chained_starts[i]->page_count) {
     break;
    }



    ut16 page_start = bin->chained_starts[i]->page_start[page_idx];
    if (page_start == DYLD_CHAINED_PTR_START_NONE) {
     continue;

","3
libr/bin/format/mach0/mach0.c
@@ -4580,6 +4580,9 @@ void MACH0_(iterate_chained_fixups)(struct MACH0_(obj_t) *bin, ut64 limit_start,
    if (page_idx >= bin->chained_starts[i]->page_count) {
     break;
    }
    if (!bin->chained_starts[i]->page_start) {
     break;
    }
    ut16 page_start = bin->chained_starts[i]->page_start[page_idx];
    if (page_start == DYLD_CHAINED_PTR_START_NONE) {
     continue;"
https://huntr.dev/bounties/8a121555-d407-45a3-9c92-b1b9442034ff/,Denial of service in mruby/mruby,49b8cef31f01c0d88d874e17714dff1fa5b85df0,,CWE-400: Denial of Service,https://www.github.com/mruby/mruby/commit/457abf4c9ef91f0f888791c67598218091b55d8b,"@@ -137,10 +137,9 @@ exc_to_s(mrb_state *mrb, mrb_value exc)
mrb_value
mrb_exc_inspect(mrb_state *mrb, mrb_value exc)
{
  mrb_value mesg = mrb_exc_mesg_get(mrb, mrb_exc_ptr(exc));
  mrb_value cname = mrb_mod_to_s(mrb, mrb_obj_value(mrb_obj_class(mrb, exc)));
  mesg = mrb_obj_as_string(mrb, mesg);
  return RSTRING_LEN(mesg) == 0 ? cname : mrb_format(mrb, ""%v (%v)"", mesg, cname);
}

void mrb_keep_backtrace(mrb_state *mrb, mrb_value exc);

","5
src/error.c
@@ -137,10 +137,9 @@ exc_to_s(mrb_state *mrb, mrb_value exc)
mrb_value
mrb_exc_inspect(mrb_state *mrb, mrb_value exc)
{
  mrb_value mesg = mrb_exc_mesg_get(mrb, mrb_exc_ptr(exc));
  mrb_value cname = mrb_mod_to_s(mrb, mrb_obj_value(mrb_obj_class(mrb, exc)));
  mesg = mrb_obj_as_string(mrb, mesg);
  return RSTRING_LEN(mesg) == 0 ? cname : mrb_format(mrb, ""%v (%v)"", mesg, cname);
  mrb_value mesg = mrb_exc_mesg_get(mrb, mrb_exc_ptr(exc)); /* string or nil */
  return (mrb_nil_p(mesg)||RSTRING_LEN(mesg)==0) ? cname : mrb_format(mrb, ""%v (%v)"", mesg, cname);
}

void mrb_keep_backtrace(mrb_state *mrb, mrb_value exc);"
https://huntr.dev/bounties/e8197737-7557-443e-a59f-2a86e8dda75f/,A heap-buffer-overflow in mobi_decode_infl in index.c in bfabiszewski/libmobi,A heap-buffer-overflow in mobi_decode_infl in index.c,CVE-2022-1987,CWE-126: Buffer Over-read,https://www.github.com/bfabiszewski/libmobi/commit/612562bc1ea38f1708b044e7a079c47a05b1291d,"@@ -1,3 +1,4 @@

2022-05-03: Fix boundary checking error in markup search, that could cause buffer over-read with corrupt input
2022-05-02: Fix typo in macro name
2022-04-27: Fix undefined behavior when passing null to strdup

@@ -29,11 +29,11 @@
/**
 @brief Read index entry label from buffer pointing at index record data
 
 @param[in,out] output Output string
 @param[in,out] buf MOBIBuffer structure, offset pointing at index entry label
 @param[in] length Number of bytes to be read
 @param[in] has_ligatures Decode ligatures if true
 @return Size of read label
 */
size_t mobi_indx_get_label(unsigned char *output, MOBIBuffer *buf, const size_t length, const size_t has_ligatures) {
    if (!output) {
@@ -248,9 +248,9 @@ uint16_t mobi_ordt_lookup(const MOBIOrdt *ordt, const uint16_t offset) {
 
 @param[in] ordt MOBIOrdt structure (ORDT data and metadata)
 @param[in,out] buf MOBIBuffer structure with input string
 @param[in,out] output Output buffer (INDX_LABEL_SIZEMAX bytes)
 @param[in] length Length of input string contained in buf
 @return Number of bytes read
 */
size_t mobi_getstring_ordt(const MOBIOrdt *ordt, MOBIBuffer *buf, unsigned char *output, size_t length) {
    size_t i = 0;
@@ -362,12 +362,16 @@ static MOBI_RET mobi_parse_index_entry(MOBIIndx *indx, const MOBIIdxt idxt, cons
        debug_print(""Label length too long: %zu\n"", label_length);
        return MOBI_DATA_CORRUPT;
    }
    char text[INDX_LABEL_SIZEMAX];
    /* FIXME: what is ORDT1 for? */
    if (ordt->ordt2) {
        label_length = mobi_getstring_ordt(ordt, buf, (unsigned char*) text, label_length);
    } else {
        label_length = mobi_indx_get_label((unsigned char*) text, buf, label_length, indx->ligt_entries_count);




    }
    indx->entries[entry_number].label = malloc(label_length + 1);
    if (indx->entries[entry_number].label == NULL) {

","1
ChangeLog
@@ -1,3 +1,4 @@
2022-05-05: Fix: index entry label not being zero-terminated with corrupt input
2022-05-03: Fix boundary checking error in markup search, that could cause buffer over-read with corrupt input
2022-05-02: Fix typo in macro name
2022-04-27: Fix undefined behavior when passing null to strdup
14
src/index.c
@@ -29,11 +29,11 @@
/**
 @brief Read index entry label from buffer pointing at index record data
   @param[in,out] output Output string
 @param[in,out] output Output buffer (INDX_LABEL_SIZEMAX + 1 bytes)
 @param[in,out] buf MOBIBuffer structure, offset pointing at index entry label
 @param[in] length Number of bytes to be read
 @param[in] has_ligatures Decode ligatures if true
 @return Size of read label
 @return Length of output string (without null terminator), on error buf->error set to MOBI_RET status
 */
size_t mobi_indx_get_label(unsigned char *output, MOBIBuffer *buf, const size_t length, const size_t has_ligatures) {
    if (!output) {
@@ -248,9 +248,9 @@ uint16_t mobi_ordt_lookup(const MOBIOrdt *ordt, const uint16_t offset) {
   @param[in] ordt MOBIOrdt structure (ORDT data and metadata)
 @param[in,out] buf MOBIBuffer structure with input string
 @param[in,out] output Output buffer (INDX_LABEL_SIZEMAX bytes)
 @param[in,out] output Output buffer (INDX_LABEL_SIZEMAX + 1 bytes)
 @param[in] length Length of input string contained in buf
 @return Number of bytes read
 @return Length of output string (without null terminator)
 */
size_t mobi_getstring_ordt(const MOBIOrdt *ordt, MOBIBuffer *buf, unsigned char *output, size_t length) {
    size_t i = 0;
@@ -362,12 +362,16 @@ static MOBI_RET mobi_parse_index_entry(MOBIIndx *indx, const MOBIIdxt idxt, cons
        debug_print(""Label length too long: %zu\n"", label_length);
        return MOBI_DATA_CORRUPT;
    }
    char text[INDX_LABEL_SIZEMAX];
    char text[INDX_LABEL_SIZEMAX + 1];
    /* FIXME: what is ORDT1 for? */
    if (ordt->ordt2) {
        label_length = mobi_getstring_ordt(ordt, buf, (unsigned char*) text, label_length);
    } else {
        label_length = mobi_indx_get_label((unsigned char*) text, buf, label_length, indx->ligt_entries_count);
        if (buf->error != MOBI_SUCCESS) {
            debug_print(""Buffer error reading label: %d\n"", buf->error);
            return MOBI_DATA_CORRUPT;
        }
    }
    indx->entries[entry_number].label = malloc(label_length + 1);
    if (indx->entries[entry_number].label == NULL) {"
https://huntr.dev/bounties/f6b9114b-671d-4948-b946-ffe5c9aeb816/,Buffer Over-read in hpjansson/chafa,Buffer Over-read in hpjansson/chafa at xwd-loader.c:185,CVE-2022-2301,CWE-126: Buffer Over-read,https://www.github.com/hpjansson/chafa/commit/56fabfa18a6880b4cb66047fa6557920078048d9,"@@ -165,67 +165,91 @@ compute_pixel_type (XwdLoader *loader)
}

#define ASSERT_HEADER(x) if (!(x)) return FALSE



static gboolean
load_header (XwdLoader *loader) // gconstpointer in, gsize in_max_len, XwdHeader *header_out)
{
    XwdHeader *h = &loader->header;
    XwdHeader in;
    const guint32 *p = (const guint32 *) &in;

    if (!file_mapping_taste (loader->mapping, &in, 0, sizeof (in)))
        return FALSE;

    h->header_size = g_ntohl (*(p++));
    h->file_version = g_ntohl (*(p++));
    h->pixmap_format = g_ntohl (*(p++));
    h->pixmap_depth = g_ntohl (*(p++));
    h->pixmap_width = g_ntohl (*(p++));
    h->pixmap_height = g_ntohl (*(p++));
    h->x_offset = g_ntohl (*(p++));
    h->byte_order = g_ntohl (*(p++));
    h->bitmap_unit = g_ntohl (*(p++));
    h->bitmap_bit_order = g_ntohl (*(p++));
    h->bitmap_pad = g_ntohl (*(p++));
    h->bits_per_pixel = g_ntohl (*(p++));
    h->bytes_per_line = g_ntohl (*(p++));
    h->visual_class = g_ntohl (*(p++));
    h->red_mask = g_ntohl (*(p++));
    h->green_mask = g_ntohl (*(p++));
    h->blue_mask = g_ntohl (*(p++));
    h->bits_per_rgb = g_ntohl (*(p++));
    h->color_map_entries = g_ntohl (*(p++));
    h->n_colors = g_ntohl (*(p++));
    h->window_width = g_ntohl (*(p++));
    h->window_height = g_ntohl (*(p++));
    h->window_x = g_ntohl (*(p++));
    h->window_y = g_ntohl (*(p++));
    h->window_border_width = g_ntohl (*(p++));



    /* Only support the most common/useful subset of XWD files out there;
     * namely, that corresponding to screen dumps from modern X.Org servers. */



    ASSERT_HEADER (h->header_size >= sizeof (XwdHeader));

    ASSERT_HEADER (h->file_version == 7);
    ASSERT_HEADER (h->pixmap_depth == 24);




    /* Xvfb sets bits_per_rgb to 8, but 'convert' uses 24 for the same image data. One
     * of them is likely misunderstanding. Let's be lenient and accept either. */
    ASSERT_HEADER (h->bits_per_rgb == 8 || h->bits_per_rgb == 24);










    ASSERT_HEADER (h->bytes_per_line >= h->pixmap_width * (h->bits_per_pixel / 8));





    ASSERT_HEADER (compute_pixel_type (loader) < CHAFA_PIXEL_MAX);

    loader->file_data = file_mapping_get_data (loader->mapping, &loader->file_data_len);
    if (!loader->file_data)
        return FALSE;

    ASSERT_HEADER (loader->file_data_len >= h->header_size
                   + h->n_colors * sizeof (XwdColor)
                   + h->pixmap_height * h->bytes_per_line);

    loader->image_data = (const guint8 *) loader->file_data
        + h->header_size + h->n_colors * sizeof (XwdColor);

    return TRUE;
}

","86
tools/chafa/xwd-loader.c
@@ -165,67 +165,91 @@ compute_pixel_type (XwdLoader *loader)
}

#define ASSERT_HEADER(x) if (!(x)) return FALSE
#define UNPACK_FIELD_U32(dest, src, field) ((dest)->field = GUINT32_FROM_BE ((src)->field))
#define UNPACK_FIELD_S32(dest, src, field) ((dest)->field = GINT32_FROM_BE ((src)->field))

static gboolean
load_header (XwdLoader *loader) // gconstpointer in, gsize in_max_len, XwdHeader *header_out)
load_header (XwdLoader *loader)
{
    XwdHeader *h = &loader->header;
    XwdHeader in;
    const guint32 *p = (const guint32 *) &in;
    const XwdHeader *inp;

    if (!file_mapping_taste (loader->mapping, &in, 0, sizeof (in)))
        return FALSE;

    h->header_size = g_ntohl (*(p++));
    h->file_version = g_ntohl (*(p++));
    h->pixmap_format = g_ntohl (*(p++));
    h->pixmap_depth = g_ntohl (*(p++));
    h->pixmap_width = g_ntohl (*(p++));
    h->pixmap_height = g_ntohl (*(p++));
    h->x_offset = g_ntohl (*(p++));
    h->byte_order = g_ntohl (*(p++));
    h->bitmap_unit = g_ntohl (*(p++));
    h->bitmap_bit_order = g_ntohl (*(p++));
    h->bitmap_pad = g_ntohl (*(p++));
    h->bits_per_pixel = g_ntohl (*(p++));
    h->bytes_per_line = g_ntohl (*(p++));
    h->visual_class = g_ntohl (*(p++));
    h->red_mask = g_ntohl (*(p++));
    h->green_mask = g_ntohl (*(p++));
    h->blue_mask = g_ntohl (*(p++));
    h->bits_per_rgb = g_ntohl (*(p++));
    h->color_map_entries = g_ntohl (*(p++));
    h->n_colors = g_ntohl (*(p++));
    h->window_width = g_ntohl (*(p++));
    h->window_height = g_ntohl (*(p++));
    h->window_x = g_ntohl (*(p++));
    h->window_y = g_ntohl (*(p++));
    h->window_border_width = g_ntohl (*(p++));
    inp = &in;

    UNPACK_FIELD_U32 (h, inp, header_size);
    UNPACK_FIELD_U32 (h, inp, file_version);
    UNPACK_FIELD_U32 (h, inp, pixmap_format);
    UNPACK_FIELD_U32 (h, inp, pixmap_depth);
    UNPACK_FIELD_U32 (h, inp, pixmap_width);
    UNPACK_FIELD_U32 (h, inp, pixmap_height);
    UNPACK_FIELD_U32 (h, inp, x_offset);
    UNPACK_FIELD_U32 (h, inp, byte_order);
    UNPACK_FIELD_U32 (h, inp, bitmap_unit);
    UNPACK_FIELD_U32 (h, inp, bitmap_bit_order);
    UNPACK_FIELD_U32 (h, inp, bitmap_pad);
    UNPACK_FIELD_U32 (h, inp, bits_per_pixel);
    UNPACK_FIELD_U32 (h, inp, bytes_per_line);
    UNPACK_FIELD_U32 (h, inp, visual_class);
    UNPACK_FIELD_U32 (h, inp, red_mask);
    UNPACK_FIELD_U32 (h, inp, green_mask);
    UNPACK_FIELD_U32 (h, inp, blue_mask);
    UNPACK_FIELD_U32 (h, inp, bits_per_rgb);
    UNPACK_FIELD_U32 (h, inp, color_map_entries);
    UNPACK_FIELD_U32 (h, inp, n_colors);
    UNPACK_FIELD_U32 (h, inp, window_width);
    UNPACK_FIELD_U32 (h, inp, window_height);
    UNPACK_FIELD_S32 (h, inp, window_x);
    UNPACK_FIELD_S32 (h, inp, window_y);
    UNPACK_FIELD_U32 (h, inp, window_border_width);

    /* Only support the most common/useful subset of XWD files out there;
     * namely, that corresponding to screen dumps from modern X.Org servers. */
     * namely, that corresponding to screen dumps from modern X.Org servers.
     * We could check visual_class == 5 too, but the other fields convey all
     * the info we need. */

    ASSERT_HEADER (h->header_size >= sizeof (XwdHeader));
    ASSERT_HEADER (h->header_size <= 65535);
    ASSERT_HEADER (h->file_version == 7);
    ASSERT_HEADER (h->pixmap_depth == 24);

    /* Should be zero for truecolor/directcolor. Cap it to prevent overflows. */
    ASSERT_HEADER (h->color_map_entries <= 256);

    /* Xvfb sets bits_per_rgb to 8, but 'convert' uses 24 for the same image data. One
     * of them is likely misunderstanding. Let's be lenient and accept either. */
    ASSERT_HEADER (h->bits_per_rgb == 8 || h->bits_per_rgb == 24);

    /* These are the pixel formats we allow. */
    ASSERT_HEADER (h->bits_per_pixel == 24 || h->bits_per_pixel == 32);

    /* Enforce sane dimensions. */
    ASSERT_HEADER (h->pixmap_width >= 1 && h->pixmap_width <= 65535);
    ASSERT_HEADER (h->pixmap_height >= 1 && h->pixmap_height <= 65535);

    /* Make sure rowstride can actually hold a row's worth of data but is not padded to
     * something ridiculous. */
    ASSERT_HEADER (h->bytes_per_line >= h->pixmap_width * (h->bits_per_pixel / 8));
    ASSERT_HEADER (h->bytes_per_line <= h->pixmap_width * (h->bits_per_pixel / 8) + 1024);

    /* Make sure the total allocation/map is not too big. */
    ASSERT_HEADER (h->bytes_per_line * h->pixmap_height < (1UL << 31) - 65536 - 256 * 32);

    ASSERT_HEADER (compute_pixel_type (loader) < CHAFA_PIXEL_MAX);

    loader->file_data = file_mapping_get_data (loader->mapping, &loader->file_data_len);
    if (!loader->file_data)
        return FALSE;

    ASSERT_HEADER (loader->file_data_len >= h->header_size
                   + h->n_colors * sizeof (XwdColor)
                   + h->pixmap_height * h->bytes_per_line);
                   + h->color_map_entries * sizeof (XwdColor)
                   + h->pixmap_height * (gsize) h->bytes_per_line);

    loader->image_data = (const guint8 *) loader->file_data
        + h->header_size + h->n_colors * sizeof (XwdColor);
        + h->header_size + h->color_map_entries * sizeof (XwdColor);

    return TRUE;
}"
https://huntr.dev/bounties/a7436e88-0488-4bd4-816f-2e2c803e93e8/,Heap-buffer-overflow in mobi_search_links_kf7 in bfabiszewski/libmobi,heap-buffer-overflow /home/ubuntu/libmobi-public/src/parse_rawml.c:110 in mobi_search_links_kf7,CVE-2022-1908,CWE-126: Buffer Over-read,https://www.github.com/bfabiszewski/libmobi/commit/1e0378e6f9e4ae415cedc9eb10850888897c5dba,"@@ -1,3 +1,4 @@

2022-05-02: Fix typo in macro name
2022-04-27: Fix undefined behavior when passing null to strdup
2022-04-27: Fix wrong boundary checks in inflections parser resulting in stack buffer over-read with corrupt input

@@ -107,7 +107,7 @@ MOBI_RET mobi_search_links_kf7(MOBIResult *result, const unsigned char *data_sta
                    result->value[i++] = (char) *data++;
                }
                /* self closing tag '/>' */
                if (*(data - 1) == '/' && *data == '>') {
                    --data; --i;
                }
                result->end = data;
@@ -182,7 +182,7 @@ MOBI_RET mobi_find_attrvalue(MOBIResult *result, const unsigned char *data_start
                result->value[i++] = (char) *data++;
            }
            /* self closing tag '/>' */
            if (*(data - 1) == '/' && *data == '>') {
                --data; --i;
            }
            result->end = data;
@@ -354,7 +354,7 @@ size_t mobi_get_attribute_value(char *value, const unsigned char *data, const si
                length--;
            }
            /* self closing tag '/>' */
            if (*(data - 1) == '/' && *data == '>') {
                value--;
            }
            *value = '\0';

","1
ChangeLog
@@ -1,3 +1,4 @@
2022-05-03: Fix boundary checking error in markup search, that could cause buffer over-read with corrupt input
2022-05-02: Fix typo in macro name
2022-04-27: Fix undefined behavior when passing null to strdup
2022-04-27: Fix wrong boundary checks in inflections parser resulting in stack buffer over-read with corrupt input
6
src/parse_rawml.c
@@ -107,7 +107,7 @@ MOBI_RET mobi_search_links_kf7(MOBIResult *result, const unsigned char *data_sta
                    result->value[i++] = (char) *data++;
                }
                /* self closing tag '/>' */
                if (*(data - 1) == '/' && *data == '>') {
                if (data <= data_end && *(data - 1) == '/' && *data == '>') {
                    --data; --i;
                }
                result->end = data;
@@ -182,7 +182,7 @@ MOBI_RET mobi_find_attrvalue(MOBIResult *result, const unsigned char *data_start
                result->value[i++] = (char) *data++;
            }
            /* self closing tag '/>' */
            if (*(data - 1) == '/' && *data == '>') {
            if (data <= data_end && *(data - 1) == '/' && *data == '>') {
                --data; --i;
            }
            result->end = data;
@@ -354,7 +354,7 @@ size_t mobi_get_attribute_value(char *value, const unsigned char *data, const si
                length--;
            }
            /* self closing tag '/>' */
            if (*(data - 1) == '/' && *data == '>') {
            if (length && *(data - 1) == '/' && *data == '>') {
                value--;
            }
            *value = '\0';"
https://huntr.dev/bounties/4eb0fa3e-4480-4fb5-8ec0-fbcd71de6012/,heap-buffer-overflow in mobi_get_attribute_value in bfabiszewski/libmobi,heap-buffer-overflow /home/ubuntu/libmobi-public/src/parse_rawml.c:357 in mobi_get_attribute_value,CVE-2022-1907,CWE-126: Buffer Over-read,https://www.github.com/bfabiszewski/libmobi/commit/1e0378e6f9e4ae415cedc9eb10850888897c5dba,"@@ -1,3 +1,4 @@

2022-05-02: Fix typo in macro name
2022-04-27: Fix undefined behavior when passing null to strdup
2022-04-27: Fix wrong boundary checks in inflections parser resulting in stack buffer over-read with corrupt input

@@ -107,7 +107,7 @@ MOBI_RET mobi_search_links_kf7(MOBIResult *result, const unsigned char *data_sta
                    result->value[i++] = (char) *data++;
                }
                /* self closing tag '/>' */
                if (*(data - 1) == '/' && *data == '>') {
                    --data; --i;
                }
                result->end = data;
@@ -182,7 +182,7 @@ MOBI_RET mobi_find_attrvalue(MOBIResult *result, const unsigned char *data_start
                result->value[i++] = (char) *data++;
            }
            /* self closing tag '/>' */
            if (*(data - 1) == '/' && *data == '>') {
                --data; --i;
            }
            result->end = data;
@@ -354,7 +354,7 @@ size_t mobi_get_attribute_value(char *value, const unsigned char *data, const si
                length--;
            }
            /* self closing tag '/>' */
            if (*(data - 1) == '/' && *data == '>') {
                value--;
            }
            *value = '\0';

","1
ChangeLog
@@ -1,3 +1,4 @@
2022-05-03: Fix boundary checking error in markup search, that could cause buffer over-read with corrupt input
2022-05-02: Fix typo in macro name
2022-04-27: Fix undefined behavior when passing null to strdup
2022-04-27: Fix wrong boundary checks in inflections parser resulting in stack buffer over-read with corrupt input
6
src/parse_rawml.c
@@ -107,7 +107,7 @@ MOBI_RET mobi_search_links_kf7(MOBIResult *result, const unsigned char *data_sta
                    result->value[i++] = (char) *data++;
                }
                /* self closing tag '/>' */
                if (*(data - 1) == '/' && *data == '>') {
                if (data <= data_end && *(data - 1) == '/' && *data == '>') {
                    --data; --i;
                }
                result->end = data;
@@ -182,7 +182,7 @@ MOBI_RET mobi_find_attrvalue(MOBIResult *result, const unsigned char *data_start
                result->value[i++] = (char) *data++;
            }
            /* self closing tag '/>' */
            if (*(data - 1) == '/' && *data == '>') {
            if (data <= data_end && *(data - 1) == '/' && *data == '>') {
                --data; --i;
            }
            result->end = data;
@@ -354,7 +354,7 @@ size_t mobi_get_attribute_value(char *value, const unsigned char *data, const si
                length--;
            }
            /* self closing tag '/>' */
            if (*(data - 1) == '/' && *data == '>') {
            if (length && *(data - 1) == '/' && *data == '>') {
                value--;
            }
            *value = '\0';"
https://huntr.dev/bounties/68c249e2-779d-4871-b7e3-851f03aca2de/,NULL Pointer Dereference in function mobi_build_opf_metadata at opf.c:1161 in bfabiszewski/libmobi,NULL Pointer Dereference in function mobi_build_opf_metadata at opf.c:1161 allows attackers to cause a denial of service (application crash) via a crafted input file,CVE-2022-2279,CWE-476: NULL Pointer Dereference,https://www.github.com/bfabiszewski/libmobi/commit/c0699c8693c47f14a2e57dec7292e862ac7adf9c,"@@ -1,3 +1,4 @@

2022-04-27: Fix wrong boundary checks in inflections parser resulting in stack buffer over-read with corrupt input
2022-04-26: Fix text formatting
2022-04-26: Fix array boundary check when parsing inflections which could result in buffer over-read with corrupt input

@@ -1152,24 +1152,30 @@ MOBI_RET mobi_build_opf_metadata(OPF *opf,  const MOBIData *m, const MOBIRawml *
    if (mobi_is_dictionary(m)) {
        if (opf->metadata->x_meta->dictionary_in_lang == NULL) {
            if (m->mh && m->mh->dict_input_lang) {
                opf->metadata->x_meta->dictionary_in_lang = calloc(OPF_META_MAX_TAGS, sizeof(char*));
                if (opf->metadata->x_meta->dictionary_in_lang == NULL) {
                    debug_print(""%s\n"", ""Memory allocation failed"");
                    return MOBI_MALLOC_FAILED;
                }
                uint32_t dict_lang_in = *m->mh->dict_input_lang;
                opf->metadata->x_meta->dictionary_in_lang[0] = strdup(mobi_get_locale_string(dict_lang_in));








            }
        }
        if (opf->metadata->x_meta->dictionary_out_lang == NULL) {
            if (m->mh && m->mh->dict_output_lang) {
                opf->metadata->x_meta->dictionary_out_lang = calloc(OPF_META_MAX_TAGS, sizeof(char*));
                if (opf->metadata->x_meta->dictionary_out_lang == NULL) {
                    debug_print(""%s\n"", ""Memory allocation failed"");
                    return MOBI_MALLOC_FAILED;





                }
                uint32_t dict_lang_in = *m->mh->dict_output_lang;
                opf->metadata->x_meta->dictionary_out_lang[0] = strdup(mobi_get_locale_string(dict_lang_in));
            }
        }
        if (rawml->orth->orth_index_name) {

@@ -641,7 +641,7 @@ static const char *mobi_locale[MOBI_LANG_MAX][MOBI_REGION_MAX] = {
 See mobi_locale array.
 
 @param[in] locale_number Mobipocket locale number (as stored in MOBI header)
 @return Pointer to locale string in mobi_locale array
 */
const char * mobi_get_locale_string(const uint32_t locale_number) {
    uint8_t lang_code = locale_number & 0xffU;

@@ -330,7 +330,7 @@ void print_summary(const MOBIData *m) {
            *m->mh->dict_input_lang && *m->mh->dict_output_lang) {
            const char *locale_in = mobi_get_locale_string(*m->mh->dict_input_lang);
            const char *locale_out = mobi_get_locale_string(*m->mh->dict_output_lang);
            printf("": %s => %s"", locale_in, locale_out);
        }
        printf(""\n"");
    }

","1
ChangeLog
@@ -1,3 +1,4 @@
2022-04-27: Fix undefined behavior when passing null to strdup
2022-04-27: Fix wrong boundary checks in inflections parser resulting in stack buffer over-read with corrupt input
2022-04-26: Fix text formatting
2022-04-26: Fix array boundary check when parsing inflections which could result in buffer over-read with corrupt input
30
src/opf.c
@@ -1152,24 +1152,30 @@ MOBI_RET mobi_build_opf_metadata(OPF *opf,  const MOBIData *m, const MOBIRawml *
    if (mobi_is_dictionary(m)) {
        if (opf->metadata->x_meta->dictionary_in_lang == NULL) {
            if (m->mh && m->mh->dict_input_lang) {
                opf->metadata->x_meta->dictionary_in_lang = calloc(OPF_META_MAX_TAGS, sizeof(char*));
                if (opf->metadata->x_meta->dictionary_in_lang == NULL) {
                    debug_print(""%s\n"", ""Memory allocation failed"");
                    return MOBI_MALLOC_FAILED;
                }
                uint32_t dict_lang_in = *m->mh->dict_input_lang;
                opf->metadata->x_meta->dictionary_in_lang[0] = strdup(mobi_get_locale_string(dict_lang_in));
                const char *lang = mobi_get_locale_string(dict_lang_in);
                if (lang) {
                    opf->metadata->x_meta->dictionary_in_lang = calloc(OPF_META_MAX_TAGS, sizeof(char*));
                    if (opf->metadata->x_meta->dictionary_in_lang == NULL) {
                        debug_print(""%s\n"", ""Memory allocation failed"");
                        return MOBI_MALLOC_FAILED;
                    }
                    opf->metadata->x_meta->dictionary_in_lang[0] = strdup(lang);
                }
            }
        }
        if (opf->metadata->x_meta->dictionary_out_lang == NULL) {
            if (m->mh && m->mh->dict_output_lang) {
                opf->metadata->x_meta->dictionary_out_lang = calloc(OPF_META_MAX_TAGS, sizeof(char*));
                if (opf->metadata->x_meta->dictionary_out_lang == NULL) {
                    debug_print(""%s\n"", ""Memory allocation failed"");
                    return MOBI_MALLOC_FAILED;
                uint32_t dict_lang_out = *m->mh->dict_output_lang;
                const char *lang = mobi_get_locale_string(dict_lang_out);
                if (lang) {
                    opf->metadata->x_meta->dictionary_out_lang = calloc(OPF_META_MAX_TAGS, sizeof(char*));
                    if (opf->metadata->x_meta->dictionary_out_lang == NULL) {
                        debug_print(""%s\n"", ""Memory allocation failed"");
                        return MOBI_MALLOC_FAILED;
                    }
                    opf->metadata->x_meta->dictionary_out_lang[0] = strdup(lang);
                }
                uint32_t dict_lang_in = *m->mh->dict_output_lang;
                opf->metadata->x_meta->dictionary_out_lang[0] = strdup(mobi_get_locale_string(dict_lang_in));
            }
        }
        if (rawml->orth->orth_index_name) {
2
src/util.c
@@ -641,7 +641,7 @@ static const char *mobi_locale[MOBI_LANG_MAX][MOBI_REGION_MAX] = {
 See mobi_locale array.
   @param[in] locale_number Mobipocket locale number (as stored in MOBI header)
 @return Pointer to locale string in mobi_locale array
 @return Pointer to locale string in mobi_locale array or NULL on error
 */
const char * mobi_get_locale_string(const uint32_t locale_number) {
    uint8_t lang_code = locale_number & 0xffU;
2
tools/common.c
@@ -330,7 +330,7 @@ void print_summary(const MOBIData *m) {
            *m->mh->dict_input_lang && *m->mh->dict_output_lang) {
            const char *locale_in = mobi_get_locale_string(*m->mh->dict_input_lang);
            const char *locale_out = mobi_get_locale_string(*m->mh->dict_output_lang);
            printf("": %s => %s"", locale_in, locale_out);
            printf("": %s => %s"", locale_in ? locale_in : ""unknown"", locale_out ? locale_out : ""unknown"");
        }
        printf(""\n"");
    }"
https://huntr.dev/bounties/cb574ce1-fbf7-42ea-9e6a-91e17adecdc3/,Buffer Over-read in bfabiszewski/libmobi,Stack-based Buffer Overflow at index.c:991,CVE-2022-1533,CWE-126: Buffer Over-read,https://www.github.com/bfabiszewski/libmobi/commit/eafc415bc6067e72577f70d6dd5acbf057ce6e6f,"@@ -1,3 +1,4 @@

2022-04-26: Fix text formatting
2022-04-26: Fix array boundary check when parsing inflections which could result in buffer over-read with corrupt input
2022-04-23: Fix formatting

@@ -961,17 +961,13 @@ MOBI_RET mobi_decode_infl(unsigned char *decoded, int *decoded_size, const unsig
            }
            pos -= c - 10;
            dir = 0;
            if (pos < 0 || pos > *decoded_size) {
                debug_print(""Position setting failed (%s)\n"", decoded);
                return MOBI_DATA_CORRUPT;
            }
        }
        else {
            if (mod == 'i') {
                const unsigned char *s = decoded + pos;
                unsigned char *d = decoded + pos + 1;
                const int l = *decoded_size - pos;
                if (l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) {
                    debug_print(""Out of buffer in %s at pos: %i\n"", decoded, pos);
                    return MOBI_DATA_CORRUPT;
                }
@@ -984,7 +980,7 @@ MOBI_RET mobi_decode_infl(unsigned char *decoded, int *decoded_size, const unsig
                const unsigned char *s = decoded + pos + 1;
                unsigned char *d = decoded + pos;
                const int l = *decoded_size - pos;
                if (l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) {
                    debug_print(""Out of buffer in %s at pos: %i\n"", decoded, pos);
                    return MOBI_DATA_CORRUPT;
                }

","1
ChangeLog
@@ -1,3 +1,4 @@
2022-04-27: Fix wrong boundary checks in inflections parser resulting in stack buffer over-read with corrupt input
2022-04-26: Fix text formatting
2022-04-26: Fix array boundary check when parsing inflections which could result in buffer over-read with corrupt input
2022-04-23: Fix formatting
8
src/index.c
@@ -961,17 +961,13 @@ MOBI_RET mobi_decode_infl(unsigned char *decoded, int *decoded_size, const unsig
            }
            pos -= c - 10;
            dir = 0;
            if (pos < 0 || pos > *decoded_size) {
                debug_print(""Position setting failed (%s)\n"", decoded);
                return MOBI_DATA_CORRUPT;
            }
        }
        else {
            if (mod == 'i') {
                const unsigned char *s = decoded + pos;
                unsigned char *d = decoded + pos + 1;
                const int l = *decoded_size - pos;
                if (l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) {
                if (pos < 0 || l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) {
                    debug_print(""Out of buffer in %s at pos: %i\n"", decoded, pos);
                    return MOBI_DATA_CORRUPT;
                }
@@ -984,7 +980,7 @@ MOBI_RET mobi_decode_infl(unsigned char *decoded, int *decoded_size, const unsig
                const unsigned char *s = decoded + pos + 1;
                unsigned char *d = decoded + pos;
                const int l = *decoded_size - pos;
                if (l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) {
                if (pos < 0 || l < 0 || s + l > decoded + INDX_INFLBUF_SIZEMAX) {
                    debug_print(""Out of buffer in %s at pos: %i\n"", decoded, pos);
                    return MOBI_DATA_CORRUPT;
                }"
https://huntr.dev/bounties/9a90ffa1-38f5-4685-9c00-68ba9068ce3d/,Buffer Over-read at parse_rawml.c:1416 in bfabiszewski/libmobi,Heap-based Buffer Overflow at parse_rawml.c:1416,CVE-2022-1534,CWE-126: Buffer Over-read,https://www.github.com/bfabiszewski/libmobi/commit/fb1ab50e448ddbed746fd27ae07469bc506d838b,"@@ -1,8 +1,9 @@

2022-04-23: Fix formatting
2022-04-23: Fix checking boundary of deobfuscation key which could cause buffer over-read with corrupt data
2022-04-23: Fix issue with corrupt data with empty lookup string which could lead to read beyond buffer
2022-04-23: Fix faulty checks for array boundary which caused buffer over-read
2022-04-23: Fix issue with corrupt files with tagvalues_count = 0 that caused heap buffer over-read
2022-04-23: Fix issues when mobi_buffer_getpointer returns null. With corrupt data this could lead to out-of-bounds read
2022-04-13: Add packaging status [skip ci]
2022-04-10: Make random generation return proper error codes

@@ -1413,6 +1413,10 @@ MOBI_RET mobi_reconstruct_infl(char *outstring, const MOBIIndx *infl, const MOBI

            unsigned char decoded[INDX_INFLBUF_SIZEMAX + 1];
            memset(decoded, 0, INDX_INFLBUF_SIZEMAX + 1);




            unsigned char *rule = (unsigned char *) infl->entries[parts[j]].label;
            memcpy(decoded, label, label_length);
            int decoded_length = (int) label_length;

","5
ChangeLog
@@ -1,8 +1,9 @@
2022-04-26: Fix array boundary check when parsing inflections which could result in buffer over-read with corrupt input
2022-04-23: Fix formatting
2022-04-23: Fix checking boundary of deobfuscation key which could cause buffer over-read with corrupt data
2022-04-23: Fix issue with corrupt data with empty lookup string which could lead to read beyond buffer
2022-04-23: Fix faulty checks for array boundary which caused buffer over-read
2022-04-23: Fix issue with corrupt files with tagvalues_count = 0 that caused heap buffer over-read
2022-04-23: Fix faulty checks for array boundary which caused buffer over-read with corrupt input
2022-04-23: Fix issue with corrupt files with tagvalues_count = 0 that caused null pointer dereference
2022-04-23: Fix issues when mobi_buffer_getpointer returns null. With corrupt data this could lead to out-of-bounds read
2022-04-13: Add packaging status [skip ci]
2022-04-10: Make random generation return proper error codes
4
src/parse_rawml.c
@@ -1413,6 +1413,10 @@ MOBI_RET mobi_reconstruct_infl(char *outstring, const MOBIIndx *infl, const MOBI

            unsigned char decoded[INDX_INFLBUF_SIZEMAX + 1];
            memset(decoded, 0, INDX_INFLBUF_SIZEMAX + 1);
            if (parts[j] >= infl->entries_count) {
                debug_print(""%s\n"", ""Invalid entry offset"");
                return MOBI_DATA_CORRUPT;
            }
            unsigned char *rule = (unsigned char *) infl->entries[parts[j]].label;
            memcpy(decoded, label, label_length);
            int decoded_length = (int) label_length;"
https://huntr.dev/bounties/104d8c5d-cac5-4baa-9ac9-291ea0bcab95/,chafa: NULL Pointer Dereference in function gif_internal_decode_frame at libnsgif.c:599 allows attackers to cause a denial of service (crash) via a crafted input file. in hpjansson/chafa,git clone https://github.com/hpjansson/chafa.git,CVE-2022-1507,CWE-476: NULL Pointer Dereference,https://www.github.com/hpjansson/chafa/commit/e4b777c7b7c144cd16a0ea96108267b1004fe6c9,"@@ -595,6 +595,12 @@ gif_internal_decode_frame(gif_animation *gif,
        unsigned int x, y, decode_y, burst_bytes;
        register unsigned char colour;







        /* Ensure this frame is supposed to be decoded */
        if (gif->frames[frame].display == false) {
                return GIF_OK;

","6
libnsgif/libnsgif.c
@@ -595,6 +595,12 @@ gif_internal_decode_frame(gif_animation *gif,
        unsigned int x, y, decode_y, burst_bytes;
        register unsigned char colour;

        /* If the GIF has no frame data, frame holders will not be allocated in
         * gif_initialise() */
        if (gif->frames == NULL) {
                return GIF_INSUFFICIENT_DATA;
        }

        /* Ensure this frame is supposed to be decoded */
        if (gif->frames[frame].display == false) {
                return GIF_OK;"
https://huntr.dev/bounties/c8f4c2de-7d96-4ad4-857a-c099effca2d6/,Out-of-bounds Read in r_bin_java_bootstrap_methods_attr_new function in radareorg/radare2,Out-of-bounds (OOB) read vulnerability exists in r_bin_java_bootstrap_methods_attr_new function in Radare2 5.6.9.,CVE-2022-1452,CWE-125: Out-of-bounds Read,https://www.github.com/radareorg/radare2/commit/ecc44b6a2f18ee70ac133365de0e509d26d5e168,"@@ -6933,6 +6933,10 @@ R_API RBinJavaAttrInfo *r_bin_java_bootstrap_methods_attr_new(RBinJavaObj *bin,
 offset += 6;
 if (attr) {
  attr->type = R_BIN_JAVA_ATTR_TYPE_BOOTSTRAP_METHODS_ATTR;




  attr->info.bootstrap_methods_attr.num_bootstrap_methods = R_BIN_JAVA_USHORT (buffer, offset);
  offset += 2;
  attr->info.bootstrap_methods_attr.bootstrap_methods = r_list_newf (r_bin_java_bootstrap_method_free);

","4
shlr/java/class.c
@@ -6933,6 +6933,10 @@ R_API RBinJavaAttrInfo *r_bin_java_bootstrap_methods_attr_new(RBinJavaObj *bin,
 offset += 6;
 if (attr) {
  attr->type = R_BIN_JAVA_ATTR_TYPE_BOOTSTRAP_METHODS_ATTR;
  if (offset + 8 > sz)  {
   free (attr);
   return NULL;
  }
  attr->info.bootstrap_methods_attr.num_bootstrap_methods = R_BIN_JAVA_USHORT (buffer, offset);
  offset += 2;
  attr->info.bootstrap_methods_attr.bootstrap_methods = r_list_newf (r_bin_java_bootstrap_method_free);"
https://huntr.dev/bounties/229a2e0d-9e5c-402f-9a24-57fa2eb1aaa7/,Out-of-bounds Read in r_bin_java_constant_value_attr_new function in radareorg/radare2,Out-of-bounds (OOB) read vulnerability exists in r_bin_java_constant_value_attr_new function in Radare2 5.6.9.,CVE-2022-1451,CWE-788: Access of Memory Location After End of Buffer,https://www.github.com/radareorg/radare2/commit/0927ed3ae99444e7b47b84e43118deb10fe37529,"@@ -1957,10 +1957,10 @@ R_API RBinJavaAttrInfo *r_bin_java_get_attr_from_field(RBinJavaField *field, R_B
}

R_API ut8 *r_bin_java_get_attr_buf(RBinJavaObj *bin, ut64 sz, const ut64 offset, const ut8 *buf, const ut64 len) {
 ut8 *attr_buf = NULL;
 int pending = len - offset;
 const ut8 *a_buf = offset + buf;
 attr_buf = (ut8 *) calloc (pending + 1, 1);
 if (!attr_buf) {
  eprintf (""Unable to allocate enough bytes (0x%04""PFMT64x
   "") to read in the attribute.\n"", sz);
@@ -3559,7 +3559,9 @@ R_API RBinJavaAttrInfo *r_bin_java_constant_value_attr_new(RBinJavaObj *bin, ut8
 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 if (attr) {
  attr->type = R_BIN_JAVA_ATTR_TYPE_CONST_VALUE_ATTR;
  attr->info.constant_value_attr.constantvalue_idx = R_BIN_JAVA_USHORT (buffer, offset);


  offset += 2;
  attr->size = offset;
 }
@@ -7079,9 +7081,11 @@ R_API ut64 r_bin_java_rtv_annotations_attr_calc_size(RBinJavaAttrInfo *attr) {

R_API RBinJavaAttrInfo *r_bin_java_rti_annotations_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut32 i = 0;
 RBinJavaAttrInfo *attr = NULL;
 ut64 offset = 0;
 attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);



 offset += 6;
 if (attr) {
  attr->type = R_BIN_JAVA_ATTR_TYPE_RUNTIME_INVISIBLE_ANNOTATION_ATTR;

","14
shlr/java/class.c
@@ -1957,10 +1957,10 @@ R_API RBinJavaAttrInfo *r_bin_java_get_attr_from_field(RBinJavaField *field, R_B
}

R_API ut8 *r_bin_java_get_attr_buf(RBinJavaObj *bin, ut64 sz, const ut64 offset, const ut8 *buf, const ut64 len) {
 ut8 *attr_buf = NULL;
 // XXX this pending is wrong and too expensive
 int pending = len - offset;
 const ut8 *a_buf = offset + buf;
 attr_buf = (ut8 *) calloc (pending + 1, 1);
 ut8 *attr_buf = (ut8 *) calloc (pending + 1, 1);
 if (!attr_buf) {
  eprintf (""Unable to allocate enough bytes (0x%04""PFMT64x
   "") to read in the attribute.\n"", sz);
@@ -3559,7 +3559,9 @@ R_API RBinJavaAttrInfo *r_bin_java_constant_value_attr_new(RBinJavaObj *bin, ut8
 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 if (attr) {
  attr->type = R_BIN_JAVA_ATTR_TYPE_CONST_VALUE_ATTR;
  attr->info.constant_value_attr.constantvalue_idx = R_BIN_JAVA_USHORT (buffer, offset);
  if (offset + 4 < sz) {
   attr->info.constant_value_attr.constantvalue_idx = R_BIN_JAVA_USHORT (buffer, offset);
  }
  offset += 2;
  attr->size = offset;
 }
@@ -7079,9 +7081,11 @@ R_API ut64 r_bin_java_rtv_annotations_attr_calc_size(RBinJavaAttrInfo *attr) {

R_API RBinJavaAttrInfo *r_bin_java_rti_annotations_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut32 i = 0;
 RBinJavaAttrInfo *attr = NULL;
 ut64 offset = 0;
 attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 if (buf_offset + 32 >= sz) {
  return NULL;
 }
 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 offset += 6;
 if (attr) {
  attr->type = R_BIN_JAVA_ATTR_TYPE_RUNTIME_INVISIBLE_ANNOTATION_ATTR;"
https://huntr.dev/bounties/b438a940-f8a4-4872-b030-59bdd1ab72aa/,heap-use-after-free in radareorg/radare2,"Whilst experimenting with radare2, built from version 5.6.8, we are able to induce a vulnerability at new_rbtree.c:411 in function r_rbnode_next , using radare2 as a harness.",CVE-2022-1444,CWE-416: Use After Free,https://www.github.com/radareorg/radare2/commit/14189710859c27981adb4c2c2aed2863c1859ec5,"@@ -138,9 +138,9 @@ R_API bool r_crbtree_insert(RRBTree *tree, void *data, RRBComparator cmp, void *
 r_return_val_if_fail (tree && data && cmp, false);
 bool inserted = false;

 if (tree->root == NULL) {
  tree->root = _node_new (data, NULL);
  if (tree->root == NULL) {
   return false;
  }
  inserted = true;

","4
libr/util/new_rbtree.c
@@ -138,9 +138,9 @@ R_API bool r_crbtree_insert(RRBTree *tree, void *data, RRBComparator cmp, void *
 r_return_val_if_fail (tree && data && cmp, false);
 bool inserted = false;

 if (tree->root == NULL) {
 if (!tree->root) {
  tree->root = _node_new (data, NULL);
  if (tree->root == NULL) {
  if (!tree->root) {
   return false;
  }
  inserted = true;"
https://huntr.dev/bounties/1f3dcd98-436d-49e2-9274-c649bc011d65/,A null pointer reference in libmobi. in bfabiszewski/libmobi,"The vulnerability at src/index.c#L 1054, function mobi_trie_insert_infl. At line 1063 shown as below, function mobi_get_)cncx_string_flat uses len as parameter, len got from t.tagvalues. While at line 1060, program doesn’t check the initial value of tagvalues_count, when the for loop begins with k=0, the program will get null pointer dereference.",,CWE-476: NULL Pointer Dereference,https://www.github.com/bfabiszewski/libmobi/commit/ce0ab6586069791b1e8e2a42f44318e581c39939,"@@ -1,3 +1,4 @@

2022-04-23: Fix issues when mobi_buffer_getpointer returns null. With corrupt data this could lead to out-of-bounds read
2022-04-13: Add packaging status [skip ci]
2022-04-10: Make random generation return proper error codes

@@ -1057,7 +1057,7 @@ MOBI_RET mobi_trie_insert_infl(MOBITrie **root, const MOBIIndx *indx, size_t i)
    for (size_t j = 0; j < e.tags_count; j++) {
        MOBIIndexTag t = e.tags[j];
        if (t.tagid == INDX_TAGARR_INFL_PARTS_V1) {
            for (size_t k = 0; k < t.tagvalues_count - 1; k += 2) {
                uint32_t len = t.tagvalues[k];
                uint32_t offset = t.tagvalues[k + 1];
                char *base = mobi_get_cncx_string_flat(indx->cncx_record, offset, len);

","1
ChangeLog
@@ -1,3 +1,4 @@
2022-04-23: Fix issue with corrupt files with tagvalues_count = 0 that caused heap buffer over-read
2022-04-23: Fix issues when mobi_buffer_getpointer returns null. With corrupt data this could lead to out-of-bounds read
2022-04-13: Add packaging status [skip ci]
2022-04-10: Make random generation return proper error codes
2
src/index.c
@@ -1057,7 +1057,7 @@ MOBI_RET mobi_trie_insert_infl(MOBITrie **root, const MOBIIndx *indx, size_t i)
    for (size_t j = 0; j < e.tags_count; j++) {
        MOBIIndexTag t = e.tags[j];
        if (t.tagid == INDX_TAGARR_INFL_PARTS_V1) {
            for (size_t k = 0; k < t.tagvalues_count - 1; k += 2) {
            for (size_t k = 0; k + 1 < t.tagvalues_count; k += 2) {
                uint32_t len = t.tagvalues[k];
                uint32_t offset = t.tagvalues[k + 1];
                char *base = mobi_get_cncx_string_flat(indx->cncx_record, offset, len);"
https://huntr.dev/bounties/04ae0f4b-77a1-42dc-978a-7bb5e6c93356/,Untrusted Search Path in ventoy/ventoy,"A current working directory type of DLL hijacking vulnerability is found in all executbales in ventoy-1.0.70-windows.zip, including:",,CWE-426: Untrusted Search Path,https://www.github.com/ventoy/ventoy/commit/dcc588967716395dfdb51be9dcd24e64145edd1b,"@@ -464,6 +464,60 @@ static int ParseCmdLine(LPSTR lpCmdLine, char *ip, char *port)
 return 0;
}























































int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, INT nCmdShow)
{
    int rc;
@@ -472,6 +526,8 @@ int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLi

    UNREFERENCED_PARAMETER(hPrevInstance);



    if (GetUserDefaultUILanguage() == 0x0804)
    {
        g_sysinfo.language = LANGUAGE_CN;

@@ -14,18 +14,19 @@
    <ProjectGuid>{321D6EE2-2AB3-4103-9F05-EC4EC67A75E1}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>VentoyPlugson</RootNamespace>

  </PropertyGroup>
  <Import Project=""$(VCTargetsPath)\Microsoft.Cpp.Default.props"" />
  <PropertyGroup Condition=""'$(Configuration)|$(Platform)'=='Debug|Win32'"" Label=""Configuration"">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition=""'$(Configuration)|$(Platform)'=='Release|Win32'"" Label=""Configuration"">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
@@ -61,6 +62,7 @@
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>

    </Link>
    <Manifest>
      <AdditionalManifestFiles>$(ProjectDir)\Res\Plugson32.manifest %(AdditionalManifestFiles)</AdditionalManifestFiles>
@@ -84,6 +86,7 @@
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>

    </Link>
    <Manifest>
      <AdditionalManifestFiles>$(ProjectDir)\Res\Plugson32.manifest %(AdditionalManifestFiles)</AdditionalManifestFiles>
@@ -151,7 +154,7 @@
  <ItemGroup>
    <ResourceCompile Include=""VentoyPlugson.rc"" />
  </ItemGroup>
  <ItemGroup>   
    <Image Include=""Res\plugson.ico"" />
  </ItemGroup>
  <Import Project=""$(VCTargetsPath)\Microsoft.Cpp.targets"" />

@@ -167,7 +167,7 @@
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <Image Include=""Res\refresh.ico"">
      <Filter>资源文件</Filter>
    </Image>
  </ItemGroup>

@@ -831,13 +831,67 @@ static int ParseCmdLine(LPSTR lpCmdLine)
    return argc;
}





















































int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, INT nCmdShow)
{
    DWORD dwAttrib;
 HANDLE hMutex;

    UNREFERENCED_PARAMETER(hPrevInstance);



    if (GetUserDefaultUILanguage() == 0x0804)
    {
        g_msg_lang = g_msg_cn;

@@ -14,18 +14,19 @@
    <ProjectGuid>{9987D9FE-1A40-4C5F-835C-D66B0FEADA26}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>VentoyVlnk</RootNamespace>

  </PropertyGroup>
  <Import Project=""$(VCTargetsPath)\Microsoft.Cpp.Default.props"" />
  <PropertyGroup Condition=""'$(Configuration)|$(Platform)'=='Debug|Win32'"" Label=""Configuration"">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition=""'$(Configuration)|$(Platform)'=='Release|Win32'"" Label=""Configuration"">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
@@ -61,6 +62,7 @@
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>

    </Link>
    <Manifest>
      <AdditionalManifestFiles>$(ProjectDir)\Res\Vlnk32.manifest %(AdditionalManifestFiles)</AdditionalManifestFiles>
@@ -84,6 +86,7 @@
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>

    </Link>
    <Manifest>
      <AdditionalManifestFiles>$(ProjectDir)\Res\Vlnk32.manifest %(AdditionalManifestFiles)</AdditionalManifestFiles>

","56
Plugson/src/main_windows.c
@@ -464,6 +464,60 @@ static int ParseCmdLine(LPSTR lpCmdLine, char *ip, char *port)
 return 0;
}



//
//copy from Rufus
//
#include <delayimp.h>
// For delay-loaded DLLs, use LOAD_LIBRARY_SEARCH_SYSTEM32 to avoid DLL search order hijacking.
FARPROC WINAPI dllDelayLoadHook(unsigned dliNotify, PDelayLoadInfo pdli)
{
 if (dliNotify == dliNotePreLoadLibrary) {
  // Windows 7 without KB2533623 does not support the LOAD_LIBRARY_SEARCH_SYSTEM32 flag.
  // That is is OK, because the delay load handler will interrupt the NULL return value
  // to mean that it should perform a normal LoadLibrary.
  return (FARPROC)LoadLibraryExA(pdli->szDll, NULL, LOAD_LIBRARY_SEARCH_SYSTEM32);
 }
 return NULL;
}

#if defined(_MSC_VER)
// By default the Windows SDK headers have a `const` while MinGW does not.
const
#endif
PfnDliHook __pfnDliNotifyHook2 = dllDelayLoadHook;

typedef BOOL(WINAPI* SetDefaultDllDirectories_t)(DWORD);
static void DllProtect(void)
{
 SetDefaultDllDirectories_t pfSetDefaultDllDirectories = NULL;

 // Disable loading system DLLs from the current directory (sideloading mitigation)
 // PS: You know that official MSDN documentation for SetDllDirectory() that explicitly
 // indicates that ""If the parameter is an empty string (""""), the call removes the current
 // directory from the default DLL search order""? Yeah, that doesn't work. At all.
 // Still, we invoke it, for platforms where the following call might actually work...
 SetDllDirectoryA("""");

 // For libraries on the KnownDLLs list, the system will always load them from System32.
 // For other DLLs we link directly to, we can delay load the DLL and use a delay load
 // hook to load them from System32. Note that, for this to work, something like:
 // 'somelib.dll;%(DelayLoadDLLs)' must be added to the 'Delay Loaded Dlls' option of
 // the linker properties in Visual Studio (which means this won't work with MinGW).
 // For all other DLLs, use SetDefaultDllDirectories(LOAD_LIBRARY_SEARCH_SYSTEM32).
 // Finally, we need to perform the whole gymkhana below, where we can't call on
 // SetDefaultDllDirectories() directly, because Windows 7 doesn't have the API exposed.
 // Also, no, Coverity, we never need to care about freeing kernel32 as a library.
 // coverity[leaked_storage]

 pfSetDefaultDllDirectories = (SetDefaultDllDirectories_t)
  GetProcAddress(LoadLibraryW(L""kernel32.dll""), ""SetDefaultDllDirectories"");
 if (pfSetDefaultDllDirectories != NULL)
  pfSetDefaultDllDirectories(LOAD_LIBRARY_SEARCH_SYSTEM32);
}


int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, INT nCmdShow)
{
    int rc;
@@ -472,6 +526,8 @@ int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLi

    UNREFERENCED_PARAMETER(hPrevInstance);

 DllProtect();

    if (GetUserDefaultUILanguage() == 0x0804)
    {
        g_sysinfo.language = LANGUAGE_CN;
BIN +44.5 KB (110%)
Plugson/vs/VentoyPlugson/Release/VentoyPlugson.exe
Binary file not shown.
9
Plugson/vs/VentoyPlugson/VentoyPlugson/VentoyPlugson.vcxproj
@@ -14,18 +14,19 @@
    <ProjectGuid>{321D6EE2-2AB3-4103-9F05-EC4EC67A75E1}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>VentoyPlugson</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project=""$(VCTargetsPath)\Microsoft.Cpp.Default.props"" />
  <PropertyGroup Condition=""'$(Configuration)|$(Platform)'=='Debug|Win32'"" Label=""Configuration"">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition=""'$(Configuration)|$(Platform)'=='Release|Win32'"" Label=""Configuration"">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
@@ -61,6 +62,7 @@
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
      <DelayLoadDLLs>gdi32.dll;winspool.dll;comdlg32.dll;advapi32.dll;shell32.dll;ole32.dll;oleaut32.dll;uuid.dll;odbc32.dll;odbccp32.dll</DelayLoadDLLs>
    </Link>
    <Manifest>
      <AdditionalManifestFiles>$(ProjectDir)\Res\Plugson32.manifest %(AdditionalManifestFiles)</AdditionalManifestFiles>
@@ -84,6 +86,7 @@
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
      <DelayLoadDLLs>gdi32.dll;winspool.dll;comdlg32.dll;advapi32.dll;shell32.dll;ole32.dll;oleaut32.dll;uuid.dll;odbc32.dll;odbccp32.dll</DelayLoadDLLs>
    </Link>
    <Manifest>
      <AdditionalManifestFiles>$(ProjectDir)\Res\Plugson32.manifest %(AdditionalManifestFiles)</AdditionalManifestFiles>
@@ -151,7 +154,7 @@
  <ItemGroup>
    <ResourceCompile Include=""VentoyPlugson.rc"" />
  </ItemGroup>
  <ItemGroup>   
  <ItemGroup>
    <Image Include=""Res\plugson.ico"" />
  </ItemGroup>
  <Import Project=""$(VCTargetsPath)\Microsoft.Cpp.targets"" />
2
Plugson/vs/VentoyPlugson/VentoyPlugson/VentoyPlugson.vcxproj.filters
@@ -167,7 +167,7 @@
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <Image Include=""Res\refresh.ico"">
    <Image Include=""Res\plugson.ico"">
      <Filter>资源文件</Filter>
    </Image>
  </ItemGroup>
54
Vlnk/src/main_windows.c
@@ -831,13 +831,67 @@ static int ParseCmdLine(LPSTR lpCmdLine)
    return argc;
}


//
//copy from Rufus
//
#include <delayimp.h>
// For delay-loaded DLLs, use LOAD_LIBRARY_SEARCH_SYSTEM32 to avoid DLL search order hijacking.
FARPROC WINAPI dllDelayLoadHook(unsigned dliNotify, PDelayLoadInfo pdli)
{
    if (dliNotify == dliNotePreLoadLibrary) {
        // Windows 7 without KB2533623 does not support the LOAD_LIBRARY_SEARCH_SYSTEM32 flag.
        // That is is OK, because the delay load handler will interrupt the NULL return value
        // to mean that it should perform a normal LoadLibrary.
        return (FARPROC)LoadLibraryExA(pdli->szDll, NULL, LOAD_LIBRARY_SEARCH_SYSTEM32);
    }
    return NULL;
}

#if defined(_MSC_VER)
// By default the Windows SDK headers have a `const` while MinGW does not.
const
#endif
PfnDliHook __pfnDliNotifyHook2 = dllDelayLoadHook;

typedef BOOL(WINAPI *SetDefaultDllDirectories_t)(DWORD);
static void DllProtect(void)
{
    SetDefaultDllDirectories_t pfSetDefaultDllDirectories = NULL;

    // Disable loading system DLLs from the current directory (sideloading mitigation)
    // PS: You know that official MSDN documentation for SetDllDirectory() that explicitly
    // indicates that ""If the parameter is an empty string (""""), the call removes the current
    // directory from the default DLL search order""? Yeah, that doesn't work. At all.
    // Still, we invoke it, for platforms where the following call might actually work...
    SetDllDirectoryA("""");

    // For libraries on the KnownDLLs list, the system will always load them from System32.
    // For other DLLs we link directly to, we can delay load the DLL and use a delay load
    // hook to load them from System32. Note that, for this to work, something like:
    // 'somelib.dll;%(DelayLoadDLLs)' must be added to the 'Delay Loaded Dlls' option of
    // the linker properties in Visual Studio (which means this won't work with MinGW).
    // For all other DLLs, use SetDefaultDllDirectories(LOAD_LIBRARY_SEARCH_SYSTEM32).
    // Finally, we need to perform the whole gymkhana below, where we can't call on
    // SetDefaultDllDirectories() directly, because Windows 7 doesn't have the API exposed.
    // Also, no, Coverity, we never need to care about freeing kernel32 as a library.
    // coverity[leaked_storage]

    pfSetDefaultDllDirectories = (SetDefaultDllDirectories_t)
        GetProcAddress(LoadLibraryW(L""kernel32.dll""), ""SetDefaultDllDirectories"");
    if (pfSetDefaultDllDirectories != NULL)
        pfSetDefaultDllDirectories(LOAD_LIBRARY_SEARCH_SYSTEM32);
}

int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, INT nCmdShow)
{
    DWORD dwAttrib;
 HANDLE hMutex;

    UNREFERENCED_PARAMETER(hPrevInstance);

    DllProtect();

    if (GetUserDefaultUILanguage() == 0x0804)
    {
        g_msg_lang = g_msg_cn;
BIN +29 KB (120%)
Vlnk/vs/VentoyVlnk/Release/VentoyVlnk.exe
Binary file not shown.
7
Vlnk/vs/VentoyVlnk/VentoyVlnk/VentoyVlnk.vcxproj
@@ -14,18 +14,19 @@
    <ProjectGuid>{9987D9FE-1A40-4C5F-835C-D66B0FEADA26}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>VentoyVlnk</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project=""$(VCTargetsPath)\Microsoft.Cpp.Default.props"" />
  <PropertyGroup Condition=""'$(Configuration)|$(Platform)'=='Debug|Win32'"" Label=""Configuration"">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition=""'$(Configuration)|$(Platform)'=='Release|Win32'"" Label=""Configuration"">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
@@ -61,6 +62,7 @@
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
      <DelayLoadDLLs>gdi32.dll;winspool.dll;comdlg32.dll;advapi32.dll;shell32.dll;ole32.dll;oleaut32.dll;uuid.dll;odbc32.dll;odbccp32.dll</DelayLoadDLLs>
    </Link>
    <Manifest>
      <AdditionalManifestFiles>$(ProjectDir)\Res\Vlnk32.manifest %(AdditionalManifestFiles)</AdditionalManifestFiles>
@@ -84,6 +86,7 @@
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
      <DelayLoadDLLs>gdi32.dll;winspool.dll;comdlg32.dll;advapi32.dll;shell32.dll;ole32.dll;oleaut32.dll;uuid.dll;odbc32.dll;odbccp32.dll</DelayLoadDLLs>
    </Link>
    <Manifest>
      <AdditionalManifestFiles>$(ProjectDir)\Res\Vlnk32.manifest %(AdditionalManifestFiles)</AdditionalManifestFiles>"
https://huntr.dev/bounties/af6c3e9e-b7df-4d80-b48f-77fdd17b4038/,Heap-based Buffer Overflow in radareorg/radare2,Heap-based buffer overflow in coresymbolication:272,CVE-2022-1437,CWE-122: Heap-based Buffer Overflow,https://www.github.com/radareorg/radare2/commit/669a404b6d98d5db409a5ebadae4e94b34ef5136,"@@ -269,6 +269,9 @@ RCoreSymCacheElement *r_coresym_cache_element_new(RBinFile *bf, RBuffer *buf, ut
  for (i = 0; i < hdr->n_sections && cursor < end; i++) {
   ut8 *sect_start = cursor;
   RCoreSymCacheElementSection *sect = &result->sections[i];



   sect->vaddr = sect->paddr = r_read_ble (cursor, false, bits);
   if (sect->vaddr < page_zero_size) {
    sect->vaddr += page_zero_size;
@@ -359,6 +362,10 @@ RCoreSymCacheElement *r_coresym_cache_element_new(RBinFile *bf, RBuffer *buf, ut
    continue;
   }
   string_origin = relative_to_strings? b + start_of_strings : cursor;




   lsym->flc.file = str_dup_safe (b, string_origin + file_name_off, end);
   if (!lsym->flc.file) {
    cursor += R_CS_EL_SIZE_LSYM;

@@ -353,28 +353,30 @@ static bool check_buffer(RBinFile *bf, RBuffer *b) {
}

static RList *symbols(RBinFile *bf) {
 RList *res = r_list_newf ((RListFree)r_bin_symbol_free);
 r_return_val_if_fail (res && bf->o && bf->o->bin_obj, res);
 RCoreSymCacheElement *element = bf->o->bin_obj;
 size_t i;
 HtUU *hash = ht_uu_new0 ();
 if (!hash) {
  return res;
 }

 bool found = false;
 for (i = 0; i < element->hdr->n_lined_symbols; i++) {
  RCoreSymCacheElementSymbol *sym = (RCoreSymCacheElementSymbol *)&element->lined_symbols[i];
  if (!sym) {
   break;
  }
  ht_uu_find (hash, sym->paddr, &found);
  if (found) {
   continue;
  }
  RBinSymbol *s = bin_symbol_from_symbol (element, sym);
  if (s) {
   r_list_append (res, s);
   ht_uu_insert (hash, sym->paddr, 1);


  }
 }
 if (element->symbols) {

","7
libr/bin/format/mach0/coresymbolication.c
@@ -269,6 +269,9 @@ RCoreSymCacheElement *r_coresym_cache_element_new(RBinFile *bf, RBuffer *buf, ut
  for (i = 0; i < hdr->n_sections && cursor < end; i++) {
   ut8 *sect_start = cursor;
   RCoreSymCacheElementSection *sect = &result->sections[i];
   if (cursor + (word_size * 4) > end) {
    goto beach;
   }
   sect->vaddr = sect->paddr = r_read_ble (cursor, false, bits);
   if (sect->vaddr < page_zero_size) {
    sect->vaddr += page_zero_size;
@@ -359,6 +362,10 @@ RCoreSymCacheElement *r_coresym_cache_element_new(RBinFile *bf, RBuffer *buf, ut
    continue;
   }
   string_origin = relative_to_strings? b + start_of_strings : cursor;
   if (!string_origin) {
    cursor += R_CS_EL_SIZE_LSYM;
    continue;
   }
   lsym->flc.file = str_dup_safe (b, string_origin + file_name_off, end);
   if (!lsym->flc.file) {
    cursor += R_CS_EL_SIZE_LSYM;
34
libr/bin/p/bin_symbols.c
@@ -353,28 +353,30 @@ static bool check_buffer(RBinFile *bf, RBuffer *b) {
}

static RList *symbols(RBinFile *bf) {
 RList *res = r_list_newf ((RListFree)r_bin_symbol_free);
 r_return_val_if_fail (res && bf->o && bf->o->bin_obj, res);
 r_return_val_if_fail (bf && bf->o && bf->o->bin_obj, NULL);
 RCoreSymCacheElement *element = bf->o->bin_obj;
 size_t i;
 HtUU *hash = ht_uu_new0 ();
 if (!hash) {
  return res;
  return NULL;
 }
 RList *res = r_list_newf ((RListFree)r_bin_symbol_free);
 bool found = false;
 for (i = 0; i < element->hdr->n_lined_symbols; i++) {
  RCoreSymCacheElementSymbol *sym = (RCoreSymCacheElementSymbol *)&element->lined_symbols[i];
  if (!sym) {
   break;
  }
  ht_uu_find (hash, sym->paddr, &found);
  if (found) {
   continue;
  }
  RBinSymbol *s = bin_symbol_from_symbol (element, sym);
  if (s) {
   r_list_append (res, s);
   ht_uu_insert (hash, sym->paddr, 1);
 if (element->lined_symbols) {
  for (i = 0; i < element->hdr->n_lined_symbols; i++) {
   RCoreSymCacheElementSymbol *sym = (RCoreSymCacheElementSymbol *)&element->lined_symbols[i];
   if (!sym) {
    break;
   }
   ht_uu_find (hash, sym->paddr, &found);
   if (found) {
    continue;
   }
   RBinSymbol *s = bin_symbol_from_symbol (element, sym);
   if (s) {
    r_list_append (res, s);
    ht_uu_insert (hash, sym->paddr, 1);
   }
  }
 }
 if (element->symbols) {"
https://huntr.dev/bounties/23b6f0a9-64f5-421e-a55f-b5b7a671f301/,Out-of-bounds Read in mrb_obj_is_kind_of in in mruby/mruby,Affected commit,CVE-2022-1427,CWE-125: Out-of-bounds Read,https://www.github.com/mruby/mruby/commit/a4d97934d51cb88954cc49161dc1d151f64afb6b,"@@ -1750,10 +1750,7 @@ mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)
        mrb_exc_set(mrb, exc);
        goto L_RAISE;
      }
      if (target_class->flags & MRB_FL_CLASS_IS_PREPENDED) {
        target_class = mrb_vm_ci_target_class(ci);
      }
      else if (target_class->tt == MRB_TT_MODULE) {
        target_class = mrb_vm_ci_target_class(ci);
        if (!target_class || target_class->tt != MRB_TT_ICLASS) {
          goto super_typeerror;

","5
src/vm.c
@@ -1750,10 +1750,7 @@ mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)
        mrb_exc_set(mrb, exc);
        goto L_RAISE;
      }
      if (target_class->flags & MRB_FL_CLASS_IS_PREPENDED) {
        target_class = mrb_vm_ci_target_class(ci);
      }
      else if (target_class->tt == MRB_TT_MODULE) {
      if ((target_class->flags & MRB_FL_CLASS_IS_PREPENDED) || target_class->tt == MRB_TT_MODULE) {
        target_class = mrb_vm_ci_target_class(ci);
        if (!target_class || target_class->tt != MRB_TT_ICLASS) {
          goto super_typeerror;"
https://huntr.dev/bounties/02b4b563-b946-4343-9092-38d1c5cd60c9/,Heap-based Buffer Overflow in radareorg/radare2,Heap-based Buffer Overflow in r_read_le32,CVE-2022-1383,CWE-122: Heap-based Buffer Overflow,https://www.github.com/radareorg/radare2/commit/1dd65336f0f0c351d6ea853efcf73cf9c0030862,"@@ -274,12 +274,12 @@ RCoreSymCacheElement *r_coresym_cache_element_new(RBinFile *bf, RBuffer *buf, ut
    sect->vaddr += page_zero_size;
   }
   cursor += word_size;
   if (cursor >= end) {
    break;
   }
   sect->size = r_read_ble (cursor, false, bits);
   cursor += word_size;
   if (cursor >= end) {
    break;
   }
   ut64 sect_name_off = r_read_ble (cursor, false, bits);
@@ -291,7 +291,11 @@ RCoreSymCacheElement *r_coresym_cache_element_new(RBinFile *bf, RBuffer *buf, ut
    cursor += word_size;
   }
   string_origin = relative_to_strings? b + start_of_strings : sect_start;
   sect->name = str_dup_safe (b, string_origin + (size_t)sect_name_off, end);




  }
 }
 if (hdr->n_symbols) {

","10
libr/bin/format/mach0/coresymbolication.c
@@ -274,12 +274,12 @@ RCoreSymCacheElement *r_coresym_cache_element_new(RBinFile *bf, RBuffer *buf, ut
    sect->vaddr += page_zero_size;
   }
   cursor += word_size;
   if (cursor >= end) {
   if (cursor + word_size >= end) {
    break;
   }
   sect->size = r_read_ble (cursor, false, bits);
   cursor += word_size;
   if (cursor >= end) {
   if (cursor + word_size >= end) {
    break;
   }
   ut64 sect_name_off = r_read_ble (cursor, false, bits);
@@ -291,7 +291,11 @@ RCoreSymCacheElement *r_coresym_cache_element_new(RBinFile *bf, RBuffer *buf, ut
    cursor += word_size;
   }
   string_origin = relative_to_strings? b + start_of_strings : sect_start;
   sect->name = str_dup_safe (b, string_origin + (size_t)sect_name_off, end);
   if (sect_name_off < (ut64)(size_t)(end - string_origin)) {
    sect->name = str_dup_safe (b, string_origin + sect_name_off, end);
   } else {
    sect->name = strdup ("""");
   }
  }
 }
 if (hdr->n_symbols) {"
https://huntr.dev/bounties/d8b6d239-6d7b-4783-b26b-5be848c01aa1/,NULL Pointer Dereference in radareorg/radare2,NULL pointer dereference in r_bin_ne_get_segments,CVE-2022-1382,CWE-476: NULL Pointer Dereference,https://www.github.com/radareorg/radare2/commit/48f0ea79f99174fb0a62cb2354e13496ce5b7c44,"@@ -77,7 +77,7 @@ static char *__func_name_from_ord(const char *module, ut16 ordinal) {

RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {
 int i;
 if (!bin) {
  return NULL;
 }
 RList *segments = r_list_newf (free);

","2
libr/bin/format/ne/ne.c
@@ -77,7 +77,7 @@ static char *__func_name_from_ord(const char *module, ut16 ordinal) {

RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {
 int i;
 if (!bin) {
 if (!bin || !bin->segment_entries) {
  return NULL;
 }
 RList *segments = r_list_newf (free);"
https://huntr.dev/bounties/cb8e860f-2214-4f48-933e-3ee88fdd738f/,Controlled heap buffer overflow in SDP packet parsing in gpac/gpac,A malicious server can trigger an out-of-bounds heap write via a specially crafted SDP packet due to no bounds check when parsing time zone information into the AdjustmentTime and AdjustmentOffset fields of GF_SDPTiming.,,CWE-122: Heap-based Buffer Overflow,https://www.github.com/gpac/gpac/commit/cfaea36eb0116f28b3ca46096b5ed932b5a8c600,"@@ -612,6 +612,7 @@ GF_Err gf_sdp_info_parse(GF_SDPInfo *sdp, char *sdp_text, u32 text_size)
    if (pos <= 0) break;
    timing->OffsetFromStart[timing->NbRepeatOffsets] = SDP_MakeSeconds(comp);
    timing->NbRepeatOffsets += 1;

   }
   break;
  case 'z':
@@ -625,6 +626,7 @@ GF_Err gf_sdp_info_parse(GF_SDPInfo *sdp, char *sdp_text, u32 text_size)
    pos = gf_token_get(LineBuf, pos, "" \t\r\n"", comp, 3000);
    timing->AdjustmentOffset[timing->NbZoneOffsets] = SDP_MakeSeconds(comp);
    timing->NbZoneOffsets += 1;

   }
   break;
  case 'k':

","2
src/ietf/sdp.c
@@ -612,6 +612,7 @@ GF_Err gf_sdp_info_parse(GF_SDPInfo *sdp, char *sdp_text, u32 text_size)
    if (pos <= 0) break;
    timing->OffsetFromStart[timing->NbRepeatOffsets] = SDP_MakeSeconds(comp);
    timing->NbRepeatOffsets += 1;
    if (timing->NbRepeatOffsets == GF_SDP_MAX_TIMEOFFSET) break;
   }
   break;
  case 'z':
@@ -625,6 +626,7 @@ GF_Err gf_sdp_info_parse(GF_SDPInfo *sdp, char *sdp_text, u32 text_size)
    pos = gf_token_get(LineBuf, pos, "" \t\r\n"", comp, 3000);
    timing->AdjustmentOffset[timing->NbZoneOffsets] = SDP_MakeSeconds(comp);
    timing->NbZoneOffsets += 1;
    if (timing->NbZoneOffsets == GF_SDP_MAX_TIMEOFFSET) break;
   }
   break;
  case 'k':"
https://huntr.dev/bounties/ec538fa4-06c6-4050-a141-f60153ddeaac/,Out-of-bounds Read in r_bin_ne_get_entrypoints function in radareorg/radare2,Out-of-bounds (OOB) read vulnerability exists in r_bin_ne_get_entrypoints function in Radare2 5.6.7,CVE-2022-1297,CWE-125: Out-of-bounds Read,https://www.github.com/radareorg/radare2/commit/0a557045476a2969c7079aec9eeb29d02f2809c6,"@@ -408,14 +408,21 @@ RList *r_bin_ne_get_entrypoints(r_bin_ne_obj_t *bin) {
    off += 2;
    ut8 segnum = *(bin->entry_table + off);
    off++;
    ut16 segoff = *(ut16 *)(bin->entry_table + off);
    if (segnum > 0) {



     entry->paddr = (ut64)bin->segment_entries[segnum - 1].offset * bin->alignment + segoff;
    }
   } else { // Fixed




    if (bundle_type < bin->ne_header->SegCount) {
     entry->paddr = (ut64)bin->segment_entries[bundle_type - 1].offset
      * bin->alignment + *(ut16 *)(bin->entry_table + off);
    }
   }
   off += 2;

","13
libr/bin/format/ne/ne.c
@@ -408,14 +408,21 @@ RList *r_bin_ne_get_entrypoints(r_bin_ne_obj_t *bin) {
    off += 2;
    ut8 segnum = *(bin->entry_table + off);
    off++;
    ut16 segoff = *(ut16 *)(bin->entry_table + off);
    if (segnum > 0) {
    if (off > bin->ne_header->EntryTableLength) {
     break;
    }
    ut16 segoff = r_read_le16 (bin->entry_table + off);
    if (segnum > 0 && segnum < bin->ne_header->SegCount) {
     entry->paddr = (ut64)bin->segment_entries[segnum - 1].offset * bin->alignment + segoff;
    }
   } else { // Fixed
    if (off + 2 >= bin->ne_header->EntryTableLength) {
     break;
    }
    ut16 delta = r_read_le16 (bin->entry_table + off);
    if (bundle_type < bin->ne_header->SegCount) {
     entry->paddr = (ut64)bin->segment_entries[bundle_type - 1].offset
      * bin->alignment + *(ut16 *)(bin->entry_table + off);
      * bin->alignment + delta;
    }
   }
   off += 2;"
https://huntr.dev/bounties/52b57274-0e1a-4d61-ab29-1373b555fea0/,Out-of-bounds read in `r_bin_ne_get_relocs` function in radareorg/radare2,Out-of-bounds (OOB) read vulnerability exists in r_bin_ne_get_relocs function in Radare2 5.6.7 due to a missing check on the index value.,CVE-2022-1296,CWE-125: Out-of-bounds Read,https://www.github.com/radareorg/radare2/commit/153bcdc29f11cd8c90e7d639a7405450f644ddb6,"@@ -1,7 +1,6 @@
/* radare - LGPL - Copyright 2019-2022 - GustavoLCR */

#include ""ne.h""
#define NE_BUG 0

static char *__get_target_os(r_bin_ne_obj_t *bin) {
 switch (bin->ne_header->targOS) {
@@ -505,25 +504,18 @@ RList *r_bin_ne_get_relocs(r_bin_ne_obj_t *bin) {
     free (reloc);
     break;
    }
    char *name;
#if NE_BUG
    if (rel.index > 0 && rel.index < bin->ne_header->ModRefs) {
     offset = modref[rel.index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;
     name = __read_nonnull_str_at (bin->buf, offset);
    } else {
     name = r_str_newf (""UnknownModule%d_%x"", rel.index, off); // ????
    }
#else
    if (rel.index > bin->ne_header->ModRefs) {
     name = r_str_newf (""UnknownModule%d_%x"", rel.index, off); // ????
    } else {
     offset = modref[rel.index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;
     name = __read_nonnull_str_at (bin->buf, offset);
    }
#endif
    if (rel.flags & IMPORTED_ORD) {
     imp->ordinal = rel.func_ord;
     imp->name = r_str_newf (""%s.%s"", name, __func_name_from_ord(name, rel.func_ord));


    } else {
     offset = bin->header_offset + bin->ne_header->ImportNameTable + rel.name_off;
     char *func = __read_nonnull_str_at (bin->buf, offset);
@@ -566,6 +558,7 @@ RList *r_bin_ne_get_relocs(r_bin_ne_obj_t *bin) {
    r_list_append (relocs, reloc);
   } else {
    do {

#if NE_BUG
     if (reloc->paddr + 4 < r_buf_size (bin->buf)) {
      break;

@@ -1,3 +1,17 @@














NAME=NE Symbols
FILE=bins/ne/anim8.exe
CMDS=is

","19
libr/bin/format/ne/ne.c
@@ -1,7 +1,6 @@
/* radare - LGPL - Copyright 2019-2022 - GustavoLCR */

#include ""ne.h""
#define NE_BUG 0

static char *__get_target_os(r_bin_ne_obj_t *bin) {
 switch (bin->ne_header->targOS) {
@@ -505,25 +504,18 @@ RList *r_bin_ne_get_relocs(r_bin_ne_obj_t *bin) {
     free (reloc);
     break;
    }
    char *name;
#if NE_BUG
    if (rel.index > 0 && rel.index < bin->ne_header->ModRefs) {
     offset = modref[rel.index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;
     name = __read_nonnull_str_at (bin->buf, offset);
    } else {
     name = r_str_newf (""UnknownModule%d_%x"", rel.index, off); // ????
    }
#else
    char *name = NULL;
    if (rel.index > bin->ne_header->ModRefs) {
     name = r_str_newf (""UnknownModule%d_%x"", rel.index, off); // ????
    } else {
    } else if (rel.index > 0) {
     offset = modref[rel.index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;
     name = __read_nonnull_str_at (bin->buf, offset);
    }
#endif
    if (rel.flags & IMPORTED_ORD) {
     imp->ordinal = rel.func_ord;
     imp->name = r_str_newf (""%s.%s"", name, __func_name_from_ord(name, rel.func_ord));
     char *fname = __func_name_from_ord (name, rel.func_ord);
     imp->name = r_str_newf (""%s.%s"", name, fname);
     free (fname);
    } else {
     offset = bin->header_offset + bin->ne_header->ImportNameTable + rel.name_off;
     char *func = __read_nonnull_str_at (bin->buf, offset);
@@ -566,6 +558,7 @@ RList *r_bin_ne_get_relocs(r_bin_ne_obj_t *bin) {
    r_list_append (relocs, reloc);
   } else {
    do {
#define NE_BUG 0
#if NE_BUG
     if (reloc->paddr + 4 < r_buf_size (bin->buf)) {
      break;
14
test/db/formats/ne
@@ -1,3 +1,17 @@
NAME=NE crash
FILE=bins/ne/necrash
CMDS=<<EOF
aaa
i~format
i~csum
aflc
EOF
EXPECT=<<EOF
format   ne
hdr.csum c258016a
0
EOF
RUN
NAME=NE Symbols
FILE=bins/ne/anim8.exe
CMDS=is"
https://huntr.dev/bounties/6ea041d1-e2aa-472c-bf3e-da5fa8726c25/,Out-of-bounds Read in mrb_get_args in mruby/mruby,Affected commit,CVE-2022-1276,CWE-125: Out-of-bounds Read,https://www.github.com/mruby/mruby/commit/c8c083cb750606b2da81582cd8e43b442bb143e6,"@@ -1905,7 +1905,7 @@ gen_assignment(codegen_scope *s, node *tree, node *rhs, int sp, int val)
          }
        }
        if (tree->cdr->car) {       /* keyword arguments */
          if (n == 14) {
            pop_n(n);
            genop_2(s, OP_ARRAY, cursp(), n);
            push();

","2
mrbgems/mruby-compiler/core/codegen.c
@@ -1905,7 +1905,7 @@ gen_assignment(codegen_scope *s, node *tree, node *rhs, int sp, int val)
          }
        }
        if (tree->cdr->car) {       /* keyword arguments */
          if (n == 14) {
          if (n == 13 || n == 14) {
            pop_n(n);
            genop_2(s, OP_ARRAY, cursp(), n);
            push();"
https://huntr.dev/bounties/f918376e-b488-4113-963d-ffe8716e4189/,heap-buffer-overflow in mrb_vm_exec in mruby/mruby in mruby/mruby,3cf291f72224715942beaf8553e42ba8891ab3c6,CVE-2022-1286,CWE-122: Heap-based Buffer Overflow,https://www.github.com/mruby/mruby/commit/b1d0296a937fe278239bdfac840a3fd0e93b3ee9,"@@ -2361,7 +2361,10 @@ mrb_remove_method(mrb_state *mrb, struct RClass *c, mrb_sym mid)
  MRB_CLASS_ORIGIN(c);
  h = c->mt;

  if (h && mt_del(mrb, h, mid)) return;



  mrb_name_error(mrb, mid, ""method '%n' not defined in %C"", mid, c);
}


","5
src/class.c
@@ -2361,7 +2361,10 @@ mrb_remove_method(mrb_state *mrb, struct RClass *c, mrb_sym mid)
  MRB_CLASS_ORIGIN(c);
  h = c->mt;

  if (h && mt_del(mrb, h, mid)) return;
  if (h && mt_del(mrb, h, mid)) {
    mrb_mc_clear_by_class(mrb, c);
    return;
  }
  mrb_name_error(mrb, mid, ""method '%n' not defined in %C"", mid, c);
}"
https://huntr.dev/bounties/e98ad92c-3a64-48fb-84d4-d13afdbcbdd7/,heap-use-after-free in radareorg/radare2,"Whilst experimenting with radare2, built from version 5.6.6, we are able to induce a vulnerability at reg.c:101 in function r_reg_get_name_idx , using radare2 as a harness.",CVE-2022-1284,CWE-416: Use After Free,https://www.github.com/radareorg/radare2/commit/64a82e284dddabaeb549228380103b57dead32a6,"@@ -5295,10 +5295,6 @@ R_API void r_core_anal_esil(RCore *core, const char *str, const char *target) {
  arch = R2_ARCH_MIPS;
 }

 const char *sn = r_reg_get_name (core->anal->reg, R_REG_NAME_SN);
 if (!sn) {
  eprintf (""Warning: No SN reg alias for current architecture.\n"");
 }
 r_reg_arena_push (core->anal->reg);

 IterCtx ictx = { start, end, fcn, NULL };
@@ -5409,6 +5405,10 @@ R_API void r_core_anal_esil(RCore *core, const char *str, const char *target) {
    goto repeat;
   }
  }




  if (sn && op.type == R_ANAL_OP_TYPE_SWI) {
   r_strf_buffer (64);
   r_flag_space_set (core->flags, R_FLAGS_FS_SYSCALLS);

","8
libr/core/canal.c
@@ -5295,10 +5295,6 @@ R_API void r_core_anal_esil(RCore *core, const char *str, const char *target) {
  arch = R2_ARCH_MIPS;
 }

 const char *sn = r_reg_get_name (core->anal->reg, R_REG_NAME_SN);
 if (!sn) {
  eprintf (""Warning: No SN reg alias for current architecture.\n"");
 }
 r_reg_arena_push (core->anal->reg);

 IterCtx ictx = { start, end, fcn, NULL };
@@ -5409,6 +5405,10 @@ R_API void r_core_anal_esil(RCore *core, const char *str, const char *target) {
    goto repeat;
   }
  }
  const char *sn = r_reg_get_name (core->anal->reg, R_REG_NAME_SN);
  if (!sn) {
   eprintf (""Warning: No SN reg alias for current architecture.\n"");
  }
  if (sn && op.type == R_ANAL_OP_TYPE_SWI) {
   r_strf_buffer (64);
   r_flag_space_set (core->flags, R_FLAGS_FS_SYSCALLS);"
https://huntr.dev/bounties/bfeb8fb8-644d-4587-80d4-cb704c404013/,NULL Pointer Dereference in r_bin_ne_get_entrypoints function in radareorg/radare2,A NULL pointer deference vulnerability in r_bin_ne_get_entrypoints function due to a missing check before using the pointer.,CVE-2022-1283,CWE-476: NULL Pointer Dereference,https://www.github.com/radareorg/radare2/commit/18d1d064bf599a255d55f09fca3104776fc34a67,"@@ -115,7 +115,7 @@ RList *r_bin_ne_get_symbols(r_bin_ne_obj_t *bin) {
 }
 RList *entries = r_bin_ne_get_entrypoints (bin);
 bool resident = true, first = true;
 while (true) {
  ut8 sz = r_buf_read8_at (bin->buf, off);
  if (!sz) {
   first = true;
@@ -352,6 +352,9 @@ RList *r_bin_ne_get_imports(r_bin_ne_obj_t *bin) {
}

RList *r_bin_ne_get_entrypoints(r_bin_ne_obj_t *bin) {



 RList *entries = r_list_newf (free);
 if (!entries) {
  return NULL;

","5
libr/bin/format/ne/ne.c
@@ -115,7 +115,7 @@ RList *r_bin_ne_get_symbols(r_bin_ne_obj_t *bin) {
 }
 RList *entries = r_bin_ne_get_entrypoints (bin);
 bool resident = true, first = true;
 while (true) {
 while (entries) {
  ut8 sz = r_buf_read8_at (bin->buf, off);
  if (!sz) {
   first = true;
@@ -352,6 +352,9 @@ RList *r_bin_ne_get_imports(r_bin_ne_obj_t *bin) {
}

RList *r_bin_ne_get_entrypoints(r_bin_ne_obj_t *bin) {
 if (!bin->entry_table) {
  return NULL;
 }
 RList *entries = r_list_newf (free);
 if (!entries) {
  return NULL;"
https://huntr.dev/bounties/8ae2c61a-2220-47a5-bfe8-fe6d41ab1f82/,heap-buffer-overflow in radareorg/radare2,"Whilst experimenting with radare2, built from version 5.6.6, we are able to induce a vulnerability at bin_dyldcache.c:125 in function va2pa , using radare2 as a harness.",CVE-2022-1244,CWE-122: Heap-based Buffer Overflow,https://www.github.com/radareorg/radare2/commit/2b77b277d67ce061ee6ef839e7139ebc2103c1e3,"@@ -1,4 +1,4 @@
/* radare - LGPL - Copyright 2009-2010 nibble<.ds@gmail.com> */

#include <r_types.h>
#include ""mach0_specs.h""

@@ -1247,7 +1247,8 @@ static RList *create_cache_bins(RBinFile *bf, RDyldCache *cache) {
   if (deps && !deps[j]) {
    continue;
   }
   ut64 pa = va2pa (img[j].address, hdr->mappingCount, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);

   if (pa == UT64_MAX) {
    continue;
   }

","2
libr/bin/format/mach0/dyldcache.h
@@ -1,4 +1,4 @@
/* radare - LGPL - Copyright 2009-2010 nibble<.ds@gmail.com> */
/* radare - LGPL - Copyright 2009-2022 nibble, pancake */

#include <r_types.h>
#include ""mach0_specs.h""
3
libr/bin/p/bin_dyldcache.c
@@ -1247,7 +1247,8 @@ static RList *create_cache_bins(RBinFile *bf, RDyldCache *cache) {
   if (deps && !deps[j]) {
    continue;
   }
   ut64 pa = va2pa (img[j].address, hdr->mappingCount, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);
   // ut64 pa = va2pa (img[j].address, hdr->mappingCount, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);
   ut64 pa = va2pa (img[j].address, cache->n_maps, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);
   if (pa == UT64_MAX) {
    continue;
   }"
https://huntr.dev/bounties/47422cdf-aad2-4405-a6a1-6f63a3a93200/,Heap-based Buffer Overflow in libr/bin/format/ne/ne.c in radareorg/radare2,while (off < bin->ne_header->EntryTableLength) {,CVE-2022-1238,CWE-805: Buffer Access with Incorrect Length Value,https://www.github.com/radareorg/radare2/commit/c40a4f9862104ede15d0ba05ccbf805923070778,"@@ -374,6 +374,9 @@ RList *r_bin_ne_get_entrypoints(r_bin_ne_obj_t *bin) {
 }
 int off = 0;
 while (off < bin->ne_header->EntryTableLength) {



  ut8 bundle_length = *(ut8 *)(bin->entry_table + off);
  if (!bundle_length) {
   break;
@@ -398,7 +401,9 @@ RList *r_bin_ne_get_entrypoints(r_bin_ne_obj_t *bin) {
    ut8 segnum = *(bin->entry_table + off);
    off++;
    ut16 segoff = *(ut16 *)(bin->entry_table + off);
    entry->paddr = (ut64)bin->segment_entries[segnum - 1].offset * bin->alignment + segoff;


   } else { // Fixed
    entry->paddr = (ut64)bin->segment_entries[bundle_type - 1].offset * bin->alignment + *(ut16 *)(bin->entry_table + off);
   }

","7
libr/bin/format/ne/ne.c
@@ -374,6 +374,9 @@ RList *r_bin_ne_get_entrypoints(r_bin_ne_obj_t *bin) {
 }
 int off = 0;
 while (off < bin->ne_header->EntryTableLength) {
  if (bin->entry_table + off + 32 >= r_buf_size (bin->buf)) {
   break;
  }
  ut8 bundle_length = *(ut8 *)(bin->entry_table + off);
  if (!bundle_length) {
   break;
@@ -398,7 +401,9 @@ RList *r_bin_ne_get_entrypoints(r_bin_ne_obj_t *bin) {
    ut8 segnum = *(bin->entry_table + off);
    off++;
    ut16 segoff = *(ut16 *)(bin->entry_table + off);
    entry->paddr = (ut64)bin->segment_entries[segnum - 1].offset * bin->alignment + segoff;
    if (segnum > 0) {
     entry->paddr = (ut64)bin->segment_entries[segnum - 1].offset * bin->alignment + segoff;
    }
   } else { // Fixed
    entry->paddr = (ut64)bin->segment_entries[bundle_type - 1].offset * bin->alignment + *(ut16 *)(bin->entry_table + off);
   }"
https://huntr.dev/bounties/ad3c9c4c-76e7-40c8-bd4a-c095acd8bb40/,Improper Validation of Array Index in radareorg/radare2,85                      RBinSection *bs = R_NEW0 (RBinSection);,CVE-2022-1237,CWE-129: Improper Validation of Array Index,https://www.github.com/radareorg/radare2/commit/2d782cdaa2112c10b8dd5e7a93c134b2ada9c1a6,"@@ -1,4 +1,4 @@
/* radare - LGPL - Copyright 2019 - GustavoLCR */

#include ""ne.h""

@@ -83,10 +83,10 @@ RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {
 RList *segments = r_list_newf (free);
 for (i = 0; i < bin->ne_header->SegCount; i++) {
  RBinSection *bs = R_NEW0 (RBinSection);
  NE_image_segment_entry *se = &bin->segment_entries[i];
  if (!bs) {
   return segments;
  }

  bs->size = se->length;
  bs->vsize = se->minAllocSz ? se->minAllocSz : 64000;
  bs->bits = R_SYS_BITS_16;
@@ -425,7 +425,7 @@ RList *r_bin_ne_get_relocs(r_bin_ne_obj_t *bin) {
  return NULL;
 }

 ut16 *modref = malloc (bin->ne_header->ModRefs * sizeof (ut16));
 if (!modref) {
  return NULL;
 }
@@ -451,7 +451,8 @@ RList *r_bin_ne_get_relocs(r_bin_ne_obj_t *bin) {
   continue;
  }
  off += 2;
  while (off < start + length * sizeof (NE_image_reloc_item)) {

   RBinReloc *reloc = R_NEW0 (RBinReloc);
   if (!reloc) {
    return NULL;
@@ -484,10 +485,11 @@ RList *r_bin_ne_get_relocs(r_bin_ne_obj_t *bin) {
     break;
    }
    char *name;
    if (rel.index > bin->ne_header->ModRefs) {
     name = r_str_newf (""UnknownModule%d_%x"", rel.index, off); // ????
    } else {
     offset = modref[rel.index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;

     name = __read_nonnull_str_at (bin->buf, offset);
    }
    if (rel.flags & IMPORTED_ORD) {
@@ -563,16 +565,31 @@ void __init(RBuffer *buf, r_bin_ne_obj_t *bin) {
  return;
 }
 bin->buf = buf;

 r_buf_read_at (buf, bin->header_offset, (ut8 *)bin->ne_header, sizeof (NE_image_header));






 bin->alignment = 1 << bin->ne_header->FileAlnSzShftCnt;
 if (!bin->alignment) {
  bin->alignment = 1 << 9;
 }
 bin->os = __get_target_os (bin);

 ut16 offset = bin->ne_header->SegTableOffset + bin->header_offset;
 ut16 size = bin->ne_header->SegCount * sizeof (NE_image_segment_entry);





 bin->segment_entries = calloc (1, size);



 if (!bin->segment_entries) {
  return;
 }

","31
libr/bin/format/ne/ne.c
@@ -1,4 +1,4 @@
/* radare - LGPL - Copyright 2019 - GustavoLCR */
/* radare - LGPL - Copyright 2019-2022 - GustavoLCR */

#include ""ne.h""

@@ -83,10 +83,10 @@ RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {
 RList *segments = r_list_newf (free);
 for (i = 0; i < bin->ne_header->SegCount; i++) {
  RBinSection *bs = R_NEW0 (RBinSection);
  NE_image_segment_entry *se = &bin->segment_entries[i];
  if (!bs) {
   return segments;
  }
  NE_image_segment_entry *se = &bin->segment_entries[i];
  bs->size = se->length;
  bs->vsize = se->minAllocSz ? se->minAllocSz : 64000;
  bs->bits = R_SYS_BITS_16;
@@ -425,7 +425,7 @@ RList *r_bin_ne_get_relocs(r_bin_ne_obj_t *bin) {
  return NULL;
 }

 ut16 *modref = malloc (bin->ne_header->ModRefs * sizeof (ut16));
 ut16 *modref = calloc (bin->ne_header->ModRefs, sizeof (ut16));
 if (!modref) {
  return NULL;
 }
@@ -451,7 +451,8 @@ RList *r_bin_ne_get_relocs(r_bin_ne_obj_t *bin) {
   continue;
  }
  off += 2;
  while (off < start + length * sizeof (NE_image_reloc_item)) {
  size_t buf_size = r_buf_size (bin->buf);
  while (off < start + length * sizeof (NE_image_reloc_item) && off < buf_size) {
   RBinReloc *reloc = R_NEW0 (RBinReloc);
   if (!reloc) {
    return NULL;
@@ -484,10 +485,11 @@ RList *r_bin_ne_get_relocs(r_bin_ne_obj_t *bin) {
     break;
    }
    char *name;
    if (rel.index > bin->ne_header->ModRefs) {
    if (rel.index < 1 || rel.index > bin->ne_header->ModRefs) {
     name = r_str_newf (""UnknownModule%d_%x"", rel.index, off); // ????
    } else {
     offset = modref[rel.index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;
     int index = rel.index;
     offset = modref[index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;
     name = __read_nonnull_str_at (bin->buf, offset);
    }
    if (rel.flags & IMPORTED_ORD) {
@@ -563,16 +565,31 @@ void __init(RBuffer *buf, r_bin_ne_obj_t *bin) {
  return;
 }
 bin->buf = buf;
 // XXX this is endian unsafe
 r_buf_read_at (buf, bin->header_offset, (ut8 *)bin->ne_header, sizeof (NE_image_header));
 if (bin->ne_header->FileAlnSzShftCnt > 8) {
  bin->ne_header->FileAlnSzShftCnt = 8;
 }
 if (bin->ne_header->ModRefs * sizeof (ut16) >= r_buf_size (bin->buf)) {
  bin->ne_header->ModRefs = r_buf_size (bin->buf) / sizeof (ut16);
 }
 bin->alignment = 1 << bin->ne_header->FileAlnSzShftCnt;
 if (!bin->alignment) {
  bin->alignment = 1 << 9;
 }
 bin->os = __get_target_os (bin);

 ut16 offset = bin->ne_header->SegTableOffset + bin->header_offset;
 ut16 size = bin->ne_header->SegCount * sizeof (NE_image_segment_entry);
 size_t size = bin->ne_header->SegCount * sizeof (NE_image_segment_entry);
 if (offset >= r_buf_size (bin->buf)) {
  return;
 }
 size_t remaining = r_buf_size (bin->buf) - offset;
 size = R_MIN (remaining, size);
 bin->segment_entries = calloc (1, size);
 if (size >= remaining) {
  bin->ne_header->SegCount = size / sizeof (NE_image_segment_entry);
 }
 if (!bin->segment_entries) {
  return;
 }"
https://huntr.dev/bounties/e589bd97-4c74-4e79-93b5-0951a281facc/,Heap buffer overflow in libr/bin/format/mach0/mach0.c in radareorg/radare2,3177            size_t i;,CVE-2022-1240,CWE-122: Heap-based Buffer Overflow,https://www.github.com/radareorg/radare2/commit/ca8d8b39f3e34a4fd943270330b80f1148129de4,"@@ -3178,7 +3178,7 @@ static void parse_relocation_info(struct MACH0_(obj_t) *bin, RSkipList *relocs,
 for (i = 0; i < num; i++) {
  struct relocation_info a_info = info[i];
  ut32 sym_num = a_info.r_symbolnum;
  if (sym_num > bin->nsymtab) {
   continue;
  }


","2
libr/bin/format/mach0/mach0.c
@@ -3178,7 +3178,7 @@ static void parse_relocation_info(struct MACH0_(obj_t) *bin, RSkipList *relocs,
 for (i = 0; i < num; i++) {
  struct relocation_info a_info = info[i];
  ut32 sym_num = a_info.r_symbolnum;
  if (sym_num > bin->nsymtab) {
  if (sym_num >= bin->nsymtab) {
   continue;
  }"
https://huntr.dev/bounties/9fcc06d0-08e4-49c8-afda-2cae40946abe/,Use-After-Free in str_escape in mruby/mruby in mruby/mruby,60cf382ff9765e36b21143d79688a3e758b66fd4,CVE-2022-1212,CWE-416: Use After Free,https://www.github.com/mruby/mruby/commit/3cf291f72224715942beaf8553e42ba8891ab3c6,"@@ -2268,9 +2268,9 @@ mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)
          }
          if (ci->cci > CINFO_NONE) {
            ci = cipop(mrb);

            mrb_gc_arena_restore(mrb, ai);
            mrb->c->vmexec = FALSE;
            mrb->exc = (struct RObject*)break_new(mrb, RBREAK_TAG_BREAK, proc, v);
            mrb->jmp = prev_jmp;
            MRB_THROW(prev_jmp);
          }

","2
src/vm.c
@@ -2268,9 +2268,9 @@ mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)
          }
          if (ci->cci > CINFO_NONE) {
            ci = cipop(mrb);
            mrb->exc = (struct RObject*)break_new(mrb, RBREAK_TAG_BREAK, proc, v);
            mrb_gc_arena_restore(mrb, ai);
            mrb->c->vmexec = FALSE;
            mrb->exc = (struct RObject*)break_new(mrb, RBREAK_TAG_BREAK, proc, v);
            mrb->jmp = prev_jmp;
            MRB_THROW(prev_jmp);
          }"
https://huntr.dev/bounties/4ada4519-c3b6-4814-b822-65dcb33cf98d/,Use After Free in new_object in libredwg/libredwg,Heap use after free in new_object function.,,CWE-416: Use After Free,https://www.github.com/libredwg/libredwg/commit/fa4a343b5885d1b94b422068ece103aaef1354e3,,"25
src/in_dxf.c
@@ -86,13 +86,24 @@ static array_hdls *obj_hdls = NULL;
  dwg_dynapi_entity_set_value (o, obj->name, field, &pair->value, 1);         \
  LOG_TRACE (""%s.%s = %d ["" #type "" %d]\n"", obj->name, field, pair->value.i,  \
             pair->code);                                                     \
  dxf_free_pair (pair)
  dxf_free_pair (pair); pair = NULL;
#define EXPECT_UINT_DXF(field, dxf, type)                                     \
  EXPECT_DXF (obj->name, #field, dxf);                                        \
  if (pair->value.l < 0) {            \
      LOG_ERROR (""%s: Unexpected DXF value %ld for %s code %d"", obj->name,    \
                 pair ? pair->value.l : 0, #field, dxf);        \
      return pair;             \
  }               \
  dwg_dynapi_entity_set_value (o, obj->name, field, &pair->value, 1);         \
  LOG_TRACE (""%s.%s = %d ["" #type "" %d]\n"", obj->name, field, pair->value.i,  \
             pair->code);                                                     \
  dxf_free_pair (pair); pair = NULL
#define EXPECT_DBL_DXF(field, dxf, type)                                      \
  EXPECT_DXF (obj->name, #field, dxf);                                        \
  dwg_dynapi_entity_set_value (o, obj->name, field, &pair->value, 1);         \
  LOG_TRACE (""%s.%s = %f ["" #type "" %d]\n"", obj->name, field, pair->value.d,  \
             pair->code);                                                     \
  dxf_free_pair (pair)
  dxf_free_pair (pair); pair = NULL
#define EXPECT_H_DXF(field, htype, dxf, type)                                 \
  EXPECT_DXF (obj->name, #field, dxf);                                        \
  if (pair->value.u)                                                          \
@@ -102,7 +113,7 @@ static array_hdls *obj_hdls = NULL;
      LOG_TRACE (""%s.%s = "" FORMAT_REF "" [H %d]\n"", obj->name, field,         \
                 ARGS_REF (hdl), pair->code);                                 \
    }                                                                         \
  dxf_free_pair (pair)
  dxf_free_pair (pair); pair = NULL
#define EXPECT_T_DXF(field, dxf)                                              \
  EXPECT_DXF (obj->name, #field, dxf);                                        \
  if (pair->value.s)                                                          \
@@ -111,7 +122,7 @@ static array_hdls *obj_hdls = NULL;
      LOG_TRACE (""%s.%s = \""%s\"" [T %d]\n"", obj->name, field, pair->value.s,  \
                 pair->code);                                                 \
    }                                                                         \
  dxf_free_pair (pair)
  dxf_free_pair (pair); pair = NULL

// stricter ordering for special subclasses:
#define FIELD_B(field, dxf)                                                   \
@@ -142,7 +153,7 @@ static array_hdls *obj_hdls = NULL;
  if (dxf)                                                                    \
    {                                                                         \
      pair = dxf_read_pair (dat);                                             \
      EXPECT_INT_DXF (#field, dxf, BL);                                       \
      EXPECT_UINT_DXF (#field, dxf, BL);                                      \
    }
#define FIELD_BD(field, dxf)                                                  \
  if (dxf)                                                                    \
@@ -6133,13 +6144,13 @@ add_PERSUBENTMGR (Dwg_Object *restrict obj, Bit_Chain *restrict dat,
  Dwg_Object_PERSUBENTMGR *o = obj->tio.object->tio.PERSUBENTMGR;
  Dwg_Data *dwg = obj->parent;

  EXPECT_INT_DXF (""class_version"", 90, BL);
  EXPECT_UINT_DXF (""class_version"", 90, BL);
  FIELD_BL (unknown_0, 90);
  FIELD_BL (unknown_2, 90);
  FIELD_BL (numassocsteps, 90);
  FIELD_BL (numassocsubents, 90);
  FIELD_BL (num_steps, 90);
  if (o->num_steps)
  if (o->num_steps > 0)
    {
      o->steps = (BITCODE_BL*)xcalloc (o->num_steps, sizeof (BITCODE_BL));
      if (!o->steps)"
https://huntr.dev/bounties/7b979e76-ae54-4132-b455-0833e45195eb/,Out-of-bounds read in radareorg/radare2,Out-of-bounds (OOB) read vulnerability exists in analop function in Radare2 5.6.7,CVE-2022-1207,CWE-125: Out-of-bounds Read,https://www.github.com/radareorg/radare2/commit/605785b65dd356d46d4487faa41dbf90943b8bc1,"@@ -1,4 +1,4 @@
/* radare2 - LGPL - Copyright 2014-2015 - pancake */

#include <r_asm.h>
#include <r_lib.h>
@@ -7,6 +7,9 @@ static int analop(RAnal *a, RAnalOp *op, ut64 addr, const ut8 *buf, int len, RAn
 int opsize = -1;
 op->type = -1;
 opsize = 2;



 switch (buf[0]) {
 case 0x3f:
 case 0x4f:
@@ -21,9 +24,9 @@ static int analop(RAnal *a, RAnalOp *op, ut64 addr, const ut8 *buf, int len, RAn
  op->type = R_ANAL_OP_TYPE_LEA;
  if (len > 5) {
   op->ptr = buf[2];
   op->ptr |= buf[3]<<8;
   op->ptr |= buf[4]<<16;
   op->ptr |= ((ut32)(0xff&buf[5]))<<24;
   op->ptr += addr;
   opsize = 6;
  } else {
@@ -35,9 +38,9 @@ static int analop(RAnal *a, RAnalOp *op, ut64 addr, const ut8 *buf, int len, RAn
  op->type = R_ANAL_OP_TYPE_CALL;
  if (len > 5) {
   st32 delta = buf[2];
   delta |= buf[3]<<8;
   delta |= buf[4]<<16;
   delta |= buf[5]<<24;
   op->jump = addr + delta;
  } else {
   op->jump = UT64_MAX;
@@ -46,6 +49,9 @@ static int analop(RAnal *a, RAnalOp *op, ut64 addr, const ut8 *buf, int len, RAn
  opsize = 6;
  break;
 case 0x00:



  if (buf[1] == 0x00) {
   op->type = R_ANAL_OP_TYPE_TRAP;
  } else {
@@ -57,11 +63,17 @@ static int analop(RAnal *a, RAnalOp *op, ut64 addr, const ut8 *buf, int len, RAn
  }
  break;
 case 0xf0:
  if (buf[1]==0xb9) {



   op->type = R_ANAL_OP_TYPE_RET;
  }
  break;
 default:



  switch (buf[1]) {
  case 0x00:
   op->type = R_ANAL_OP_TYPE_CJMP; // BCC
@@ -70,7 +82,7 @@ static int analop(RAnal *a, RAnalOp *op, ut64 addr, const ut8 *buf, int len, RAn
   op->type = R_ANAL_OP_TYPE_SHR;
   break;
  case 0x96: // move.d r, r
   if (buf[0] >=0xc0) {
    op->type = R_ANAL_OP_TYPE_CMP;
   } else {
    op->type = R_ANAL_OP_TYPE_MOV;
@@ -242,6 +254,7 @@ static bool set_reg_profile(RAnal *anal) {
  ""=PC pc\n""
  ""=SP r14\n"" // XXX
  ""=BP srp\n"" // XXX

  ""=A0 r0\n""
  ""=A1 r1\n""
  ""=A2 r2\n""

","31
libr/anal/p/anal_cris.c
@@ -1,4 +1,4 @@
/* radare2 - LGPL - Copyright 2014-2015 - pancake */
/* radare2 - LGPL - Copyright 2014-2022 - pancake */

#include <r_asm.h>
#include <r_lib.h>
@@ -7,6 +7,9 @@ static int analop(RAnal *a, RAnalOp *op, ut64 addr, const ut8 *buf, int len, RAn
 int opsize = -1;
 op->type = -1;
 opsize = 2;
 if (len < 1) {
  return -1;
 }
 switch (buf[0]) {
 case 0x3f:
 case 0x4f:
@@ -21,9 +24,9 @@ static int analop(RAnal *a, RAnalOp *op, ut64 addr, const ut8 *buf, int len, RAn
  op->type = R_ANAL_OP_TYPE_LEA;
  if (len > 5) {
   op->ptr = buf[2];
   op->ptr |= buf[3]<<8;
   op->ptr |= buf[4]<<16;
   op->ptr |= ((ut32)(0xff&buf[5]))<<24;
   op->ptr |= buf[3] << 8;
   op->ptr |= buf[4] << 16;
   op->ptr |= ((ut32)(0xff & buf[5])) << 24;
   op->ptr += addr;
   opsize = 6;
  } else {
@@ -35,9 +38,9 @@ static int analop(RAnal *a, RAnalOp *op, ut64 addr, const ut8 *buf, int len, RAn
  op->type = R_ANAL_OP_TYPE_CALL;
  if (len > 5) {
   st32 delta = buf[2];
   delta |= buf[3]<<8;
   delta |= buf[4]<<16;
   delta |= buf[5]<<24;
   delta |= buf[3] << 8;
   delta |= buf[4] << 16;
   delta |= buf[5] << 24;
   op->jump = addr + delta;
  } else {
   op->jump = UT64_MAX;
@@ -46,6 +49,9 @@ static int analop(RAnal *a, RAnalOp *op, ut64 addr, const ut8 *buf, int len, RAn
  opsize = 6;
  break;
 case 0x00:
  if (len < 2) {
   break;
  }
  if (buf[1] == 0x00) {
   op->type = R_ANAL_OP_TYPE_TRAP;
  } else {
@@ -57,11 +63,17 @@ static int analop(RAnal *a, RAnalOp *op, ut64 addr, const ut8 *buf, int len, RAn
  }
  break;
 case 0xf0:
  if (buf[1]==0xb9) {
  if (len < 2) {
   break;
  }
  if (buf[1] == 0xb9) {
   op->type = R_ANAL_OP_TYPE_RET;
  }
  break;
 default:
  if (len < 2) {
   break;
  }
  switch (buf[1]) {
  case 0x00:
   op->type = R_ANAL_OP_TYPE_CJMP; // BCC
@@ -70,7 +82,7 @@ static int analop(RAnal *a, RAnalOp *op, ut64 addr, const ut8 *buf, int len, RAn
   op->type = R_ANAL_OP_TYPE_SHR;
   break;
  case 0x96: // move.d r, r
   if (buf[0] >=0xc0) {
   if (buf[0] >= 0xc0) {
    op->type = R_ANAL_OP_TYPE_CMP;
   } else {
    op->type = R_ANAL_OP_TYPE_MOV;
@@ -242,6 +254,7 @@ static bool set_reg_profile(RAnal *anal) {
  ""=PC pc\n""
  ""=SP r14\n"" // XXX
  ""=BP srp\n"" // XXX
  ""=SN r0\n""
  ""=A0 r0\n""
  ""=A1 r1\n""
  ""=A2 r2\n"""
https://huntr.dev/bounties/6f930add-c9d8-4870-ae56-d4bd8354703b/,NULL Pointer Dereference in mrb_vm_exec with super in mruby/mruby,NULL Pointer Dereference in mrb_vm_exec with super,CVE-2022-1201,CWE-476: NULL Pointer Dereference,https://www.github.com/mruby/mruby/commit/00acae117da1b45b318dc36531a7b0021b8097ae,"@@ -1749,7 +1749,7 @@ mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)
      }
      else if (target_class->tt == MRB_TT_MODULE) {
        target_class = mrb_vm_ci_target_class(ci);
        if (target_class->tt != MRB_TT_ICLASS) {
          goto super_typeerror;
        }
      }

","2
src/vm.c
@@ -1749,7 +1749,7 @@ mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)
      }
      else if (target_class->tt == MRB_TT_MODULE) {
        target_class = mrb_vm_ci_target_class(ci);
        if (target_class->tt != MRB_TT_ICLASS) {
        if (!target_class || target_class->tt != MRB_TT_ICLASS) {
          goto super_typeerror;
        }
      }"
https://huntr.dev/bounties/f8cb85b8-7ff3-47f1-a9a6-7080eb371a3d/,Inf loop in gpac/gpac,A inf loop security issue in gpac/gpac,CVE-2022-1222,CWE-835: Infinite Loop,https://www.github.com/gpac/gpac/commit/7f060bbb72966cae80d6fee338d0b07fa3fc06e1,"@@ -1884,8 +1884,8 @@ avi_t *AVI_open_fd(FILE *fd, int getIndex)

int avi_parse_input_file(avi_t *AVI, int getIndex)
{
 int i, rate, scale, idx_type;
 s64 n;
 unsigned char *hdrl_data;
 u64 header_offset=0;
 int hdrl_len=0;
@@ -1939,6 +1939,7 @@ int avi_parse_input_file(avi_t *AVI, int getIndex)
    n -= 4;
   if(strnicmp(data,""hdrl"",4) == 0)
   {

    hdrl_len = (u32) n;
    hdrl_data = (unsigned char *) gf_malloc((u32)n);
    if(hdrl_data==0) ERR_EXIT(AVI_ERR_NO_MEM);
@@ -2091,8 +2092,10 @@ int avi_parse_input_file(avi_t *AVI, int getIndex)
      AVI->compressor2[4] = 0;

      if (n>40) {

       AVI->extradata_size = (u32) (n - 40);
       AVI->extradata = gf_malloc(sizeof(u8)* AVI->extradata_size);

       memcpy(AVI->extradata, hdrl_data + i + 40, AVI->extradata_size);
      }


","7
src/media_tools/avilib.c
@@ -1884,8 +1884,8 @@ avi_t *AVI_open_fd(FILE *fd, int getIndex)

int avi_parse_input_file(avi_t *AVI, int getIndex)
{
 int i, rate, scale, idx_type;
 s64 n;
 int rate, scale, idx_type;
 s64 n, i;
 unsigned char *hdrl_data;
 u64 header_offset=0;
 int hdrl_len=0;
@@ -1939,6 +1939,7 @@ int avi_parse_input_file(avi_t *AVI, int getIndex)
    n -= 4;
   if(strnicmp(data,""hdrl"",4) == 0)
   {
    if (n>0xFFFFFFFF) ERR_EXIT(AVI_ERR_READ)
    hdrl_len = (u32) n;
    hdrl_data = (unsigned char *) gf_malloc((u32)n);
    if(hdrl_data==0) ERR_EXIT(AVI_ERR_NO_MEM);
@@ -2091,8 +2092,10 @@ int avi_parse_input_file(avi_t *AVI, int getIndex)
      AVI->compressor2[4] = 0;

      if (n>40) {
       if (n>0xFFFFFFFF) ERR_EXIT(AVI_ERR_READ)
       AVI->extradata_size = (u32) (n - 40);
       AVI->extradata = gf_malloc(sizeof(u8)* AVI->extradata_size);
       if (!AVI->extradata) ERR_EXIT(AVI_ERR_NO_MEM)
       memcpy(AVI->extradata, hdrl_data + i + 40, AVI->extradata_size);
      }"
https://huntr.dev/bounties/a26cb79c-9257-4fbf-98c5-a5a331efa264/,Null Pointer Dereference Caused Segmentation Fault in gpac/gpac,Null pointer dereference caused segmentation fault,CVE-2022-1172,CWE-476: NULL Pointer Dereference,https://www.github.com/gpac/gpac/commit/55a183e6b8602369c04ea3836e05436a79fbc7f8,"@@ -205,6 +205,7 @@ GF_Err gf_bifs_dec_sf_field(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *n
  if (sfcb->buffer) {
   gf_free(sfcb->buffer);
   sfcb->buffer = NULL;

  }
  while (gf_list_count(sfcb->commandList)) {
   GF_Command *com = (GF_Command*)gf_list_get(sfcb->commandList, 0);

","1
src/bifs/field_decode.c
@@ -205,6 +205,7 @@ GF_Err gf_bifs_dec_sf_field(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *n
  if (sfcb->buffer) {
   gf_free(sfcb->buffer);
   sfcb->buffer = NULL;
   sfcb->bufferSize = 0;
  }
  while (gf_list_count(sfcb->commandList)) {
   GF_Command *com = (GF_Command*)gf_list_get(sfcb->commandList, 0);"
https://huntr.dev/bounties/1e2ab4ea-018d-48fd-a61f-84780d528c2b/,Stack buffer overflow in XML entity parsing in gpac/gpac,"Attempting to parse a XML/SVG file containing an <!ENTITY with a sufficiently long name into a fixed sized, stack allocated buffer causes an overflow.",,CWE-121: Stack-based Buffer Overflow,https://www.github.com/gpac/gpac/commit/a74b68c958551aafc795445bca810c5fa36328e3,"@@ -637,13 +637,15 @@ static void xml_sax_skip_xml_proc(GF_SAXParser *parser)

static void xml_sax_parse_entity(GF_SAXParser *parser)
{
 char szName[1024];

 u32 i = 0;
 XML_Entity *ent = (XML_Entity *)gf_list_last(parser->entities);
 char *skip_chars = "" \t\n\r"";
 i=0;
 if (ent && ent->value) ent = NULL;
 if (ent) skip_chars = NULL;


 while (parser->current_pos+i < parser->line_size) {
  u8 c = parser->buffer[parser->current_pos+i];
@@ -655,16 +657,20 @@ static void xml_sax_parse_entity(GF_SAXParser *parser)
  if (!ent && (c=='%')) {
   parser->current_pos+=i+1;
   parser->sax_state = SAX_STATE_SKIP_DOCTYPE;

   return;
  }
  else if (!ent && ((c=='\""') || (c=='\'')) ) {
   szName[i] = 0;
   GF_SAFEALLOC(ent, XML_Entity);
   if (!ent) {
    parser->sax_state = SAX_STATE_ALLOC_ERROR;

    return;
   }
   ent->name = gf_strdup(szName);



   ent->namelen = (u32) strlen(ent->name);
   ent->sep = c;
   parser->current_pos += 1+i;
@@ -674,6 +680,7 @@ static void xml_sax_parse_entity(GF_SAXParser *parser)
   gf_list_add(parser->entities, ent);
   skip_chars = NULL;
  } else if (ent && c==ent->sep) {

   xml_sax_store_text(parser, i);

   ent->value = xml_get_current_text(parser);
@@ -685,12 +692,14 @@ static void xml_sax_parse_entity(GF_SAXParser *parser)
   parser->sax_state = SAX_STATE_SKIP_DOCTYPE;
   return;
  } else if (!ent) {
   szName[i] = c;

   i++;
  } else {
   i++;
  }
 }

 xml_sax_store_text(parser, i);
}


","17
src/utils/xml_parser.c
@@ -637,13 +637,15 @@ static void xml_sax_skip_xml_proc(GF_SAXParser *parser)

static void xml_sax_parse_entity(GF_SAXParser *parser)
{
 char szName[1024];
 char szC[2];
 char *ent_name=NULL;
 u32 i = 0;
 XML_Entity *ent = (XML_Entity *)gf_list_last(parser->entities);
 char *skip_chars = "" \t\n\r"";
 i=0;
 if (ent && ent->value) ent = NULL;
 if (ent) skip_chars = NULL;
 szC[1]=0;

 while (parser->current_pos+i < parser->line_size) {
  u8 c = parser->buffer[parser->current_pos+i];
@@ -655,16 +657,20 @@ static void xml_sax_parse_entity(GF_SAXParser *parser)
  if (!ent && (c=='%')) {
   parser->current_pos+=i+1;
   parser->sax_state = SAX_STATE_SKIP_DOCTYPE;
   if (ent_name) gf_free(ent_name);
   return;
  }
  else if (!ent && ((c=='\""') || (c=='\'')) ) {
   szName[i] = 0;
   GF_SAFEALLOC(ent, XML_Entity);
   if (!ent) {
    parser->sax_state = SAX_STATE_ALLOC_ERROR;
    if (ent_name) gf_free(ent_name);
    return;
   }
   ent->name = gf_strdup(szName);
   if (!ent_name) gf_dynstrcat(&ent_name, """", NULL);

   ent->name = ent_name;
   ent_name=NULL;
   ent->namelen = (u32) strlen(ent->name);
   ent->sep = c;
   parser->current_pos += 1+i;
@@ -674,6 +680,7 @@ static void xml_sax_parse_entity(GF_SAXParser *parser)
   gf_list_add(parser->entities, ent);
   skip_chars = NULL;
  } else if (ent && c==ent->sep) {
   if (ent_name) gf_free(ent_name);
   xml_sax_store_text(parser, i);

   ent->value = xml_get_current_text(parser);
@@ -685,12 +692,14 @@ static void xml_sax_parse_entity(GF_SAXParser *parser)
   parser->sax_state = SAX_STATE_SKIP_DOCTYPE;
   return;
  } else if (!ent) {
   szName[i] = c;
   szC[0] = c;
   gf_dynstrcat(&ent_name, szC, NULL);
   i++;
  } else {
   i++;
  }
 }
 if (ent_name) gf_free(ent_name);
 xml_sax_store_text(parser, i);
}"
https://huntr.dev/bounties/16b9d0ea-71ed-41bc-8a88-2deb4c20be8f/,use after free in mrb_vm_exec in mruby/mruby,Proof of Concept (uaf5.rb),CVE-2022-1106,CWE-416: Use After Free,https://www.github.com/mruby/mruby/commit/7f5a490d09f4d56801ac3a3e4e39e03e1471b44c,"@@ -2819,13 +2819,15 @@ mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)
    }

    CASE(OP_RANGE_INC, B) {
      regs[a] = mrb_range_new(mrb, regs[a], regs[a+1], FALSE);

      mrb_gc_arena_restore(mrb, ai);
      NEXT;
    }

    CASE(OP_RANGE_EXC, B) {
      regs[a] = mrb_range_new(mrb, regs[a], regs[a+1], TRUE);

      mrb_gc_arena_restore(mrb, ai);
      NEXT;
    }

","6
src/vm.c
@@ -2819,13 +2819,15 @@ mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)
    }

    CASE(OP_RANGE_INC, B) {
      regs[a] = mrb_range_new(mrb, regs[a], regs[a+1], FALSE);
      mrb_value v = mrb_range_new(mrb, regs[a], regs[a+1], FALSE);
      regs[a] = v;
      mrb_gc_arena_restore(mrb, ai);
      NEXT;
    }

    CASE(OP_RANGE_EXC, B) {
      regs[a] = mrb_range_new(mrb, regs[a], regs[a+1], TRUE);
      mrb_value v = mrb_range_new(mrb, regs[a], regs[a+1], TRUE);
      regs[a] = v;
      mrb_gc_arena_restore(mrb, ai);
      NEXT;
    }"
https://huntr.dev/bounties/6597ece9-07af-415b-809b-919ce0a17cf3/,User after free in mrb_vm_exec in mruby/mruby,Proof of Concept (uaf1.rb),CVE-2022-1071,CWE-416: Use After Free,https://www.github.com/mruby/mruby/commit/aaa28a508903041dd7399d4159a8ace9766b022f,"@@ -1394,14 +1394,16 @@ mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)
        regs[a] = mrb_ary_entry(va, mrb_integer(vb));
        break;
      case MRB_TT_HASH:
        regs[a] = mrb_hash_get(mrb, va, vb);

        break;
      case MRB_TT_STRING:
        switch (mrb_type(vb)) {
        case MRB_TT_INTEGER:
        case MRB_TT_STRING:
        case MRB_TT_RANGE:
          regs[a] = mrb_str_aref(mrb, va, vb, mrb_undef_value());

          break;
        default:
          goto getidx_fallback;
@@ -1423,7 +1425,8 @@ mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)
    }

    CASE(OP_GETCONST, BB) {
      regs[a] = mrb_vm_const_get(mrb, syms[b]);

      NEXT;
    }

@@ -1433,7 +1436,8 @@ mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)
    }

    CASE(OP_GETMCNST, BB) {
      regs[a] = mrb_const_get(mrb, regs[a], syms[b]);

      NEXT;
    }

@@ -2014,14 +2018,15 @@ mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)
    CASE(OP_KARG, BB) {
      mrb_value k = mrb_symbol_value(syms[b]);
      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);
      mrb_value kdict;

      if (kidx < 0 || !mrb_hash_p(kdict=regs[kidx]) || !mrb_hash_key_p(mrb, kdict, k)) {
        mrb_value str = mrb_format(mrb, ""missing keyword: %v"", k);
        mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));
        goto L_RAISE;
      }
      regs[a] = mrb_hash_get(mrb, kdict, k);

      mrb_hash_delete_key(mrb, kdict, k);
      NEXT;
    }

","17
src/vm.c
@@ -1394,14 +1394,16 @@ mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)
        regs[a] = mrb_ary_entry(va, mrb_integer(vb));
        break;
      case MRB_TT_HASH:
        regs[a] = mrb_hash_get(mrb, va, vb);
        va = mrb_hash_get(mrb, va, vb);
        regs[a] = va;
        break;
      case MRB_TT_STRING:
        switch (mrb_type(vb)) {
        case MRB_TT_INTEGER:
        case MRB_TT_STRING:
        case MRB_TT_RANGE:
          regs[a] = mrb_str_aref(mrb, va, vb, mrb_undef_value());
          va = mrb_str_aref(mrb, va, vb, mrb_undef_value());
          regs[a] = va;
          break;
        default:
          goto getidx_fallback;
@@ -1423,7 +1425,8 @@ mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)
    }

    CASE(OP_GETCONST, BB) {
      regs[a] = mrb_vm_const_get(mrb, syms[b]);
      mrb_value v = mrb_vm_const_get(mrb, syms[b]);
      regs[a] = v;
      NEXT;
    }

@@ -1433,7 +1436,8 @@ mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)
    }

    CASE(OP_GETMCNST, BB) {
      regs[a] = mrb_const_get(mrb, regs[a], syms[b]);
      mrb_value v = mrb_const_get(mrb, regs[a], syms[b]);
      regs[a] = v;
      NEXT;
    }

@@ -2014,14 +2018,15 @@ mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)
    CASE(OP_KARG, BB) {
      mrb_value k = mrb_symbol_value(syms[b]);
      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);
      mrb_value kdict;
      mrb_value kdict, v;

      if (kidx < 0 || !mrb_hash_p(kdict=regs[kidx]) || !mrb_hash_key_p(mrb, kdict, k)) {
        mrb_value str = mrb_format(mrb, ""missing keyword: %v"", k);
        mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));
        goto L_RAISE;
      }
      regs[a] = mrb_hash_get(mrb, kdict, k);
      v = mrb_hash_get(mrb, kdict, k);
      regs[a] = v;
      mrb_hash_delete_key(mrb, kdict, k);
      NEXT;
    }"
https://huntr.dev/bounties/a7546dae-01c5-4fb0-8a8e-c04ea4e9bac7/,Heap Buffer Overflow in parseDragons in radareorg/radare2,heap buffer overflow in parseDragons function.,CVE-2022-1061,CWE-122: Heap-based Buffer Overflow,https://www.github.com/radareorg/radare2/commit/d4ce40b516ffd70cf2e9e36832d8de139117d522,"@@ -181,14 +181,17 @@ static RBinSymbol *bin_symbol_from_symbol(RCoreSymCacheElement *element, RCoreSy

static RCoreSymCacheElement *parseDragons(RBinFile *bf, RBuffer *buf, int off, int bits, R_OWN char *file_name) {
 D eprintf (""Dragons at 0x%x\n"", off);
 ut64 size = r_buf_size (buf);
 if (off >= size) {
  return NULL;
 }
 size -= off;
 if (!size) {
  return NULL;
 }



 ut8 *b = malloc (size);
 if (!b) {
  return NULL;

","5
libr/bin/p/bin_symbols.c
@@ -181,14 +181,17 @@ static RBinSymbol *bin_symbol_from_symbol(RCoreSymCacheElement *element, RCoreSy

static RCoreSymCacheElement *parseDragons(RBinFile *bf, RBuffer *buf, int off, int bits, R_OWN char *file_name) {
 D eprintf (""Dragons at 0x%x\n"", off);
 ut64 size = r_buf_size (buf);
 st64 size = r_buf_size (buf);
 if (off >= size) {
  return NULL;
 }
 size -= off;
 if (!size) {
  return NULL;
 }
 if (size < 32) {
  return NULL;
 }
 ut8 *b = malloc (size);
 if (!b) {
  return NULL;"
https://huntr.dev/bounties/3b3b7f77-ab8d-4de3-999b-eeec0a3eebe7/,Heap Buffer Overflow in iterate_chained_fixups in radareorg/radare2,heap buffer overflow in iterate_chained_fixups function.,CVE-2022-1052,CWE-122: Heap-based Buffer Overflow,https://www.github.com/radareorg/radare2/commit/0052500c1ed5bf8263b26b9fd7773dbdc6f170c4,"@@ -1510,10 +1510,11 @@ static bool parse_chained_fixups(struct MACH0_(obj_t) *bin, ut32 offset, ut32 si
 if (header.starts_offset > size) {
  return false;
 }
 ut32 segs_count;
 if ((segs_count = r_buf_read_le32_at (bin->b, starts_at)) == UT32_MAX) {
  return false;
 }

 bin->chained_starts = R_NEWS0 (struct r_dyld_chained_starts_in_segment *, segs_count);
 if (!bin->chained_starts) {
  return false;
@@ -1699,6 +1700,7 @@ static bool reconstruct_chained_fixup(struct MACH0_(obj_t) *bin) {
 }
 R_FREE (opcodes);


 return true;
}

@@ -2124,7 +2126,7 @@ void *MACH0_(mach0_free)(struct MACH0_(obj_t) *mo) {
 free (mo->intrp);
 free (mo->compiler);
 if (mo->chained_starts) {
  for (i = 0; i < mo->nsegs; i++) {
   if (mo->chained_starts[i]) {
    free (mo->chained_starts[i]->page_start);
    free (mo->chained_starts[i]);
@@ -4558,7 +4560,7 @@ struct MACH0_(mach_header) *MACH0_(get_hdr)(RBuffer *buf) {

void MACH0_(iterate_chained_fixups)(struct MACH0_(obj_t) *bin, ut64 limit_start, ut64 limit_end, ut32 event_mask, RFixupCallback callback, void * context) {
 int i = 0;
 for (; i < bin->nsegs; i++) {
  if (!bin->chained_starts[i]) {
   continue;
  }

@@ -130,6 +130,7 @@ struct MACH0_(obj_t) {
 char *intrp;
 char *compiler;
 int nsegs;

 struct r_dyld_chained_starts_in_segment **chained_starts;
 struct dyld_chained_fixups_header fixups_header;
 ut64 fixups_offset;

@@ -391,7 +391,7 @@ R_API int r_cmd_alias_set_raw(RCmd *cmd, const char *k, const ut8 *v, int sz) {

R_API RCmdAliasVal *r_cmd_alias_get(RCmd *cmd, const char *k) {
 r_return_val_if_fail (cmd && cmd->aliases && k, NULL);
 return ht_pp_find(cmd->aliases, k, NULL);
}

static ut8 *alias_append_internal(int *out_szp, const RCmdAliasVal *first, const ut8 *second, int second_sz) {

","10
libr/bin/format/mach0/mach0.c
@@ -1510,10 +1510,11 @@ static bool parse_chained_fixups(struct MACH0_(obj_t) *bin, ut32 offset, ut32 si
 if (header.starts_offset > size) {
  return false;
 }
 ut32 segs_count;
 if ((segs_count = r_buf_read_le32_at (bin->b, starts_at)) == UT32_MAX) {
 ut32 segs_count = r_buf_read_le32_at (bin->b, starts_at);
 if (segs_count == UT32_MAX || segs_count == 0) {
  return false;
 }
 bin->segs_count = segs_count;
 bin->chained_starts = R_NEWS0 (struct r_dyld_chained_starts_in_segment *, segs_count);
 if (!bin->chained_starts) {
  return false;
@@ -1699,6 +1700,7 @@ static bool reconstruct_chained_fixup(struct MACH0_(obj_t) *bin) {
 }
 R_FREE (opcodes);

 bin->segs_count = bin->nsegs;
 return true;
}

@@ -2124,7 +2126,7 @@ void *MACH0_(mach0_free)(struct MACH0_(obj_t) *mo) {
 free (mo->intrp);
 free (mo->compiler);
 if (mo->chained_starts) {
  for (i = 0; i < mo->nsegs; i++) {
  for (i = 0; i < mo->nsegs && i < mo->segs_count; i++) {
   if (mo->chained_starts[i]) {
    free (mo->chained_starts[i]->page_start);
    free (mo->chained_starts[i]);
@@ -4558,7 +4560,7 @@ struct MACH0_(mach_header) *MACH0_(get_hdr)(RBuffer *buf) {

void MACH0_(iterate_chained_fixups)(struct MACH0_(obj_t) *bin, ut64 limit_start, ut64 limit_end, ut32 event_mask, RFixupCallback callback, void * context) {
 int i = 0;
 for (; i < bin->nsegs; i++) {
 for (; i < bin->nsegs && i < bin->segs_count; i++) {
  if (!bin->chained_starts[i]) {
   continue;
  }
1
libr/bin/format/mach0/mach0.h
@@ -130,6 +130,7 @@ struct MACH0_(obj_t) {
 char *intrp;
 char *compiler;
 int nsegs;
 int segs_count;
 struct r_dyld_chained_starts_in_segment **chained_starts;
 struct dyld_chained_fixups_header fixups_header;
 ut64 fixups_offset;
2
libr/core/cmd_api.c
@@ -391,7 +391,7 @@ R_API int r_cmd_alias_set_raw(RCmd *cmd, const char *k, const ut8 *v, int sz) {

R_API RCmdAliasVal *r_cmd_alias_get(RCmd *cmd, const char *k) {
 r_return_val_if_fail (cmd && cmd->aliases && k, NULL);
 return ht_pp_find(cmd->aliases, k, NULL);
 return ht_pp_find (cmd->aliases, k, NULL);
}

static ut8 *alias_append_internal(int *out_szp, const RCmdAliasVal *first, const ut8 *second, int second_sz) {"
https://huntr.dev/bounties/37da2cd6-0b46-4878-a32e-acbfd8f6f457/,Use After Free in op_is_set_bp in radareorg/radare2,Heap use after free in op_is_set_bp function.,CVE-2022-1031,CWE-416: Use After Free,https://www.github.com/radareorg/radare2/commit/a7ce29647fcb38386d7439696375e16e093d6acb,"@@ -815,7 +815,7 @@ static int fcn_recurse(RAnal *anal, RAnalFunction *fcn, ut64 addr, ut64 len, int
   // note, we have still increased size of basic block
   // (and function)
   if (anal->verbose) {
    eprintf(""Enter branch delay at 0x%08""PFMT64x "". bb->sz=%""PFMT64u""\n"", at - oplen, bb->size);
   }
   delay.idx = idx - oplen;
   delay.cnt = op->delay;
@@ -882,6 +882,12 @@ static int fcn_recurse(RAnal *anal, RAnalFunction *fcn, ut64 addr, ut64 len, int
   // swapped parameters wtf
   r_anal_xrefs_set (anal, op->addr, op->ptr, R_ANAL_REF_TYPE_DATA);
  }






  analyze_retpoline (anal, op);
  switch (op->type & R_ANAL_OP_TYPE_MASK) {
  case R_ANAL_OP_TYPE_CMOV:
@@ -973,7 +979,7 @@ static int fcn_recurse(RAnal *anal, RAnalFunction *fcn, ut64 addr, ut64 len, int
    fcn->bp_off = fcn->stack - op->src[0]->delta;
   }
   if (op->dst && op->dst->reg && op->dst->reg->name && op->ptr > 0 && op->ptr != UT64_MAX) {
    free(last_reg_mov_lea_name);
    if ((last_reg_mov_lea_name = strdup(op->dst->reg->name))) {
     last_reg_mov_lea_val = op->ptr;
     last_is_reg_mov_lea = true;
@@ -1404,10 +1410,13 @@ static int fcn_recurse(RAnal *anal, RAnalFunction *fcn, ut64 addr, ut64 len, int
    }
   }
  }

  if (anal->opt.vars && !varset) {
   // XXX uses op.src/dst and fails because regprofile invalidates the regitems

   r_anal_extract_vars (anal, fcn, op);
  }

  if (op->type != R_ANAL_OP_TYPE_MOV && op->type != R_ANAL_OP_TYPE_CMOV && op->type != R_ANAL_OP_TYPE_LEA) {
   last_is_reg_mov_lea = false;
  }

@@ -1048,7 +1048,7 @@ static void extract_arg(RAnal *anal, RAnalFunction *fcn, RAnalOp *op, const char
  free (vartype);
 } else {
  st64 frame_off = -(ptr + fcn->bp_off);
  if (maxstackframe != 0 && (frame_off > maxstackframe || frame_off < -maxstackframe)) {
   goto beach;
  }
  RAnalVar *var = get_stack_var (fcn, frame_off);

","13
libr/anal/fcn.c
@@ -815,7 +815,7 @@ static int fcn_recurse(RAnal *anal, RAnalFunction *fcn, ut64 addr, ut64 len, int
   // note, we have still increased size of basic block
   // (and function)
   if (anal->verbose) {
    eprintf(""Enter branch delay at 0x%08""PFMT64x "". bb->sz=%""PFMT64u""\n"", at - oplen, bb->size);
    eprintf (""Enter branch delay at 0x%08""PFMT64x "". bb->sz=%""PFMT64u""\n"", at - oplen, bb->size);
   }
   delay.idx = idx - oplen;
   delay.cnt = op->delay;
@@ -882,6 +882,12 @@ static int fcn_recurse(RAnal *anal, RAnalFunction *fcn, ut64 addr, ut64 len, int
   // swapped parameters wtf
   r_anal_xrefs_set (anal, op->addr, op->ptr, R_ANAL_REF_TYPE_DATA);
  }
  if (anal->opt.vars && !varset) {
   // XXX uses op.src/dst and fails because regprofile invalidates the regitems
   // lets just call this BEFORE retpoline() to avoid such issue
   r_anal_extract_vars (anal, fcn, op);
  }
  // this call may cause regprofile changes which cause ranalop.regitem references to be invalid
  analyze_retpoline (anal, op);
  switch (op->type & R_ANAL_OP_TYPE_MASK) {
  case R_ANAL_OP_TYPE_CMOV:
@@ -973,7 +979,7 @@ static int fcn_recurse(RAnal *anal, RAnalFunction *fcn, ut64 addr, ut64 len, int
    fcn->bp_off = fcn->stack - op->src[0]->delta;
   }
   if (op->dst && op->dst->reg && op->dst->reg->name && op->ptr > 0 && op->ptr != UT64_MAX) {
    free(last_reg_mov_lea_name);
    free (last_reg_mov_lea_name);
    if ((last_reg_mov_lea_name = strdup(op->dst->reg->name))) {
     last_reg_mov_lea_val = op->ptr;
     last_is_reg_mov_lea = true;
@@ -1404,10 +1410,13 @@ static int fcn_recurse(RAnal *anal, RAnalFunction *fcn, ut64 addr, ut64 len, int
    }
   }
  }
#if 0
  if (anal->opt.vars && !varset) {
   // XXX uses op.src/dst and fails because regprofile invalidates the regitems
   // we must ranalop in here to avoid uaf
   r_anal_extract_vars (anal, fcn, op);
  }
#endif
  if (op->type != R_ANAL_OP_TYPE_MOV && op->type != R_ANAL_OP_TYPE_CMOV && op->type != R_ANAL_OP_TYPE_LEA) {
   last_is_reg_mov_lea = false;
  }
2
libr/anal/var.c
@@ -1048,7 +1048,7 @@ static void extract_arg(RAnal *anal, RAnalFunction *fcn, RAnalOp *op, const char
  free (vartype);
 } else {
  st64 frame_off = -(ptr + fcn->bp_off);
  if (maxstackframe != 0 && (frame_off > maxstackframe || frame_off < -maxstackframe)) {
  if (maxstackframe > 0 && (frame_off > maxstackframe || frame_off < -maxstackframe)) {
   goto beach;
  }
  RAnalVar *var = get_stack_var (fcn, frame_off);"
https://huntr.dev/bounties/bd129d60-47ce-46b3-b465-ca29f3b918dd/,Untrusted Pointer Dereference in gpac/gpac,Null Pointer Dereference in gpac,,CWE-822: Untrusted Pointer Dereference,https://www.github.com/gpac/gpac/commit/fece8097e1270a2be68acda8dfe9435868a16f8e,,"8
src/media_tools/av_parsers.c
@@ -8500,7 +8500,15 @@ static s32 gf_hevc_read_pps_bs_internal(GF_BitStream *bs, HEVCState *hevc)
 pps->entropy_coding_sync_enabled_flag = gf_bs_read_int_log(bs, 1, ""entropy_coding_sync_enabled_flag"");
 if (pps->tiles_enabled_flag) {
  pps->num_tile_columns = 1 + gf_bs_read_ue_log(bs, ""num_tile_columns_minus1"");
  if (pps->num_tile_columns > 22) {
   GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[HEVC] Invalid num_tile_columns %u\n"", pps->num_tile_columns));
   return -1;
  }
  pps->num_tile_rows = 1 + gf_bs_read_ue_log(bs, ""num_tile_rows_minus1"");
  if (pps->num_tile_rows > 20) {
   GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[HEVC] Invalid num_tile_rows %u\n"", pps->num_tile_rows));
   return -1;
  }
  pps->uniform_spacing_flag = gf_bs_read_int_log(bs, 1, ""uniform_spacing_flag"");
  if (!pps->uniform_spacing_flag) {
   for (i = 0; i < pps->num_tile_columns - 1; i++) {"
https://huntr.dev/bounties/851942a4-1d64-4553-8fdc-9fccd167864b/,Segmentation Fault caused by MP4Box -lsr in gpac/gpac,MP4Box -version,CVE-2022-1035,CWE-476: NULL Pointer Dereference,https://www.github.com/gpac/gpac/commit/3718d583c6ade191dc7979c64f48c001ca6f0243,"@@ -755,8 +755,7 @@ static void gf_dump_vrml_simple_field(GF_SceneDumper *sdump, GF_FieldInfo field,

 switch (field.fieldType) {
 case GF_SG_VRML_SFNODE:
  assert ( *(GF_Node **)field.far_ptr);
  gf_dump_vrml_node(sdump, *(GF_Node **)field.far_ptr, 0, NULL);
  return;
 case GF_SG_VRML_MFNODE:
  list = * ((GF_ChildNodeItem **) field.far_ptr);

","3
src/scene_manager/scene_dump.c
@@ -755,8 +755,7 @@ static void gf_dump_vrml_simple_field(GF_SceneDumper *sdump, GF_FieldInfo field,

 switch (field.fieldType) {
 case GF_SG_VRML_SFNODE:
  assert ( *(GF_Node **)field.far_ptr);
  gf_dump_vrml_node(sdump, *(GF_Node **)field.far_ptr, 0, NULL);
  gf_dump_vrml_node(sdump, field.far_ptr ? *(GF_Node **)field.far_ptr : NULL, 0, NULL);
  return;
 case GF_SG_VRML_MFNODE:
  list = * ((GF_ChildNodeItem **) field.far_ptr);"
https://huntr.dev/bounties/d2f44226-775f-4871-95ab-a33b14755355/,Classic Buffer Overflow in john in openwall/john,"For 1Password Cloud Keychain plugin, the length of inputs are not properly checked. Then inputs are copied to fixed length buffers. For example, creating a salt with a larger length allow a buffer overflow.",,CWE-120: Classic Buffer Overflow,https://www.github.com/openwall/john/commit/a4ecdf40343c523538c8b40c562fe228c4b25b44,"@@ -27,7 +27,7 @@ struct custom_salt {
 unsigned char masterkey[CTLEN];
 unsigned int plaintextlen;
 unsigned int ivlen;
 unsigned char iv[32];
 unsigned int cryptextlen;
 unsigned char cryptext[CTLEN];
 unsigned int expectedhmaclen;

@@ -37,6 +37,8 @@ int cloudkeychain_valid(char *ciphertext, struct fmt_main *self)
 if (!isdec(p))
  goto err;
 len = atoi(p);


 if ((p = strtokm(NULL, ""$"")) == NULL) /* salt */
  goto err;
 if (hexlenl(p, &extra)/2 != len || extra)
@@ -50,6 +52,8 @@ int cloudkeychain_valid(char *ciphertext, struct fmt_main *self)
 if (!isdec(p))
  goto err;
 len = atoi(p);


 if ((p = strtokm(NULL, ""$"")) == NULL) /* masterkey */
  goto err;
 if (hexlenl(p, &extra)/2 != len || extra)

","2
src/cloudkeychain_common.h
@@ -27,7 +27,7 @@ struct custom_salt {
 unsigned char masterkey[CTLEN];
 unsigned int plaintextlen;
 unsigned int ivlen;
 unsigned char iv[32];
 unsigned char iv[IVLEN];
 unsigned int cryptextlen;
 unsigned char cryptext[CTLEN];
 unsigned int expectedhmaclen;
4
src/cloudkeychain_common_plug.c
@@ -37,6 +37,8 @@ int cloudkeychain_valid(char *ciphertext, struct fmt_main *self)
 if (!isdec(p))
  goto err;
 len = atoi(p);
 if (len > SALTLEN)
  goto err;
 if ((p = strtokm(NULL, ""$"")) == NULL) /* salt */
  goto err;
 if (hexlenl(p, &extra)/2 != len || extra)
@@ -50,6 +52,8 @@ int cloudkeychain_valid(char *ciphertext, struct fmt_main *self)
 if (!isdec(p))
  goto err;
 len = atoi(p);
 if (len > CTLEN)
  goto err;
 if ((p = strtokm(NULL, ""$"")) == NULL) /* masterkey */
  goto err;
 if (hexlenl(p, &extra)/2 != len || extra)"
https://huntr.dev/bounties/68e09ec1-6cc7-48b8-981d-30f478c70276/,NULL Pointer Dereference in mruby/mruby,There is a NULL Pointer Dereference in mrb_vm_exec (vm.c:1929). This bug has been found on mruby lastest commit (hash c2f7ed514dfa0fcae2e7e72d51f25be3d3d6d72c) on Ubuntu 20.04 for x86_64/amd64.,CVE-2022-0890,CWE-476: NULL Pointer Dereference,https://www.github.com/mruby/mruby/commit/da48e7dbb20024c198493b8724adae1b842083aa,"@@ -208,15 +208,22 @@ fiber_switch(mrb_state *mrb, mrb_value self, mrb_int len, const mrb_value *a, mr
    if (!c->ci->proc) {
      mrb_raise(mrb, E_FIBER_ERROR, ""double resume (current)"");
    }
    mrb_stack_extend(mrb, len+2); /* for receiver and (optional) block */
    b = c->stbase+1;
    e = b + len;
    while (b<e) {
      *b++ = *a++;
    }
    if (vmexec) {
      c->ci--;                    /* pop dummy callinfo */
    }













    c->cibase->n = len;
    value = c->stbase[0] = MRB_PROC_ENV(c->cibase->proc)->stack[0];
  }

","19
mrbgems/mruby-fiber/src/fiber.c
@@ -208,15 +208,22 @@ fiber_switch(mrb_state *mrb, mrb_value self, mrb_int len, const mrb_value *a, mr
    if (!c->ci->proc) {
      mrb_raise(mrb, E_FIBER_ERROR, ""double resume (current)"");
    }
    mrb_stack_extend(mrb, len+2); /* for receiver and (optional) block */
    b = c->stbase+1;
    e = b + len;
    while (b<e) {
      *b++ = *a++;
    }
    if (vmexec) {
      c->ci--;                    /* pop dummy callinfo */
    }
    if (len >= 15) {
      mrb_stack_extend(mrb, 3);   /* for receiver, args and (optional) block */
      c->stbase[1] = mrb_ary_new_from_values(mrb, len, a);
      len = 15;
    }
    else {
      mrb_stack_extend(mrb, len+2); /* for receiver and (optional) block */
      b = c->stbase+1;
      e = b + len;
      while (b<e) {
        *b++ = *a++;
      }
    }
    c->cibase->n = len;
    value = c->stbase[0] = MRB_PROC_ENV(c->cibase->proc)->stack[0];
  }"
https://huntr.dev/bounties/a83fb1e3-3823-45bd-9c43-39ccd37f7621/,NULL Pointer Dereference in gpac/gpac,NULL Pointer Dereference in MP4BOX,,CWE-476: NULL Pointer Dereference,https://www.github.com/gpac/gpac/commit/6f37ae2a9008d571611fcb228945f7331b26ae24,"@@ -2721,13 +2721,23 @@ GF_Err gf_isom_get_user_data(GF_ISOFile *movie, u32 trackNumber, u32 UserDataTyp
  ptr = (GF_UnknownBox*)gf_list_get(map->boxes, UserDataIndex-1);

  if (ptr->type == GF_ISOM_BOX_TYPE_UNKNOWN) {





   *userData = (char *)gf_malloc(sizeof(char)*ptr->dataSize);
   if (!*userData) return GF_OUT_OF_MEM;
   memcpy(*userData, ptr->data, sizeof(char)*ptr->dataSize);
   *userDataSize = ptr->dataSize;
   return GF_OK;
  } else if (ptr->type == GF_ISOM_BOX_TYPE_UUID) {
   GF_UnknownUUIDBox *p_uuid = (GF_UnknownUUIDBox *)ptr;





   *userData = (char *)gf_malloc(sizeof(char)*p_uuid->dataSize);
   if (!*userData) return GF_OUT_OF_MEM;
   memcpy(*userData, p_uuid->data, sizeof(char)*p_uuid->dataSize);

","10
src/isomedia/isom_read.c
@@ -2721,13 +2721,23 @@ GF_Err gf_isom_get_user_data(GF_ISOFile *movie, u32 trackNumber, u32 UserDataTyp
  ptr = (GF_UnknownBox*)gf_list_get(map->boxes, UserDataIndex-1);

  if (ptr->type == GF_ISOM_BOX_TYPE_UNKNOWN) {
   if (!ptr->dataSize) {
    *userData = NULL;
    *userDataSize = 0;
    return GF_OK;
   }
   *userData = (char *)gf_malloc(sizeof(char)*ptr->dataSize);
   if (!*userData) return GF_OUT_OF_MEM;
   memcpy(*userData, ptr->data, sizeof(char)*ptr->dataSize);
   *userDataSize = ptr->dataSize;
   return GF_OK;
  } else if (ptr->type == GF_ISOM_BOX_TYPE_UUID) {
   GF_UnknownUUIDBox *p_uuid = (GF_UnknownUUIDBox *)ptr;
   if (!p_uuid->dataSize) {
    *userData = NULL;
    *userDataSize = 0;
    return GF_OK;
   }
   *userData = (char *)gf_malloc(sizeof(char)*p_uuid->dataSize);
   if (!*userData) return GF_OUT_OF_MEM;
   memcpy(*userData, p_uuid->data, sizeof(char)*p_uuid->dataSize);"
https://huntr.dev/bounties/d420554c-b36c-4233-974f-2fcd9bad47f0/,Heap-based Buffer Overflow in gpac/gpac,Heap-based Buffer Overflow in gpac,,CWE-122: Heap-based Buffer Overflow,https://www.github.com/gpac/gpac/commit/aa8f03c119fc78bc887eb79dfc4b5f82f3474ed9,"@@ -464,7 +464,7 @@ typedef struct RepFormat
typedef struct
{
 u16 avg_bit_rate, max_bit_rate, avg_pic_rate;
 u8 constand_pic_rate_idc;
} HEVC_RateInfo;


@@ -483,6 +483,7 @@ typedef struct
 HEVC_ProfileTierLevel ptl;

 HEVC_SublayerPTL sub_ptl[8];

 HEVC_RateInfo rates[8];



@@ -1018,7 +1018,7 @@ static void naludmx_create_hevc_decoder_config(GF_NALUDmxCtx *ctx, u8 **dsi, u32

  if (!i) {
   hvcc->avgFrameRate = lvcc->avgFrameRate = vps->rates[0].avg_pic_rate;
   hvcc->constantFrameRate = lvcc->constantFrameRate = vps->rates[0].constand_pic_rate_idc;
   hvcc->numTemporalLayers = lvcc->numTemporalLayers = vps->max_sub_layers;
   hvcc->temporalIdNested = lvcc->temporalIdNested = vps->temporal_id_nesting;
  }
@@ -1183,7 +1183,7 @@ static void naludmx_create_vvc_decoder_config(GF_NALUDmxCtx *ctx, u8 **dsi, u32

  if (!i) {
   cfg->avgFrameRate = vps->rates[0].avg_pic_rate;
   cfg->constantFrameRate = vps->rates[0].constand_pic_rate_idc;
   cfg->numTemporalLayers = vps->max_sub_layers;
  }
  if (!ctx->analyze)

@@ -8195,8 +8195,10 @@ static s32 gf_hevc_read_sps_bs_internal(GF_BitStream *bs, HEVCState *hevc, u8 la
  sps->update_rep_format_flag = gf_bs_read_int_log(bs, 1, ""update_rep_format_flag"");
  if (sps->update_rep_format_flag) {
   sps->rep_format_idx = gf_bs_read_int_log(bs, 8, ""rep_format_idx"");
  }
  else {


   sps->rep_format_idx = vps->rep_format_idx[layer_id];
  }
  sps->width = vps->rep_formats[sps->rep_format_idx].pic_width_luma_samples;

","3
include/gpac/internal/media_dev.h
@@ -464,7 +464,7 @@ typedef struct RepFormat
typedef struct
{
 u16 avg_bit_rate, max_bit_rate, avg_pic_rate;
 u8 constand_pic_rate_idc;
 u8 constant_pic_rate_idc;
} HEVC_RateInfo;


@@ -483,6 +483,7 @@ typedef struct
 HEVC_ProfileTierLevel ptl;

 HEVC_SublayerPTL sub_ptl[8];
 //this is not parsed yet (in VPS VUI)
 HEVC_RateInfo rates[8];


4
src/filters/reframe_nalu.c
@@ -1018,7 +1018,7 @@ static void naludmx_create_hevc_decoder_config(GF_NALUDmxCtx *ctx, u8 **dsi, u32

  if (!i) {
   hvcc->avgFrameRate = lvcc->avgFrameRate = vps->rates[0].avg_pic_rate;
   hvcc->constantFrameRate = lvcc->constantFrameRate = vps->rates[0].constand_pic_rate_idc;
   hvcc->constantFrameRate = lvcc->constantFrameRate = vps->rates[0].constant_pic_rate_idc;
   hvcc->numTemporalLayers = lvcc->numTemporalLayers = vps->max_sub_layers;
   hvcc->temporalIdNested = lvcc->temporalIdNested = vps->temporal_id_nesting;
  }
@@ -1183,7 +1183,7 @@ static void naludmx_create_vvc_decoder_config(GF_NALUDmxCtx *ctx, u8 **dsi, u32

  if (!i) {
   cfg->avgFrameRate = vps->rates[0].avg_pic_rate;
   cfg->constantFrameRate = vps->rates[0].constand_pic_rate_idc;
   cfg->constantFrameRate = vps->rates[0].constant_pic_rate_idc;
   cfg->numTemporalLayers = vps->max_sub_layers;
  }
  if (!ctx->analyze)
6
src/media_tools/av_parsers.c
@@ -8195,8 +8195,10 @@ static s32 gf_hevc_read_sps_bs_internal(GF_BitStream *bs, HEVCState *hevc, u8 la
  sps->update_rep_format_flag = gf_bs_read_int_log(bs, 1, ""update_rep_format_flag"");
  if (sps->update_rep_format_flag) {
   sps->rep_format_idx = gf_bs_read_int_log(bs, 8, ""rep_format_idx"");
  }
  else {
   if (sps->rep_format_idx>15) {
    return -1;
   }
  } else {
   sps->rep_format_idx = vps->rep_format_idx[layer_id];
  }
  sps->width = vps->rep_formats[sps->rep_format_idx].pic_width_luma_samples;"
https://huntr.dev/bounties/29c5f76e-5f1f-43ab-a0c8-e31951e407b6/,Use After Free in r_reg_get_name_idx in radareorg/radare2,heap use after free in r_reg_get_name_idx.,CVE-2022-0849,CWE-416: Use After Free,https://www.github.com/radareorg/radare2/commit/10517e3ff0e609697eb8cde60ec8dc999ee5ea24,"@@ -94,9 +94,11 @@ static inline int kvx_is_tca_opcode(ut32 x) {
 return (major > 1) && (major < 8);
}


static inline int kvx_is_nop_opcode(ut32 x) {
 return ((x)<<1) == 0xFFFFFFFE;
}


static inline int kvx_opc_match(const opc_t *opc, insn_t *insn) {
 int i;

@@ -1,4 +1,4 @@
/* radare - LGPL - Copyright 2009-2021 - pancake, nibble */

#include <r_types.h>
#include <r_list.h>
@@ -4727,7 +4727,7 @@ static bool myvalid(RIO *io, ut64 addr) {
typedef struct {
 RAnalOp *op;
 RAnalFunction *fcn;
 const char *spname;
 ut64 initial_sp;
} EsilBreakCtx;

@@ -5099,7 +5099,7 @@ R_API void r_core_anal_esil(RCore *core, const char *str, const char *target) {
 bool gp_fixed = r_config_get_i (core->config, ""anal.gpfixed"");
 RAnalEsil *ESIL = core->anal->esil;
 ut64 refptr = 0LL;
 const char *pcname;
 RAnalOp op = R_EMPTY;
 ut8 *buf = NULL;
 bool end_address_set = false;
@@ -5188,11 +5188,12 @@ R_API void r_core_anal_esil(RCore *core, const char *str, const char *target) {
  r_core_cmd0 (core, ""aeim"");
  ESIL = core->anal->esil;
 }
 const char *spname = r_reg_get_name (core->anal->reg, R_REG_NAME_SP);
 if (!spname) {
  eprintf (""Error: No =SP defined in the reg profile.\n"");
  return;
 }

 EsilBreakCtx ctx = {
  &op,
  fcn,
@@ -5210,11 +5211,12 @@ R_API void r_core_anal_esil(RCore *core, const char *str, const char *target) {
 }
 //eprintf (""Analyzing ESIL refs from 0x%""PFMT64x"" - 0x%""PFMT64x""\n"", addr, end);
 // TODO: backup/restore register state before/after analysis
 pcname = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);
 if (!pcname || !*pcname) {
  eprintf (""Cannot find program counter register in the current profile.\n"");
  return;
 }

 esil_anal_stop = false;
 r_cons_break_push (cccb, core);

@@ -5299,11 +5301,9 @@ R_API void r_core_anal_esil(RCore *core, const char *str, const char *target) {
  r_anal_op_fini (&op);
  r_asm_set_pc (core->rasm, cur);
  i_old = i;
#if 1
  if (i > iend) {
   goto repeat;
  }
#endif
  if (!r_anal_op (core->anal, &op, cur, buf + i, iend - i, R_ANAL_OP_MASK_ESIL | R_ANAL_OP_MASK_VAL | R_ANAL_OP_MASK_HINT)) {
   i += minopsize - 1; //   XXX dupe in op.size below
  }
@@ -5544,6 +5544,8 @@ R_API void r_core_anal_esil(RCore *core, const char *str, const char *target) {
   break;
  }
 } while (get_next_i (&ictx, &i));


 r_list_free (ictx.bbl);
 r_list_free (ictx.path);
 r_list_free (ictx.switch_path);

","2
libr/anal/arch/kvx/kvx-dis.c
@@ -94,9 +94,11 @@ static inline int kvx_is_tca_opcode(ut32 x) {
 return (major > 1) && (major < 8);
}

#if UNUSED0
static inline int kvx_is_nop_opcode(ut32 x) {
 return ((x)<<1) == 0xFFFFFFFE;
}
#endif

static inline int kvx_opc_match(const opc_t *opc, insn_t *insn) {
 int i;
20
libr/core/canal.c
@@ -1,4 +1,4 @@
/* radare - LGPL - Copyright 2009-2021 - pancake, nibble */
/* radare - LGPL - Copyright 2009-2022 - pancake, nibble */

#include <r_types.h>
#include <r_list.h>
@@ -4727,7 +4727,7 @@ static bool myvalid(RIO *io, ut64 addr) {
typedef struct {
 RAnalOp *op;
 RAnalFunction *fcn;
 const char *spname;
 char *spname;
 ut64 initial_sp;
} EsilBreakCtx;

@@ -5099,7 +5099,7 @@ R_API void r_core_anal_esil(RCore *core, const char *str, const char *target) {
 bool gp_fixed = r_config_get_i (core->config, ""anal.gpfixed"");
 RAnalEsil *ESIL = core->anal->esil;
 ut64 refptr = 0LL;
 const char *pcname;
 char *pcname = NULL;
 RAnalOp op = R_EMPTY;
 ut8 *buf = NULL;
 bool end_address_set = false;
@@ -5188,11 +5188,12 @@ R_API void r_core_anal_esil(RCore *core, const char *str, const char *target) {
  r_core_cmd0 (core, ""aeim"");
  ESIL = core->anal->esil;
 }
 const char *spname = r_reg_get_name (core->anal->reg, R_REG_NAME_SP);
 if (!spname) {
 const char *kspname = r_reg_get_name (core->anal->reg, R_REG_NAME_SP);
 if (R_STR_ISEMPTY (kspname)) {
  eprintf (""Error: No =SP defined in the reg profile.\n"");
  return;
 }
 char *spname = strdup (kspname);
 EsilBreakCtx ctx = {
  &op,
  fcn,
@@ -5210,11 +5211,12 @@ R_API void r_core_anal_esil(RCore *core, const char *str, const char *target) {
 }
 //eprintf (""Analyzing ESIL refs from 0x%""PFMT64x"" - 0x%""PFMT64x""\n"", addr, end);
 // TODO: backup/restore register state before/after analysis
 pcname = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);
 if (!pcname || !*pcname) {
 const char *kpcname = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);
 if (!kpcname || !*kpcname) {
  eprintf (""Cannot find program counter register in the current profile.\n"");
  return;
 }
 pcname = strdup (kpcname);
 esil_anal_stop = false;
 r_cons_break_push (cccb, core);

@@ -5299,11 +5301,9 @@ R_API void r_core_anal_esil(RCore *core, const char *str, const char *target) {
  r_anal_op_fini (&op);
  r_asm_set_pc (core->rasm, cur);
  i_old = i;
#if 1
  if (i > iend) {
   goto repeat;
  }
#endif
  if (!r_anal_op (core->anal, &op, cur, buf + i, iend - i, R_ANAL_OP_MASK_ESIL | R_ANAL_OP_MASK_VAL | R_ANAL_OP_MASK_HINT)) {
   i += minopsize - 1; //   XXX dupe in op.size below
  }
@@ -5544,6 +5544,8 @@ R_API void r_core_anal_esil(RCore *core, const char *str, const char *target) {
   break;
  }
 } while (get_next_i (&ictx, &i));
 free (pcname);
 free (spname);
 r_list_free (ictx.bbl);
 r_list_free (ictx.path);
 r_list_free (ictx.switch_path);"
https://huntr.dev/bounties/baa82f60-f7fd-4dea-8f69-24ccf6f6f759/,Heap-based Buffer Overflow in john in openwall/john,"For PEM plugin, the length of the ciphertext is not properly checked. Then the ciphertext is copied to a fixed length buffer. Creating a ciphertext with a larger length allow a heap overflow.",,CWE-122: Heap-based Buffer Overflow,https://www.github.com/openwall/john/commit/75667e266c2b9356504a86c6013b91a9a3e48c4e,"@@ -65,7 +65,7 @@ int pem_valid(char *ciphertext, struct fmt_main *self)
  goto err;
 if ((p = strtokm(NULL, ""$"")) == NULL)   // salt
  goto err;
 if (hexlenl(p, &extra) != 16 || extra)
  goto err;
 if ((p = strtokm(NULL, ""$"")) == NULL)   // iterations
  goto err;
@@ -81,6 +81,8 @@ int pem_valid(char *ciphertext, struct fmt_main *self)
 if (!isdec(p))
  goto err;
 len = atoi(p);


 if ((p = strtokm(NULL, ""*"")) == NULL)   // ciphertext
  goto err;
 if (hexlenl(p, &extra) != len*2 || extra)

","4
src/pem_common_plug.c
@@ -65,7 +65,7 @@ int pem_valid(char *ciphertext, struct fmt_main *self)
  goto err;
 if ((p = strtokm(NULL, ""$"")) == NULL)   // salt
  goto err;
 if (hexlenl(p, &extra) != 16 || extra)
 if (hexlenl(p, &extra) != SALTLEN * 2 || extra)
  goto err;
 if ((p = strtokm(NULL, ""$"")) == NULL)   // iterations
  goto err;
@@ -81,6 +81,8 @@ int pem_valid(char *ciphertext, struct fmt_main *self)
 if (!isdec(p))
  goto err;
 len = atoi(p);
 if (len > CTLEN)
  goto err;
 if ((p = strtokm(NULL, ""*"")) == NULL)   // ciphertext
  goto err;
 if (hexlenl(p, &extra) != len*2 || extra)"
https://huntr.dev/bounties/bdbddc0e-fb06-4211-a90b-7cbedcee2bea/,Denial of Service in radareorg/radare2,R2 will hang for several crafted binaries.,CVE-2022-0695,CWE-400: Denial of Service,https://www.github.com/radareorg/radare2/commit/634b886e84a5c568d243e744becc6b3223e089cf,"@@ -1,4 +1,4 @@
/* radare - LGPL - Copyright 2008-2021 nibble, pancake, inisider */

#include <stdio.h>
#include <stdlib.h>
@@ -278,15 +278,13 @@ struct r_bin_pe_addr_t *PE_(check_msvcseh)(RBinPEObj *pe) {
}

struct r_bin_pe_addr_t *PE_(check_mingw)(RBinPEObj *pe) {
 struct r_bin_pe_addr_t* entry;
 bool sw = false;
 ut8 b[1024];
 size_t n = 0;
 if (!pe || !pe->b) {
  return 0LL;
 }
 entry = PE_(r_bin_pe_get_entrypoint) (pe);
 ZERO_FILL (b);
 if (r_buf_read_at (pe->b, entry->paddr, b, sizeof (b)) < 0) {
  pe_printf (""Warning: Cannot read entry at 0x%08""PFMT64x ""\n"", entry->paddr);
  free (entry);
@@ -339,11 +337,11 @@ struct r_bin_pe_addr_t *PE_(check_unknow)(RBinPEObj *pe) {
 if (!pe || !pe->b) {
  return 0LL;
 }
 ut8 b[512];
 ZERO_FILL (b);
 entry = PE_ (r_bin_pe_get_entrypoint) (pe);
 // option2: /x 8bff558bec83ec20
 if (r_buf_read_at (pe->b, entry->paddr, b, 512) < 1) {
  pe_printf (""Warning: Cannot read entry at 0x%08""PFMT64x""\n"", entry->paddr);
  free (entry);
  return NULL;
@@ -537,7 +535,8 @@ static int bin_pe_parse_imports(RBinPEObj* pe,
    if (len < 1) {
     pe_printf (""Warning: read (import name)\n"");
     goto error;
    } else if (!*name) {

     break;
    }
    name[PE_NAME_LENGTH] = '\0';
@@ -1258,7 +1257,6 @@ static bool bin_pe_init_metadata_hdr(RBinPEObj* pe) {
 // read the header after the string
 rr = r_buf_fread_at (pe->b, metadata_directory + 16 + metadata->VersionStringLength,
  (ut8*) (&metadata->Flags), pe->big_endian? ""2S"": ""2s"", 1);

 if (rr < 1) {
  goto fail;
 }
@@ -1820,7 +1818,7 @@ static Var* Pe_r_bin_pe_parse_var(RBinPEObj* pe, PE_DWord* curAddr) {
  free_Var (var);
  return NULL;
 }
 if (r_buf_read_at (pe->b, *curAddr, (ut8*) var->szKey, TRANSLATION_UTF_16_LEN) < 1) {
  pe_printf (""Warning: read (Var szKey)\n"");
  free_Var (var);
  return NULL;

@@ -587,7 +587,7 @@ static ut64 estimate_slide(RBinFile *bf, RDyldCache *cache, ut64 value_mask, ut6
  int n_classes = classlist_sample_size / 8;
  ut64 sect_offset = sections[classlist_idx].offset + bin->hdr_offset;

  if (r_buf_fread_at (cache->buf, sect_offset, (ut8*) classlist, ""l"", n_classes) < classlist_sample_size) {
   goto next_bin;
  }


@@ -57,7 +57,7 @@ static RList* sections(RBinFile* bf) {
  return NULL;
 }

 if (r_buf_fread_at (bf->buf, 0, (ut8*)&psxheader, ""8c17i"", 1) < sizeof (psxexe_header)) {
  eprintf (""Truncated Header\n"");
  free (sect);
  r_list_free (ret);
@@ -93,7 +93,7 @@ static RList* entries(RBinFile* bf) {
  return NULL;
 }

 if (r_buf_fread_at (bf->buf, 0, (ut8*)&psxheader, ""8c17i"", 1) < sizeof (psxexe_header)) {
  eprintf (""PSXEXE Header truncated\n"");
  r_list_free (ret);
  free (addr);

@@ -7,7 +7,7 @@ static int lmf_header_load(lmf_header *lmfh, RBuffer *buf, Sdb *db) {
 if (r_buf_size (buf) < sizeof (lmf_header)) {
  return false;
 }
 if (r_buf_fread_at (buf, QNX_HEADER_ADDR, (ut8 *) lmfh, ""iiiiiiiicccciiiicc"", 1) < QNX_HDR_SIZE) {
  return false;
 }
 r_strf_buffer (32);
@@ -64,15 +64,15 @@ static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadadd
  goto beach;
 }
 // Read the first record
 if (r_buf_fread_at (bf->buf, 0, (ut8 *)&lrec, ""ccss"", 1) < QNX_RECORD_SIZE) {
  goto beach;
 }
 // Load the header
 lmf_header_load (&qo->lmfh, bf->buf, qo->kv);
 offset += lrec.data_nbytes;

 for (;;) {
  if (r_buf_fread_at (bf->buf, offset, (ut8 *)&lrec, ""ccss"", 1) < QNX_RECORD_SIZE) {
   goto beach;
  }
  offset += sizeof (lmf_record);
@@ -84,7 +84,7 @@ static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadadd
   if (!ptr) {
    goto beach;
   }
   if (r_buf_fread_at (bf->buf, offset, (ut8 *)&lres, ""ssss"", 1) < sizeof (lmf_resource)) {
    goto beach;
   }
   ptr->name = strdup (""LMF_RESOURCE"");
@@ -95,7 +95,7 @@ static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadadd
    r_list_append (sections, ptr);
  } else if (lrec.rec_type == LMF_LOAD_REC) {
   RBinSection *ptr = R_NEW0 (RBinSection);
   if (r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, ""si"", 1) < sizeof (lmf_data)) {
    goto beach;
   }
   if (!ptr) {
@@ -110,15 +110,15 @@ static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadadd
    r_list_append (sections, ptr);
  } else if (lrec.rec_type == LMF_FIXUP_REC) {
   RBinReloc *ptr = R_NEW0 (RBinReloc);
   if (!ptr || r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, ""si"", 1) < sizeof (lmf_data)) {
    goto beach;
   }
   ptr->vaddr = ptr->paddr = ldata.offset;
   ptr->type = 'f'; // ""LMF_FIXUP"";
   r_list_append (fixups, ptr);
  } else if (lrec.rec_type == LMF_8087_FIXUP_REC) {
   RBinReloc *ptr = R_NEW0 (RBinReloc);
   if (!ptr || r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, ""si"", 1) < sizeof (lmf_data)) {
    goto beach;
   }
   ptr->vaddr = ptr->paddr = ldata.offset;

@@ -516,10 +516,9 @@ static st64 buf_format(RBuffer *dst, RBuffer *src, const char *fmt, int n) {
    ut32 d3;
    ut64 d4;
    st64 r = r_buf_read (src, tmp, tsize);
    if (r < tsize) {
     return -1;
    }

    switch (tsize) {
    case 1:
     d1 = r_read_ble8 (tmp);
@@ -566,7 +565,7 @@ R_API st64 r_buf_fread_at(RBuffer *b, ut64 addr, ut8 *buf, const char *fmt, int
  return r;
 }
 r = r_buf_fread (b, buf, fmt, n);
 r_buf_seek (b, o_addr, R_BUF_SET);
 return r;
}

@@ -598,7 +597,6 @@ R_API st64 r_buf_read_at(RBuffer *b, ut64 addr, ut8 *buf, ut64 len) {
 if (r < 0) {
  return r;
 }

 r = r_buf_read (b, buf, len);
 r_buf_seek (b, o_addr, R_BUF_SET);
 return r;

","18
libr/bin/format/pe/pe.c
@@ -1,4 +1,4 @@
/* radare - LGPL - Copyright 2008-2021 nibble, pancake, inisider */
/* radare - LGPL - Copyright 2008-2022 nibble, pancake, inisider */

#include <stdio.h>
#include <stdlib.h>
@@ -278,15 +278,13 @@ struct r_bin_pe_addr_t *PE_(check_msvcseh)(RBinPEObj *pe) {
}

struct r_bin_pe_addr_t *PE_(check_mingw)(RBinPEObj *pe) {
 struct r_bin_pe_addr_t* entry;
 bool sw = false;
 ut8 b[1024];
 ut8 b[1024] = {0};
 size_t n = 0;
 if (!pe || !pe->b) {
  return 0LL;
 }
 entry = PE_(r_bin_pe_get_entrypoint) (pe);
 ZERO_FILL (b);
 struct r_bin_pe_addr_t* entry = PE_(r_bin_pe_get_entrypoint) (pe);
 if (r_buf_read_at (pe->b, entry->paddr, b, sizeof (b)) < 0) {
  pe_printf (""Warning: Cannot read entry at 0x%08""PFMT64x ""\n"", entry->paddr);
  free (entry);
@@ -339,11 +337,11 @@ struct r_bin_pe_addr_t *PE_(check_unknow)(RBinPEObj *pe) {
 if (!pe || !pe->b) {
  return 0LL;
 }
 ut8 b[512];
 ut8 b[512] = {0};
 ZERO_FILL (b);
 entry = PE_ (r_bin_pe_get_entrypoint) (pe);
 // option2: /x 8bff558bec83ec20
 if (r_buf_read_at (pe->b, entry->paddr, b, 512) < 1) {
 if (r_buf_read_at (pe->b, entry->paddr, b, sizeof (b)) != sizeof (b)) {
  pe_printf (""Warning: Cannot read entry at 0x%08""PFMT64x""\n"", entry->paddr);
  free (entry);
  return NULL;
@@ -537,7 +535,8 @@ static int bin_pe_parse_imports(RBinPEObj* pe,
    if (len < 1) {
     pe_printf (""Warning: read (import name)\n"");
     goto error;
    } else if (!*name) {
    }
    if (!*name) {
     break;
    }
    name[PE_NAME_LENGTH] = '\0';
@@ -1258,7 +1257,6 @@ static bool bin_pe_init_metadata_hdr(RBinPEObj* pe) {
 // read the header after the string
 rr = r_buf_fread_at (pe->b, metadata_directory + 16 + metadata->VersionStringLength,
  (ut8*) (&metadata->Flags), pe->big_endian? ""2S"": ""2s"", 1);

 if (rr < 1) {
  goto fail;
 }
@@ -1820,7 +1818,7 @@ static Var* Pe_r_bin_pe_parse_var(RBinPEObj* pe, PE_DWord* curAddr) {
  free_Var (var);
  return NULL;
 }
 if (r_buf_read_at (pe->b, *curAddr, (ut8*) var->szKey, TRANSLATION_UTF_16_LEN) < 1) {
 if (r_buf_read_at (pe->b, *curAddr, (ut8*) var->szKey, TRANSLATION_UTF_16_LEN) != TRANSLATION_UTF_16_LEN) {
  pe_printf (""Warning: read (Var szKey)\n"");
  free_Var (var);
  return NULL;
2
libr/bin/p/bin_dyldcache.c
@@ -587,7 +587,7 @@ static ut64 estimate_slide(RBinFile *bf, RDyldCache *cache, ut64 value_mask, ut6
  int n_classes = classlist_sample_size / 8;
  ut64 sect_offset = sections[classlist_idx].offset + bin->hdr_offset;

  if (r_buf_fread_at (cache->buf, sect_offset, (ut8*) classlist, ""l"", n_classes) < classlist_sample_size) {
  if (r_buf_fread_at (cache->buf, sect_offset, (ut8*) classlist, ""l"", n_classes) != classlist_sample_size) {
   goto next_bin;
  }

4
libr/bin/p/bin_psxexe.c
@@ -57,7 +57,7 @@ static RList* sections(RBinFile* bf) {
  return NULL;
 }

 if (r_buf_fread_at (bf->buf, 0, (ut8*)&psxheader, ""8c17i"", 1) < sizeof (psxexe_header)) {
 if (r_buf_fread_at (bf->buf, 0, (ut8*)&psxheader, ""8c17i"", 1) != sizeof (psxexe_header)) {
  eprintf (""Truncated Header\n"");
  free (sect);
  r_list_free (ret);
@@ -93,7 +93,7 @@ static RList* entries(RBinFile* bf) {
  return NULL;
 }

 if (r_buf_fread_at (bf->buf, 0, (ut8*)&psxheader, ""8c17i"", 1) < sizeof (psxexe_header)) {
 if (r_buf_fread_at (bf->buf, 0, (ut8*)&psxheader, ""8c17i"", 1) != sizeof (psxexe_header)) {
  eprintf (""PSXEXE Header truncated\n"");
  r_list_free (ret);
  free (addr);
14
libr/bin/p/bin_qnx.c
@@ -7,7 +7,7 @@ static int lmf_header_load(lmf_header *lmfh, RBuffer *buf, Sdb *db) {
 if (r_buf_size (buf) < sizeof (lmf_header)) {
  return false;
 }
 if (r_buf_fread_at (buf, QNX_HEADER_ADDR, (ut8 *) lmfh, ""iiiiiiiicccciiiicc"", 1) < QNX_HDR_SIZE) {
 if (r_buf_fread_at (buf, QNX_HEADER_ADDR, (ut8 *) lmfh, ""iiiiiiiicccciiiicc"", 1) != QNX_HDR_SIZE) {
  return false;
 }
 r_strf_buffer (32);
@@ -64,15 +64,15 @@ static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadadd
  goto beach;
 }
 // Read the first record
 if (r_buf_fread_at (bf->buf, 0, (ut8 *)&lrec, ""ccss"", 1) < QNX_RECORD_SIZE) {
 if (r_buf_fread_at (bf->buf, 0, (ut8 *)&lrec, ""ccss"", 1) != QNX_RECORD_SIZE) {
  goto beach;
 }
 // Load the header
 lmf_header_load (&qo->lmfh, bf->buf, qo->kv);
 offset += lrec.data_nbytes;

 for (;;) {
  if (r_buf_fread_at (bf->buf, offset, (ut8 *)&lrec, ""ccss"", 1) < QNX_RECORD_SIZE) {
  if (r_buf_fread_at (bf->buf, offset, (ut8 *)&lrec, ""ccss"", 1) != QNX_RECORD_SIZE) {
   goto beach;
  }
  offset += sizeof (lmf_record);
@@ -84,7 +84,7 @@ static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadadd
   if (!ptr) {
    goto beach;
   }
   if (r_buf_fread_at (bf->buf, offset, (ut8 *)&lres, ""ssss"", 1) < sizeof (lmf_resource)) {
   if (r_buf_fread_at (bf->buf, offset, (ut8 *)&lres, ""ssss"", 1) != sizeof (lmf_resource)) {
    goto beach;
   }
   ptr->name = strdup (""LMF_RESOURCE"");
@@ -95,7 +95,7 @@ static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadadd
    r_list_append (sections, ptr);
  } else if (lrec.rec_type == LMF_LOAD_REC) {
   RBinSection *ptr = R_NEW0 (RBinSection);
   if (r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, ""si"", 1) < sizeof (lmf_data)) {
   if (r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, ""si"", 1) != sizeof (lmf_data)) {
    goto beach;
   }
   if (!ptr) {
@@ -110,15 +110,15 @@ static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadadd
    r_list_append (sections, ptr);
  } else if (lrec.rec_type == LMF_FIXUP_REC) {
   RBinReloc *ptr = R_NEW0 (RBinReloc);
   if (!ptr || r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, ""si"", 1) < sizeof (lmf_data)) {
   if (!ptr || r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, ""si"", 1) != sizeof (lmf_data)) {
    goto beach;
   }
   ptr->vaddr = ptr->paddr = ldata.offset;
   ptr->type = 'f'; // ""LMF_FIXUP"";
   r_list_append (fixups, ptr);
  } else if (lrec.rec_type == LMF_8087_FIXUP_REC) {
   RBinReloc *ptr = R_NEW0 (RBinReloc);
   if (!ptr || r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, ""si"", 1) < sizeof (lmf_data)) {
   if (!ptr || r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, ""si"", 1) != sizeof (lmf_data)) {
    goto beach;
   }
   ptr->vaddr = ptr->paddr = ldata.offset;
6
libr/util/buf.c
@@ -516,10 +516,9 @@ static st64 buf_format(RBuffer *dst, RBuffer *src, const char *fmt, int n) {
    ut32 d3;
    ut64 d4;
    st64 r = r_buf_read (src, tmp, tsize);
    if (r < tsize) {
    if (r != tsize) {
     return -1;
    }

    switch (tsize) {
    case 1:
     d1 = r_read_ble8 (tmp);
@@ -566,7 +565,7 @@ R_API st64 r_buf_fread_at(RBuffer *b, ut64 addr, ut8 *buf, const char *fmt, int
  return r;
 }
 r = r_buf_fread (b, buf, fmt, n);
 r_buf_seek (b, o_addr, R_BUF_SET);
 (void)r_buf_seek (b, o_addr, R_BUF_SET);
 return r;
}

@@ -598,7 +597,6 @@ R_API st64 r_buf_read_at(RBuffer *b, ut64 addr, ut8 *buf, ut64 len) {
 if (r < 0) {
  return r;
 }

 r = r_buf_read (b, buf, len);
 r_buf_seek (b, o_addr, R_BUF_SET);
 return r;"
https://huntr.dev/bounties/27a851a5-7ebf-409b-854f-b2614771e8f9/,Out-of-bounds Read in mruby/mruby,OOB read occurs in mrb_ary_push().,CVE-2022-0717,CWE-125: Out-of-bounds Read,https://www.github.com/mruby/mruby/commit/f72315575f78a9a773adbce0ee7d3ec33434cb76,"@@ -1904,8 +1904,12 @@ gen_assignment(codegen_scope *s, node *tree, node *rhs, int sp, int val)
      if (val) {
        gen_move(s, top, cursp(), 1);
      }
      if (n < 14) {
        n++;




      }
      else {
        pop();

","6
mrbgems/mruby-compiler/core/codegen.c
@@ -1904,8 +1904,12 @@ gen_assignment(codegen_scope *s, node *tree, node *rhs, int sp, int val)
      if (val) {
        gen_move(s, top, cursp(), 1);
      }
      if (n < 14) {
      if (n < 15) {
        n++;
        if (n == 15) {
          pop_n(14);
          genop_2(s, OP_ARRAY, cursp(), 15);
        }
      }
      else {
        pop();"
https://huntr.dev/bounties/d35b3dff-768d-4a09-a742-c18ca8f56d3c/,Heap-based Buffer Overflow in radareorg/radare2,heap-buffer-overflow /home/ubuntu/fuzz/radare2/libr/include/r_endian.h:176 in r_read_le32,CVE-2022-0713,CWE-122: Heap-based Buffer Overflow,https://www.github.com/radareorg/radare2/commit/a35f89f86ed12161af09330e92e5a213014e46a1,"@@ -222,7 +222,7 @@ RCoreSymCacheElement *r_coresym_cache_element_new(RBinFile *bf, RBuffer *buf, ut
  }
  size_t i;
  ut8 *cursor = b + R_CS_EL_OFF_SEGS;
  for (i = 0; i < hdr->n_segments && cursor < end; i++) {
   RCoreSymCacheElementSegment *seg = &result->segments[i];
   seg->paddr = seg->vaddr = r_read_le64 (cursor);
   cursor += 8;

","2
libr/bin/format/mach0/coresymbolication.c
@@ -222,7 +222,7 @@ RCoreSymCacheElement *r_coresym_cache_element_new(RBinFile *bf, RBuffer *buf, ut
  }
  size_t i;
  ut8 *cursor = b + R_CS_EL_OFF_SEGS;
  for (i = 0; i < hdr->n_segments && cursor < end; i++) {
  for (i = 0; i < hdr->n_segments && cursor + sizeof (RCoreSymCacheElementSegment) < end; i++) {
   RCoreSymCacheElementSegment *seg = &result->segments[i];
   seg->paddr = seg->vaddr = r_read_le64 (cursor);
   cursor += 8;"
https://huntr.dev/bounties/1e572820-e502-49d1-af0e-81833e2eb466/,NULL Pointer Dereference in radareorg/radare2,NULL pointer dereference in bin_symbols.c,CVE-2022-0712,CWE-476: NULL Pointer Dereference,https://www.github.com/radareorg/radare2/commit/515e592b9bea0612bc63d8e93239ff35bcf645c7,"@@ -1,4 +1,4 @@
/* radare - LGPL - Copyright 2018 - pancake */

#include <r_types.h>
#include <r_util.h>
@@ -361,6 +361,9 @@ static RList *symbols(RBinFile *bf) {
 bool found = false;
 for (i = 0; i < element->hdr->n_lined_symbols; i++) {
  RCoreSymCacheElementSymbol *sym = (RCoreSymCacheElementSymbol *)&element->lined_symbols[i];



  ht_uu_find (hash, sym->paddr, &found);
  if (found) {
   continue;

","5
libr/bin/p/bin_symbols.c
@@ -1,4 +1,4 @@
/* radare - LGPL - Copyright 2018 - pancake */
/* radare - LGPL - Copyright 2018-2022 - pancake */

#include <r_types.h>
#include <r_util.h>
@@ -361,6 +361,9 @@ static RList *symbols(RBinFile *bf) {
 bool found = false;
 for (i = 0; i < element->hdr->n_lined_symbols; i++) {
  RCoreSymCacheElementSymbol *sym = (RCoreSymCacheElementSymbol *)&element->lined_symbols[i];
  if (!sym) {
   break;
  }
  ht_uu_find (hash, sym->paddr, &found);
  if (found) {
   continue;"
https://huntr.dev/bounties/81ddfbda-6c9f-4b69-83ff-85b15141e35d/,Denial of Service in radareorg/radare2,A malformed mdmp file causes a DoS attack and leads to resource exhaustion.,CVE-2022-0476,CWE-400: Denial of Service,https://www.github.com/radareorg/radare2/commit/27fe8031782d3a06c3998eaa94354867864f9f1b,"@@ -369,9 +369,15 @@ static bool r_bin_mdmp_init_hdr(struct r_bin_mdmp_obj *obj) {
 return true;
}

static void read_module(RBuffer *b, ut64 addr, struct minidump_module *module) {
 st64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);
 r_buf_seek (b, addr, R_BUF_SET);






 module->base_of_image = r_buf_read_le64 (b);
 module->size_of_image = r_buf_read_le32 (b);
 module->check_sum = r_buf_read_le32 (b);
@@ -397,6 +403,7 @@ static void read_module(RBuffer *b, ut64 addr, struct minidump_module *module) {
 module->reserved_0 = r_buf_read_le64 (b);
 module->reserved_1 = r_buf_read_le64 (b);
 r_buf_seek (b, o_addr, R_BUF_SET);

}

static void read_memory64_list(RBuffer *b, ut64 addr, struct minidump_memory64_list *memory64_list) {
@@ -477,12 +484,11 @@ static bool r_bin_mdmp_init_directory_entry(struct r_bin_mdmp_obj *obj, struct m
   0);

  offset = entry->location.rva + sizeof (module_list);
  for (i = 0; i < module_list.number_of_modules; i++) {
   struct minidump_module *module = R_NEW (struct minidump_module);
   if (!module) {
    break;
   }
   read_module (obj->b, offset, module);
   r_list_append (obj->streams.modules, module);
   offset += sizeof (*module);
  }
@@ -503,7 +509,7 @@ static bool r_bin_mdmp_init_directory_entry(struct r_bin_mdmp_obj *obj, struct m
   0);

  offset = entry->location.rva + sizeof (memory_list);
  for (i = 0; i < memory_list.number_of_memory_ranges; i++) {
   struct minidump_memory_descriptor *desc = R_NEW (struct minidump_memory_descriptor);
   if (!desc) {
    break;
@@ -586,7 +592,7 @@ static bool r_bin_mdmp_init_directory_entry(struct r_bin_mdmp_obj *obj, struct m
   0);

  offset = entry->location.rva + sizeof (thread_ex_list);
  for (i = 0; i < thread_ex_list.number_of_threads; i++) {
   struct minidump_thread_ex *thread = R_NEW (struct minidump_thread_ex);
   if (!thread) {
    break;
@@ -613,7 +619,7 @@ static bool r_bin_mdmp_init_directory_entry(struct r_bin_mdmp_obj *obj, struct m

  obj->streams.memories64.base_rva = memory64_list.base_rva;
  offset = entry->location.rva + sizeof (memory64_list);
  for (i = 0; i < memory64_list.number_of_memory_ranges; i++) {
   struct minidump_memory_descriptor64 *desc = R_NEW (struct minidump_memory_descriptor64);
   if (!desc) {
    break;
@@ -708,7 +714,7 @@ static bool r_bin_mdmp_init_directory_entry(struct r_bin_mdmp_obj *obj, struct m
   ""SizeOfHeader SizeOfEntry NumberOfEntries"", 0);

  offset = entry->location.rva + sizeof (unloaded_module_list);
  for (i = 0; i < unloaded_module_list.number_of_entries; i++) {
   struct minidump_unloaded_module *module = R_NEW (struct minidump_unloaded_module);
   if (!module) {
    break;
@@ -763,7 +769,7 @@ static bool r_bin_mdmp_init_directory_entry(struct r_bin_mdmp_obj *obj, struct m
   0);

  offset = entry->location.rva + sizeof (memory_info_list);
  for (i = 0; i < memory_info_list.number_of_entries; i++) {
   struct minidump_memory_info *info = R_NEW (struct minidump_memory_info);
   if (!info) {
    break;
@@ -793,7 +799,7 @@ static bool r_bin_mdmp_init_directory_entry(struct r_bin_mdmp_obj *obj, struct m
   ""SizeOfHeader SizeOfEntry NumberOfEntries"", 0);

  offset = entry->location.rva + sizeof (thread_info_list);
  for (i = 0; i < thread_info_list.number_of_entries; i++) {
   struct minidump_thread_info *info = R_NEW (struct minidump_thread_info);
   if (!info) {
    break;
@@ -819,7 +825,7 @@ static bool r_bin_mdmp_init_directory_entry(struct r_bin_mdmp_obj *obj, struct m
   ""SizeOfHeader SizeOfEntry NumberOfEntries Reserved"", 0);

  offset = entry->location.rva + sizeof (handle_operation_list);
  for (i = 0; i < handle_operation_list.number_of_entries; i++) {
   struct avrf_handle_operation *op = R_NEW (struct avrf_handle_operation);
   if (!op) {
    break;
@@ -849,7 +855,7 @@ static bool r_bin_mdmp_init_directory_entry(struct r_bin_mdmp_obj *obj, struct m
   ""TokenListSize TokenListEntries ListHeaderSize ElementHeaderSize"", 0);

  offset = entry->location.rva + sizeof (token_info_list);
  for (i = 0; i < token_info_list.number_of_entries; i++) {
   struct minidump_token_info *info = R_NEW (struct minidump_token_info);
   if (!info) {
    break;

","34
libr/bin/format/mdmp/mdmp.c
@@ -369,9 +369,15 @@ static bool r_bin_mdmp_init_hdr(struct r_bin_mdmp_obj *obj) {
 return true;
}

static void read_module(RBuffer *b, ut64 addr, struct minidump_module *module) {
static struct minidump_module *read_module(RBuffer *b, ut64 addr) {
 st64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);
 r_buf_seek (b, addr, R_BUF_SET);
 if (r_buf_seek (b, addr, R_BUF_SET) == -1) {
  return NULL;
 }
 struct minidump_module *module = R_NEW0 (struct minidump_module);
 if (!module) {
  return NULL;
 }
 module->base_of_image = r_buf_read_le64 (b);
 module->size_of_image = r_buf_read_le32 (b);
 module->check_sum = r_buf_read_le32 (b);
@@ -397,6 +403,7 @@ static void read_module(RBuffer *b, ut64 addr, struct minidump_module *module) {
 module->reserved_0 = r_buf_read_le64 (b);
 module->reserved_1 = r_buf_read_le64 (b);
 r_buf_seek (b, o_addr, R_BUF_SET);
 return module;
}

static void read_memory64_list(RBuffer *b, ut64 addr, struct minidump_memory64_list *memory64_list) {
@@ -477,12 +484,11 @@ static bool r_bin_mdmp_init_directory_entry(struct r_bin_mdmp_obj *obj, struct m
   0);

  offset = entry->location.rva + sizeof (module_list);
  for (i = 0; i < module_list.number_of_modules; i++) {
   struct minidump_module *module = R_NEW (struct minidump_module);
  for (i = 0; i < module_list.number_of_modules && offset < obj->size; i++) {
   struct minidump_module *module = read_module (obj->b, offset);
   if (!module) {
    break;
    break; 
   }
   read_module (obj->b, offset, module);
   r_list_append (obj->streams.modules, module);
   offset += sizeof (*module);
  }
@@ -503,7 +509,7 @@ static bool r_bin_mdmp_init_directory_entry(struct r_bin_mdmp_obj *obj, struct m
   0);

  offset = entry->location.rva + sizeof (memory_list);
  for (i = 0; i < memory_list.number_of_memory_ranges; i++) {
  for (i = 0; i < memory_list.number_of_memory_ranges && offset < obj->size; i++) {
   struct minidump_memory_descriptor *desc = R_NEW (struct minidump_memory_descriptor);
   if (!desc) {
    break;
@@ -586,7 +592,7 @@ static bool r_bin_mdmp_init_directory_entry(struct r_bin_mdmp_obj *obj, struct m
   0);

  offset = entry->location.rva + sizeof (thread_ex_list);
  for (i = 0; i < thread_ex_list.number_of_threads; i++) {
  for (i = 0; i < thread_ex_list.number_of_threads && offset < obj->size; i++) {
   struct minidump_thread_ex *thread = R_NEW (struct minidump_thread_ex);
   if (!thread) {
    break;
@@ -613,7 +619,7 @@ static bool r_bin_mdmp_init_directory_entry(struct r_bin_mdmp_obj *obj, struct m

  obj->streams.memories64.base_rva = memory64_list.base_rva;
  offset = entry->location.rva + sizeof (memory64_list);
  for (i = 0; i < memory64_list.number_of_memory_ranges; i++) {
  for (i = 0; i < memory64_list.number_of_memory_ranges && offset < obj->size; i++) {
   struct minidump_memory_descriptor64 *desc = R_NEW (struct minidump_memory_descriptor64);
   if (!desc) {
    break;
@@ -708,7 +714,7 @@ static bool r_bin_mdmp_init_directory_entry(struct r_bin_mdmp_obj *obj, struct m
   ""SizeOfHeader SizeOfEntry NumberOfEntries"", 0);

  offset = entry->location.rva + sizeof (unloaded_module_list);
  for (i = 0; i < unloaded_module_list.number_of_entries; i++) {
  for (i = 0; i < unloaded_module_list.number_of_entries && offset < obj->size; i++) {
   struct minidump_unloaded_module *module = R_NEW (struct minidump_unloaded_module);
   if (!module) {
    break;
@@ -763,7 +769,7 @@ static bool r_bin_mdmp_init_directory_entry(struct r_bin_mdmp_obj *obj, struct m
   0);

  offset = entry->location.rva + sizeof (memory_info_list);
  for (i = 0; i < memory_info_list.number_of_entries; i++) {
  for (i = 0; i < memory_info_list.number_of_entries && offset < obj->size; i++) {
   struct minidump_memory_info *info = R_NEW (struct minidump_memory_info);
   if (!info) {
    break;
@@ -793,7 +799,7 @@ static bool r_bin_mdmp_init_directory_entry(struct r_bin_mdmp_obj *obj, struct m
   ""SizeOfHeader SizeOfEntry NumberOfEntries"", 0);

  offset = entry->location.rva + sizeof (thread_info_list);
  for (i = 0; i < thread_info_list.number_of_entries; i++) {
  for (i = 0; i < thread_info_list.number_of_entries && offset < obj->size; i++) {
   struct minidump_thread_info *info = R_NEW (struct minidump_thread_info);
   if (!info) {
    break;
@@ -819,7 +825,7 @@ static bool r_bin_mdmp_init_directory_entry(struct r_bin_mdmp_obj *obj, struct m
   ""SizeOfHeader SizeOfEntry NumberOfEntries Reserved"", 0);

  offset = entry->location.rva + sizeof (handle_operation_list);
  for (i = 0; i < handle_operation_list.number_of_entries; i++) {
  for (i = 0; i < handle_operation_list.number_of_entries && offset < obj->size; i++) {
   struct avrf_handle_operation *op = R_NEW (struct avrf_handle_operation);
   if (!op) {
    break;
@@ -849,7 +855,7 @@ static bool r_bin_mdmp_init_directory_entry(struct r_bin_mdmp_obj *obj, struct m
   ""TokenListSize TokenListEntries ListHeaderSize ElementHeaderSize"", 0);

  offset = entry->location.rva + sizeof (token_info_list);
  for (i = 0; i < token_info_list.number_of_entries; i++) {
  for (i = 0; i < token_info_list.number_of_entries && offset < obj->size; i++) {
   struct minidump_token_info *info = R_NEW (struct minidump_token_info);
   if (!info) {
    break;"
https://huntr.dev/bounties/5ad814a1-5dd3-43f4-869b-33b8dab78485/,Heap-based Buffer Overflow in radareorg/radare2,There is a heap corruption when r2 processes a crafted dyldcache file. Confirmed on the latest release 5.6.2 and the master branch.,CVE-2022-0676,CWE-122: Heap-based Buffer Overflow,https://www.github.com/radareorg/radare2/commit/c84b7232626badd075caf3ae29661b609164bac6,"@@ -1144,6 +1144,8 @@ static ut64 resolve_symbols_off(RDyldCache *cache, ut64 pa) {

static RList *create_cache_bins(RBinFile *bf, RDyldCache *cache) {
 RList *bins = r_list_newf ((RListFree)free_bin);


 if (!bins) {
  return NULL;
 }
@@ -1177,8 +1179,6 @@ static RList *create_cache_bins(RBinFile *bf, RDyldCache *cache) {
  }

  ut32 j;
  ut16 *depArray = NULL;
  cache_imgxtr_t *extras = NULL;
  if (target_libs) {
   HtPU *path_to_idx = NULL;
   if (cache->accel) {
@@ -1734,12 +1734,12 @@ static void populate_cache_maps(RDyldCache *cache) {
 cache->n_maps = next_map;
}

static cache_accel_t *read_cache_accel(RBuffer *cache_buf, cache_hdr_t *hdr, cache_map_t *maps) {
 if (!cache_buf || !hdr || !hdr->accelerateInfoSize || !hdr->accelerateInfoAddr) {
  return NULL;
 }

 ut64 offset = va2pa (hdr->accelerateInfoAddr, hdr->mappingCount, maps, cache_buf, 0, NULL, NULL);
 if (!offset) {
  return NULL;
 }
@@ -1895,7 +1895,7 @@ static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadadd
  r_dyldcache_free (cache);
  return false;
 }
 cache->accel = read_cache_accel (cache->buf, cache->hdr, cache->maps);
 cache->bins = create_cache_bins (bf, cache);
 if (!cache->bins) {
  r_dyldcache_free (cache);

","12
libr/bin/p/bin_dyldcache.c
@@ -1144,6 +1144,8 @@ static ut64 resolve_symbols_off(RDyldCache *cache, ut64 pa) {

static RList *create_cache_bins(RBinFile *bf, RDyldCache *cache) {
 RList *bins = r_list_newf ((RListFree)free_bin);
 ut16 *depArray = NULL;
 cache_imgxtr_t *extras = NULL;
 if (!bins) {
  return NULL;
 }
@@ -1177,8 +1179,6 @@ static RList *create_cache_bins(RBinFile *bf, RDyldCache *cache) {
  }

  ut32 j;
  ut16 *depArray = NULL;
  cache_imgxtr_t *extras = NULL;
  if (target_libs) {
   HtPU *path_to_idx = NULL;
   if (cache->accel) {
@@ -1734,12 +1734,12 @@ static void populate_cache_maps(RDyldCache *cache) {
 cache->n_maps = next_map;
}

static cache_accel_t *read_cache_accel(RBuffer *cache_buf, cache_hdr_t *hdr, cache_map_t *maps) {
static cache_accel_t *read_cache_accel(RBuffer *cache_buf, cache_hdr_t *hdr, cache_map_t *maps, int n_maps) {
 if (!cache_buf || !hdr || !hdr->accelerateInfoSize || !hdr->accelerateInfoAddr) {
  return NULL;
 }

 ut64 offset = va2pa (hdr->accelerateInfoAddr, hdr->mappingCount, maps, cache_buf, 0, NULL, NULL);
 size_t mc = R_MIN (hdr->mappingCount, n_maps);
 ut64 offset = va2pa (hdr->accelerateInfoAddr, mc, maps, cache_buf, 0, NULL, NULL);
 if (!offset) {
  return NULL;
 }
@@ -1895,7 +1895,7 @@ static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadadd
  r_dyldcache_free (cache);
  return false;
 }
 cache->accel = read_cache_accel (cache->buf, cache->hdr, cache->maps);
 cache->accel = read_cache_accel (cache->buf, cache->hdr, cache->maps, cache->n_maps);
 cache->bins = create_cache_bins (bf, cache);
 if (!cache->bins) {
  r_dyldcache_free (cache);"
https://huntr.dev/bounties/3e5bb8f6-30fd-4553-86dd-761e9459ce1b/,NULL Pointer Dereference in mruby/mruby,There is a NULL Pointer Dereference in ary_concat (array.c:301). This bug has been found on mruby lastest commit (hash ecb28f4bf463483cf914c799d086b0cfff997aee) on Ubuntu 20.04 for x86_64/amd64.,CVE-2022-0632,CWE-476: NULL Pointer Dereference,https://www.github.com/mruby/mruby/commit/44f591aa8f7091e6ca6cb418e428ae6d4ceaf77d,"@@ -2954,19 +2954,20 @@ codegen(codegen_scope *s, node *tree, int val)
        if (tree->cdr->cdr) {
          codegen(s, tree->cdr->cdr, VAL);
        }
        else if (!s2) {/* super at top-level */
          push();      /* no need to push block */
        }
        else {
          gen_blkmove(s, s2->ainfo, lv);

        }
        st++;
      }
      else {
        if (!s2) push();
        else gen_blkmove(s, s2->ainfo, lv);
        st++;


      }

      pop_n(st+1);
      genop_2(s, OP_SUPER, cursp(), n);
      if (val) push();
@@ -3218,6 +3219,7 @@ codegen(codegen_scope *s, node *tree, int val)
        codegen_error(s, ""no anonymous block argument"");
      }
      gen_move(s, cursp(), idx, val);

    }
    else {
      codegen(s, tree, val);

","18
mrbgems/mruby-compiler/core/codegen.c
@@ -2954,19 +2954,20 @@ codegen(codegen_scope *s, node *tree, int val)
        if (tree->cdr->cdr) {
          codegen(s, tree->cdr->cdr, VAL);
        }
        else if (!s2) {/* super at top-level */
          push();      /* no need to push block */
        }
        else if (s2) gen_blkmove(s, s2->ainfo, lv);
        else {
          gen_blkmove(s, s2->ainfo, lv);
          genop_1(s, OP_LOADNIL, cursp());
          push();
        }
        st++;
      }
      else {
        if (!s2) push();
        else gen_blkmove(s, s2->ainfo, lv);
        st++;
        if (s2) gen_blkmove(s, s2->ainfo, lv);
        else {
          genop_1(s, OP_LOADNIL, cursp());
          push();
        }
      }
      st++;
      pop_n(st+1);
      genop_2(s, OP_SUPER, cursp(), n);
      if (val) push();
@@ -3218,6 +3219,7 @@ codegen(codegen_scope *s, node *tree, int val)
        codegen_error(s, ""no anonymous block argument"");
      }
      gen_move(s, cursp(), idx, val);
      if (val) push();
    }
    else {
      codegen(s, tree, val);"
https://huntr.dev/bounties/f7cdd680-1a7f-4992-b4b8-44b5e4ba3e32/,Out-of-bounds Read in mruby/mruby,commit ecb28f4bf463483cf914c799d086b0cfff997aee,CVE-2022-0630,CWE-125: Out-of-bounds Read,https://www.github.com/mruby/mruby/commit/ff3a5ebed6ffbe3e70481531cfb969b497aa73ad,"@@ -2766,7 +2766,7 @@ mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)
      int lim = a+b*2+1;

      hash = regs[a];
      mrb_assert(mrb_hash_p(hash));
      for (i=a+1; i<lim; i+=2) {
        mrb_hash_set(mrb, hash, regs[i], regs[i+1]);
      }

","2
src/vm.c
@@ -2766,7 +2766,7 @@ mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)
      int lim = a+b*2+1;

      hash = regs[a];
      mrb_assert(mrb_hash_p(hash));
      mrb_ensure_hash_type(mrb, hash);
      for (i=a+1; i<lim; i+=2) {
        mrb_hash_set(mrb, hash, regs[i], regs[i+1]);
      }"
https://huntr.dev/bounties/9bdc49ca-6697-4adc-a785-081e1961bf40/,Heap-based Buffer Overflow in mruby/mruby,Heap Overflow occurs in mrb_f_send().,CVE-2022-0631,CWE-122: Heap-based Buffer Overflow,https://www.github.com/mruby/mruby/commit/47068ae07a5fa3aa9a1879cdfe98a9ce0f339299,"@@ -689,9 +689,11 @@ mrb_f_send(mrb_state *mrb, mrb_value self)
  regs = mrb->c->ci->stack+1;

  if (n == 0) {

    mrb_argnum_error(mrb, 0, 1, -1);
  }
  else if (n == 15) {

    name = mrb_obj_to_sym(mrb, RARRAY_PTR(regs[0])[0]);
  }
  else {

","2
src/vm.c
@@ -689,9 +689,11 @@ mrb_f_send(mrb_state *mrb, mrb_value self)
  regs = mrb->c->ci->stack+1;

  if (n == 0) {
  argnum_error:
    mrb_argnum_error(mrb, 0, 1, -1);
  }
  else if (n == 15) {
    if (RARRAY_LEN(regs[0]) == 0) goto argnum_error;
    name = mrb_obj_to_sym(mrb, RARRAY_PTR(regs[0])[0]);
  }
  else {"
https://huntr.dev/bounties/5b908ac7-d8f1-4fcd-9355-85df565f7580/,Out-of-bounds Read in mruby/mruby,commit 4e8ab145da52c3cfb0bd4b823df8041dcc52f454,CVE-2022-0623,CWE-125: Out-of-bounds Read,https://www.github.com/mruby/mruby/commit/ff3a5ebed6ffbe3e70481531cfb969b497aa73ad,"@@ -2766,7 +2766,7 @@ mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)
      int lim = a+b*2+1;

      hash = regs[a];
      mrb_assert(mrb_hash_p(hash));
      for (i=a+1; i<lim; i+=2) {
        mrb_hash_set(mrb, hash, regs[i], regs[i+1]);
      }

","2
src/vm.c
@@ -2766,7 +2766,7 @@ mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)
      int lim = a+b*2+1;

      hash = regs[a];
      mrb_assert(mrb_hash_p(hash));
      mrb_ensure_hash_type(mrb, hash);
      for (i=a+1; i<lim; i+=2) {
        mrb_hash_set(mrb, hash, regs[i], regs[i+1]);
      }"
https://huntr.dev/bounties/aa80adb7-e900-44a5-ad05-91f3ccdfc81e/,Use After Free in radareorg/radare2,Use After Free occurs in r_io_bank_map_add_top().,CVE-2022-0559,CWE-416: Use After Free,https://www.github.com/radareorg/radare2/commit/b5cb90b28ec71fda3504da04e3cc94a362807f5e,"@@ -226,12 +226,18 @@ R_API bool r_io_bank_map_add_top(RIO *io, const ut32 bankid, const ut32 mapid) {
  r_io_submap_set_to (bd, r_io_submap_from (sm) - 1);
  entry = r_rbnode_next (entry);
 }
 while (entry && r_io_submap_to (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {

  //delete all submaps that are completly included in sm
  RRBNode *next = r_rbnode_next (entry);
  // this can be optimized, there is no need to do search here



  bool a = r_crbtree_delete (bank->submaps, entry->data, _find_sm_by_from_vaddr_cb, NULL);

  if (!a) {

   break;
  }
  entry = next;

@@ -138,9 +138,9 @@ R_API bool r_crbtree_insert(RRBTree *tree, void *data, RRBComparator cmp, void *
 r_return_val_if_fail (tree && data && cmp, false);
 bool inserted = false;

 if (tree->root == NULL) {
  tree->root = _node_new (data, NULL);
  if (tree->root == NULL) {
   return false;
  }
  inserted = true;

","8
libr/io/io_bank.c
@@ -226,12 +226,18 @@ R_API bool r_io_bank_map_add_top(RIO *io, const ut32 bankid, const ut32 mapid) {
  r_io_submap_set_to (bd, r_io_submap_from (sm) - 1);
  entry = r_rbnode_next (entry);
 }
 while (entry && r_io_submap_to (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {
 ut64 smto = r_io_submap_to (sm);
 while (entry && r_io_submap_to (((RIOSubMap *)entry->data)) <= smto) {
  //delete all submaps that are completly included in sm
  RRBNode *next = r_rbnode_next (entry);
  // this can be optimized, there is no need to do search here
  // XXX this is a workaround to avoid an UAF in Reproducer: iobank-crash
  void *smfree = bank->submaps->free;
  bank->submaps->free = NULL;
  bool a = r_crbtree_delete (bank->submaps, entry->data, _find_sm_by_from_vaddr_cb, NULL);
  bank->submaps->free = smfree;
  if (!a) {
   entry = NULL;
   break;
  }
  entry = next;
4
libr/util/new_rbtree.c
@@ -138,9 +138,9 @@ R_API bool r_crbtree_insert(RRBTree *tree, void *data, RRBComparator cmp, void *
 r_return_val_if_fail (tree && data && cmp, false);
 bool inserted = false;

 if (tree->root == NULL) {
 if (!tree->root) {
  tree->root = _node_new (data, NULL);
  if (tree->root == NULL) {
  if (!tree->root) {
   return false;
  }
  inserted = true;"
https://huntr.dev/bounties/a980ce4d-c359-4425-92c4-e844c0055879/,Use of Out-of-range Pointer Offset in mruby/mruby,Using out of range pointer occurs in entry_deleted_p().,CVE-2022-0614,CWE-823: Use of Out-of-range Pointer Offset,https://www.github.com/mruby/mruby/commit/ff3a5ebed6ffbe3e70481531cfb969b497aa73ad,"@@ -2766,7 +2766,7 @@ mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)
      int lim = a+b*2+1;

      hash = regs[a];
      mrb_assert(mrb_hash_p(hash));
      for (i=a+1; i<lim; i+=2) {
        mrb_hash_set(mrb, hash, regs[i], regs[i+1]);
      }

","2
src/vm.c
@@ -2766,7 +2766,7 @@ mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)
      int lim = a+b*2+1;

      hash = regs[a];
      mrb_assert(mrb_hash_p(hash));
      mrb_ensure_hash_type(mrb, hash);
      for (i=a+1; i<lim; i+=2) {
        mrb_hash_set(mrb, hash, regs[i], regs[i+1]);
      }"
https://huntr.dev/bounties/65a7632e-f95b-4836-b1a7-9cb95e5124f1/,Heap-based Buffer Overflow in mruby/mruby,Heap Overflow occurs in mrb_f_send().,CVE-2022-0570,CWE-122: Heap-based Buffer Overflow,https://www.github.com/mruby/mruby/commit/38b164ace7d6ae1c367883a3d67d7f559783faad,"@@ -1551,7 +1551,7 @@ gen_values(codegen_scope *s, node *t, int val, int limit)
  while (t) {
    int is_splat = nint(t->car->car) == NODE_SPLAT;

    if (is_splat || n > limit || cursp() >= slimit) { /* flush stack */
      pop_n(n);
      if (first) {
        if (n == 0) {
@@ -1590,6 +1590,11 @@ gen_values(codegen_scope *s, node *t, int val, int limit)
    }
    return -1;                  /* variable length */
  }





  return n;
}


","7
mrbgems/mruby-compiler/core/codegen.c
@@ -1551,7 +1551,7 @@ gen_values(codegen_scope *s, node *t, int val, int limit)
  while (t) {
    int is_splat = nint(t->car->car) == NODE_SPLAT;

    if (is_splat || n > limit || cursp() >= slimit) { /* flush stack */
    if (is_splat || cursp() >= slimit) { /* flush stack */
      pop_n(n);
      if (first) {
        if (n == 0) {
@@ -1590,6 +1590,11 @@ gen_values(codegen_scope *s, node *t, int val, int limit)
    }
    return -1;                  /* variable length */
  }
  else if (n > limit) {
    pop_n(n);
    genop_2(s, OP_ARRAY, cursp(), n);
    return -1;
  }
  return n;
}"
https://huntr.dev/bounties/af85b9e1-d1cf-4c0e-ba12-525b82b7c1e3/,Buffer Access with Incorrect Length Value in radareorg/radare2,"This vulnerability is of out-of-bound read which accesses the address beyond/past the buffer. The bug exists in latest stable release (radare2-5.5.4) and lastest master branch (ed2030b79e68986bf04f3a6279463ab989fe400f, updated in Jan 22, 2022). Specifically, the vulnerable code and the bug's basic explanation is highlighted as follows:",CVE-2022-0519,CWE-805: Buffer Access with Incorrect Length Value,https://www.github.com/radareorg/radare2/commit/6c4428f018d385fc80a33ecddcb37becea685dd5,"@@ -3627,6 +3627,9 @@ R_API ut64 r_bin_java_signature_attr_calc_size(RBinJavaAttrInfo *attr) {

R_API RBinJavaAttrInfo *r_bin_java_enclosing_methods_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut64 offset = 6;



 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 if (!attr || sz < 10) {
  free (attr);
@@ -3715,27 +3718,24 @@ R_API ut64 r_bin_java_exceptions_attr_calc_size(RBinJavaAttrInfo *attr) {

R_API RBinJavaAttrInfo *r_bin_java_inner_classes_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 RBinJavaClassesAttribute *icattr;
 RBinJavaAttrInfo *attr = NULL;
 RBinJavaCPTypeObj *obj;
 ut32 i = 0;
 ut64 offset = 0, curpos;
 attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 offset += 6;
 if (buf_offset + offset + 8 > sz) {
  eprintf (""Invalid amount of inner classes\n"");
  return NULL;
 }
 if (attr == NULL) {
  // TODO eprintf
  return attr;
 }

 attr->type = R_BIN_JAVA_ATTR_TYPE_INNER_CLASSES_ATTR;
 attr->info.inner_classes_attr.number_of_classes = R_BIN_JAVA_USHORT (buffer, offset);
 offset += 2;
 attr->info.inner_classes_attr.classes = r_list_newf (r_bin_java_inner_classes_attr_entry_free);
 for (i = 0; i < attr->info.inner_classes_attr.number_of_classes; i++) {
  curpos = buf_offset + offset;
  if (buf_offset + offset + 8 > sz) {
   eprintf (""Invalid amount of inner classes\n"");
   break;
  }
@@ -3873,6 +3873,9 @@ R_API ut64 r_bin_java_line_number_table_attr_calc_size(RBinJavaAttrInfo *attr) {

R_API RBinJavaAttrInfo *r_bin_java_source_debug_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut64 offset = 6;



 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 if (!attr) {
  return NULL;
@@ -3940,12 +3943,11 @@ R_API ut64 r_bin_java_local_variable_table_attr_calc_size(RBinJavaAttrInfo *attr
R_API RBinJavaAttrInfo *r_bin_java_local_variable_table_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 RBinJavaLocalVariableAttribute *lvattr;
 ut64 curpos = 0, offset = 6;
 RBinJavaAttrInfo *attr;
 ut32 i = 0;
 if (!buffer || sz < 1) {
  return NULL;
 }
 attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 if (!attr) {
  return NULL;
 }
@@ -4019,6 +4021,9 @@ R_API ut64 r_bin_java_local_variable_type_table_attr_calc_size(RBinJavaAttrInfo
}

R_API RBinJavaAttrInfo *r_bin_java_local_variable_type_table_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {



 RBinJavaLocalVariableTypeAttribute *lvattr;
 ut64 offset = 6;
 ut32 i = 0;
@@ -4072,21 +4077,25 @@ R_API RBinJavaAttrInfo *r_bin_java_local_variable_type_table_attr_new(RBinJavaOb
}

R_API RBinJavaAttrInfo *r_bin_java_source_code_file_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 if (!sz) {





  return NULL;
 }

 ut64 offset = 0;
 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 offset += 6;
 if (!attr) {
  return NULL;




 }
 attr->type = R_BIN_JAVA_ATTR_TYPE_SOURCE_FILE_ATTR;
 // if (buffer + offset > buffer + sz) return NULL;
 attr->info.source_file_attr.sourcefile_idx = R_BIN_JAVA_USHORT (buffer, offset);
 offset += 2;
 attr->size = offset;
 // IFDBG r_bin_java_print_source_code_file_attr_summary(attr);
 return attr;
}

@@ -4095,14 +4104,15 @@ R_API ut64 r_bin_java_source_code_file_attr_calc_size(RBinJavaAttrInfo *attr) {
}

R_API RBinJavaAttrInfo *r_bin_java_synthetic_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut64 offset = 0;


 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 if (!attr) {
  return NULL;
 }
 offset += 6;
 attr->type = R_BIN_JAVA_ATTR_TYPE_SYNTHETIC_ATTR;
 attr->size = offset;
 return attr;
}

@@ -4133,24 +4143,21 @@ R_API RBinJavaInterfaceInfo *r_bin_java_interface_new(RBinJavaObj *bin, const ut

R_API RBinJavaVerificationObj *r_bin_java_verification_info_from_type(RBinJavaObj *bin, R_BIN_JAVA_STACKMAP_TYPE type, ut32 value) {
 RBinJavaVerificationObj *se = R_NEW0 (RBinJavaVerificationObj);
 if (!se) {
  return NULL;
 }
 se->tag = type;
 if (se->tag == R_BIN_JAVA_STACKMAP_OBJECT) {
  se->info.obj_val_cp_idx = (ut16) value;
 } else if (se->tag == R_BIN_JAVA_STACKMAP_UNINIT) {
  /*if (bin->offset_sz == 4) {
  se->info.uninit_offset = value;
  } else {
  se->info.uninit_offset = (ut16) value;
  }*/
  se->info.uninit_offset = (ut16) value;
 }
 return se;
}

R_API RBinJavaVerificationObj *r_bin_java_read_from_buffer_verification_info_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {



 ut64 offset = 0;
 RBinJavaVerificationObj *se = R_NEW0 (RBinJavaVerificationObj);
 if (!se) {
@@ -4270,6 +4277,9 @@ R_API ut64 r_bin_java_stack_map_frame_calc_size(RBinJavaStackMapFrame *sf) {
}

R_API RBinJavaStackMapFrame *r_bin_java_stack_map_frame_new(ut8 *buffer, ut64 sz, RBinJavaStackMapFrame *p_frame, ut64 buf_offset) {



 RBinJavaStackMapFrame *stack_frame = r_bin_java_default_stack_frame ();
 RBinJavaVerificationObj *se = NULL;
 ut64 offset = 0;
@@ -4573,13 +4583,16 @@ R_API ut64 r_bin_java_stack_map_table_attr_calc_size(RBinJavaAttrInfo *attr) {
R_API RBinJavaAttrInfo *r_bin_java_stack_map_table_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut32 i = 0;
 ut64 offset = 0;



 RBinJavaStackMapFrame *stack_frame = NULL, *new_stack_frame = NULL;
 if (sz < 10) {
  return NULL;
 }
 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 offset += 6;
 IFDBG eprintf(""r_bin_java_stack_map_table_attr_new: New stack map allocated.\n"");
 if (!attr) {
  return NULL;
 }
@@ -6354,8 +6367,10 @@ R_API ut64 r_bin_java_annotation_default_attr_calc_size(RBinJavaAttrInfo *attr)

R_API RBinJavaAttrInfo *r_bin_java_annotation_default_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut64 offset = 0;
 RBinJavaAttrInfo *attr = NULL;
 attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);


 offset += 6;
 if (attr && sz >= offset) {
  attr->type = R_BIN_JAVA_ATTR_TYPE_ANNOTATION_DEFAULT_ATTR;
@@ -6435,10 +6450,12 @@ R_API void r_bin_java_annotation_default_attr_free(void /*RBinJavaAttrInfo*/ *a)

R_API RBinJavaAnnotation *r_bin_java_annotation_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut32 i = 0;
 RBinJavaAnnotation *annotation = NULL;
 RBinJavaElementValuePair *evps = NULL;
 ut64 offset = 0;
 annotation = R_NEW0 (RBinJavaAnnotation);



 if (!annotation) {
  return NULL;
 }
@@ -6510,14 +6527,10 @@ R_API void r_bin_java_print_annotation_summary(RBinJavaAnnotation *annotation) {
}

R_API ut64 r_bin_java_element_pair_calc_size(RBinJavaElementValuePair *evp) {
 ut64 sz = 0;
 if (evp == NULL) {
  return sz;
 }
 // evp->element_name_idx = r_bin_java_read_short(bin, bin->b->cur);
 sz += 2;
 // evp->value = r_bin_java_element_value_new (bin, offset+2);
 if (evp->value) {
  sz += r_bin_java_element_value_calc_size (evp->value);
 }
 return sz;
@@ -6596,6 +6609,9 @@ R_API ut64 r_bin_java_element_value_calc_size(RBinJavaElementValue *element_valu
R_API RBinJavaElementValue *r_bin_java_element_value_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut32 i = 0;
 ut64 offset = 0;



 RBinJavaElementValue *element_value = R_NEW0 (RBinJavaElementValue);
 if (!element_value) {
  return NULL;
@@ -7011,7 +7027,7 @@ R_API RBinJavaAnnotationsArray *r_bin_java_annotation_array_new(ut8 *buffer, ut6
R_API RBinJavaAttrInfo *r_bin_java_rtv_annotations_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut32 i = 0;
 ut64 offset = 0;
 if (buf_offset + 8 > sz) {
  return NULL;
 }
 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);

","118
shlr/java/class.c
@@ -3627,6 +3627,9 @@ R_API ut64 r_bin_java_signature_attr_calc_size(RBinJavaAttrInfo *attr) {

R_API RBinJavaAttrInfo *r_bin_java_enclosing_methods_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut64 offset = 6;
 if (sz < 8) {
  return NULL;
 }
 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 if (!attr || sz < 10) {
  free (attr);
@@ -3715,27 +3718,24 @@ R_API ut64 r_bin_java_exceptions_attr_calc_size(RBinJavaAttrInfo *attr) {

R_API RBinJavaAttrInfo *r_bin_java_inner_classes_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 RBinJavaClassesAttribute *icattr;
 RBinJavaAttrInfo *attr = NULL;
 RBinJavaCPTypeObj *obj;
 ut32 i = 0;
 ut64 offset = 0, curpos;
 attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 offset += 6;
 if (buf_offset + offset + 8 > sz) {
  eprintf (""Invalid amount of inner classes\n"");
 if (sz < 8) {
  return NULL;
 }
 if (attr == NULL) {
  // TODO eprintf
  return attr;
 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 if (!attr) {
  return NULL;
 }
 offset += 6;
 attr->type = R_BIN_JAVA_ATTR_TYPE_INNER_CLASSES_ATTR;
 attr->info.inner_classes_attr.number_of_classes = R_BIN_JAVA_USHORT (buffer, offset);
 offset += 2;
 attr->info.inner_classes_attr.classes = r_list_newf (r_bin_java_inner_classes_attr_entry_free);
 for (i = 0; i < attr->info.inner_classes_attr.number_of_classes; i++) {
  curpos = buf_offset + offset;
  if (buf_offset + offset + 8 > sz) {
  if (offset + 8 > sz) {
   eprintf (""Invalid amount of inner classes\n"");
   break;
  }
@@ -3873,6 +3873,9 @@ R_API ut64 r_bin_java_line_number_table_attr_calc_size(RBinJavaAttrInfo *attr) {

R_API RBinJavaAttrInfo *r_bin_java_source_debug_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut64 offset = 6;
 if (sz < 8) {
  return NULL;
 }
 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 if (!attr) {
  return NULL;
@@ -3940,12 +3943,11 @@ R_API ut64 r_bin_java_local_variable_table_attr_calc_size(RBinJavaAttrInfo *attr
R_API RBinJavaAttrInfo *r_bin_java_local_variable_table_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 RBinJavaLocalVariableAttribute *lvattr;
 ut64 curpos = 0, offset = 6;
 RBinJavaAttrInfo *attr;
 ut32 i = 0;
 if (!buffer || sz < 1) {
 if (!bin || !buffer || sz < 8) {
  return NULL;
 }
 attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 if (!attr) {
  return NULL;
 }
@@ -4019,6 +4021,9 @@ R_API ut64 r_bin_java_local_variable_type_table_attr_calc_size(RBinJavaAttrInfo
}

R_API RBinJavaAttrInfo *r_bin_java_local_variable_type_table_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 if (sz < 8) {
  return NULL;
 }
 RBinJavaLocalVariableTypeAttribute *lvattr;
 ut64 offset = 6;
 ut32 i = 0;
@@ -4072,21 +4077,25 @@ R_API RBinJavaAttrInfo *r_bin_java_local_variable_type_table_attr_new(RBinJavaOb
}

R_API RBinJavaAttrInfo *r_bin_java_source_code_file_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 if (!sz) {
 if (!sz || sz == UT64_MAX) {
  return NULL;
 }
#if 0
 /// XXX this breaks tests
 if (sz < 8) {
  return NULL;
 }
#endif
 ut64 offset = 0;
 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 offset += 6;
 if (!attr) {
  return NULL;
 if (attr) {
  attr->type = R_BIN_JAVA_ATTR_TYPE_SOURCE_FILE_ATTR;
  attr->info.source_file_attr.sourcefile_idx = R_BIN_JAVA_USHORT (buffer, offset);
  offset += 2;
  attr->size = offset;
  // IFDBG r_bin_java_print_source_code_file_attr_summary(attr);
 }
 attr->type = R_BIN_JAVA_ATTR_TYPE_SOURCE_FILE_ATTR;
 // if (buffer + offset > buffer + sz) return NULL;
 attr->info.source_file_attr.sourcefile_idx = R_BIN_JAVA_USHORT (buffer, offset);
 offset += 2;
 attr->size = offset;
 // IFDBG r_bin_java_print_source_code_file_attr_summary(attr);
 return attr;
}

@@ -4095,14 +4104,15 @@ R_API ut64 r_bin_java_source_code_file_attr_calc_size(RBinJavaAttrInfo *attr) {
}

R_API RBinJavaAttrInfo *r_bin_java_synthetic_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut64 offset = 0;
 if (sz < 8) {
  return NULL;
 }
 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 if (!attr) {
  return NULL;
 }
 offset += 6;
 attr->type = R_BIN_JAVA_ATTR_TYPE_SYNTHETIC_ATTR;
 attr->size = offset;
 attr->size = 6;
 return attr;
}

@@ -4133,24 +4143,21 @@ R_API RBinJavaInterfaceInfo *r_bin_java_interface_new(RBinJavaObj *bin, const ut

R_API RBinJavaVerificationObj *r_bin_java_verification_info_from_type(RBinJavaObj *bin, R_BIN_JAVA_STACKMAP_TYPE type, ut32 value) {
 RBinJavaVerificationObj *se = R_NEW0 (RBinJavaVerificationObj);
 if (!se) {
  return NULL;
 }
 se->tag = type;
 if (se->tag == R_BIN_JAVA_STACKMAP_OBJECT) {
  se->info.obj_val_cp_idx = (ut16) value;
 } else if (se->tag == R_BIN_JAVA_STACKMAP_UNINIT) {
  /*if (bin->offset_sz == 4) {
  se->info.uninit_offset = value;
  } else {
  se->info.uninit_offset = (ut16) value;
  }*/
  se->info.uninit_offset = (ut16) value;
 if (se) {
  se->tag = type;
  if (se->tag == R_BIN_JAVA_STACKMAP_OBJECT) {
   se->info.obj_val_cp_idx = (ut16) value;
  } else if (se->tag == R_BIN_JAVA_STACKMAP_UNINIT) {
   se->info.uninit_offset = (ut16) value;
  }
 }
 return se;
}

R_API RBinJavaVerificationObj *r_bin_java_read_from_buffer_verification_info_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {
 if (sz < 8) {
  return NULL;
 }
 ut64 offset = 0;
 RBinJavaVerificationObj *se = R_NEW0 (RBinJavaVerificationObj);
 if (!se) {
@@ -4270,6 +4277,9 @@ R_API ut64 r_bin_java_stack_map_frame_calc_size(RBinJavaStackMapFrame *sf) {
}

R_API RBinJavaStackMapFrame *r_bin_java_stack_map_frame_new(ut8 *buffer, ut64 sz, RBinJavaStackMapFrame *p_frame, ut64 buf_offset) {
 if (sz < 8) {
  return NULL;
 }
 RBinJavaStackMapFrame *stack_frame = r_bin_java_default_stack_frame ();
 RBinJavaVerificationObj *se = NULL;
 ut64 offset = 0;
@@ -4573,13 +4583,16 @@ R_API ut64 r_bin_java_stack_map_table_attr_calc_size(RBinJavaAttrInfo *attr) {
R_API RBinJavaAttrInfo *r_bin_java_stack_map_table_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut32 i = 0;
 ut64 offset = 0;
 if (sz < 8) {
  return NULL;
 }
 RBinJavaStackMapFrame *stack_frame = NULL, *new_stack_frame = NULL;
 if (sz < 10) {
  return NULL;
 }
 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 offset += 6;
 IFDBG eprintf(""r_bin_java_stack_map_table_attr_new: New stack map allocated.\n"");
 IFDBG eprintf (""r_bin_java_stack_map_table_attr_new: New stack map allocated.\n"");
 if (!attr) {
  return NULL;
 }
@@ -6354,8 +6367,10 @@ R_API ut64 r_bin_java_annotation_default_attr_calc_size(RBinJavaAttrInfo *attr)

R_API RBinJavaAttrInfo *r_bin_java_annotation_default_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut64 offset = 0;
 RBinJavaAttrInfo *attr = NULL;
 attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 if (sz < 8) {
  return NULL;
 }
 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 offset += 6;
 if (attr && sz >= offset) {
  attr->type = R_BIN_JAVA_ATTR_TYPE_ANNOTATION_DEFAULT_ATTR;
@@ -6435,10 +6450,12 @@ R_API void r_bin_java_annotation_default_attr_free(void /*RBinJavaAttrInfo*/ *a)

R_API RBinJavaAnnotation *r_bin_java_annotation_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut32 i = 0;
 RBinJavaAnnotation *annotation = NULL;
 RBinJavaElementValuePair *evps = NULL;
 ut64 offset = 0;
 annotation = R_NEW0 (RBinJavaAnnotation);
 if (sz < 8) {
  return NULL;
 }
 RBinJavaAnnotation *annotation = R_NEW0 (RBinJavaAnnotation);
 if (!annotation) {
  return NULL;
 }
@@ -6510,14 +6527,10 @@ R_API void r_bin_java_print_annotation_summary(RBinJavaAnnotation *annotation) {
}

R_API ut64 r_bin_java_element_pair_calc_size(RBinJavaElementValuePair *evp) {
 ut64 sz = 0;
 if (evp == NULL) {
  return sz;
 }
 // evp->element_name_idx = r_bin_java_read_short(bin, bin->b->cur);
 sz += 2;
 // evp->value = r_bin_java_element_value_new (bin, offset+2);
 if (evp->value) {
 ut64 sz = 2;
 if (evp && evp->value) {
  // evp->element_name_idx = r_bin_java_read_short(bin, bin->b->cur);
  // evp->value = r_bin_java_element_value_new (bin, offset+2);
  sz += r_bin_java_element_value_calc_size (evp->value);
 }
 return sz;
@@ -6596,6 +6609,9 @@ R_API ut64 r_bin_java_element_value_calc_size(RBinJavaElementValue *element_valu
R_API RBinJavaElementValue *r_bin_java_element_value_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut32 i = 0;
 ut64 offset = 0;
 if (sz < 8) {
  return NULL;
 }
 RBinJavaElementValue *element_value = R_NEW0 (RBinJavaElementValue);
 if (!element_value) {
  return NULL;
@@ -7011,7 +7027,7 @@ R_API RBinJavaAnnotationsArray *r_bin_java_annotation_array_new(ut8 *buffer, ut6
R_API RBinJavaAttrInfo *r_bin_java_rtv_annotations_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut32 i = 0;
 ut64 offset = 0;
 if (buf_offset + 8 > sz) {
 if (sz < 8) {
  return NULL;
 }
 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);"
https://huntr.dev/bounties/4d436311-bbf1-45a3-8774-bdb666d7f7ca/,Access of Memory Location After End of Buffer in radareorg/radare2,"This vulnerability is of out-of-bound read which accesses the address beyond/past the buffer. The bug exists in latest stable release (radare2-5.5.4) and lastest master branch (ed2030b79e68986bf04f3a6279463ab989fe400f, updated in Jan 22, 2022). Specifically, the vulnerable code and the bug's basic explanation is highlighted as follows:",CVE-2022-0521,CWE-788: Access of Memory Location After End of Buffer,https://www.github.com/radareorg/radare2/commit/6c4428f018d385fc80a33ecddcb37becea685dd5,"@@ -3627,6 +3627,9 @@ R_API ut64 r_bin_java_signature_attr_calc_size(RBinJavaAttrInfo *attr) {

R_API RBinJavaAttrInfo *r_bin_java_enclosing_methods_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut64 offset = 6;



 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 if (!attr || sz < 10) {
  free (attr);
@@ -3715,27 +3718,24 @@ R_API ut64 r_bin_java_exceptions_attr_calc_size(RBinJavaAttrInfo *attr) {

R_API RBinJavaAttrInfo *r_bin_java_inner_classes_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 RBinJavaClassesAttribute *icattr;
 RBinJavaAttrInfo *attr = NULL;
 RBinJavaCPTypeObj *obj;
 ut32 i = 0;
 ut64 offset = 0, curpos;
 attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 offset += 6;
 if (buf_offset + offset + 8 > sz) {
  eprintf (""Invalid amount of inner classes\n"");
  return NULL;
 }
 if (attr == NULL) {
  // TODO eprintf
  return attr;
 }

 attr->type = R_BIN_JAVA_ATTR_TYPE_INNER_CLASSES_ATTR;
 attr->info.inner_classes_attr.number_of_classes = R_BIN_JAVA_USHORT (buffer, offset);
 offset += 2;
 attr->info.inner_classes_attr.classes = r_list_newf (r_bin_java_inner_classes_attr_entry_free);
 for (i = 0; i < attr->info.inner_classes_attr.number_of_classes; i++) {
  curpos = buf_offset + offset;
  if (buf_offset + offset + 8 > sz) {
   eprintf (""Invalid amount of inner classes\n"");
   break;
  }
@@ -3873,6 +3873,9 @@ R_API ut64 r_bin_java_line_number_table_attr_calc_size(RBinJavaAttrInfo *attr) {

R_API RBinJavaAttrInfo *r_bin_java_source_debug_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut64 offset = 6;



 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 if (!attr) {
  return NULL;
@@ -3940,12 +3943,11 @@ R_API ut64 r_bin_java_local_variable_table_attr_calc_size(RBinJavaAttrInfo *attr
R_API RBinJavaAttrInfo *r_bin_java_local_variable_table_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 RBinJavaLocalVariableAttribute *lvattr;
 ut64 curpos = 0, offset = 6;
 RBinJavaAttrInfo *attr;
 ut32 i = 0;
 if (!buffer || sz < 1) {
  return NULL;
 }
 attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 if (!attr) {
  return NULL;
 }
@@ -4019,6 +4021,9 @@ R_API ut64 r_bin_java_local_variable_type_table_attr_calc_size(RBinJavaAttrInfo
}

R_API RBinJavaAttrInfo *r_bin_java_local_variable_type_table_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {



 RBinJavaLocalVariableTypeAttribute *lvattr;
 ut64 offset = 6;
 ut32 i = 0;
@@ -4072,21 +4077,25 @@ R_API RBinJavaAttrInfo *r_bin_java_local_variable_type_table_attr_new(RBinJavaOb
}

R_API RBinJavaAttrInfo *r_bin_java_source_code_file_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 if (!sz) {





  return NULL;
 }

 ut64 offset = 0;
 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 offset += 6;
 if (!attr) {
  return NULL;




 }
 attr->type = R_BIN_JAVA_ATTR_TYPE_SOURCE_FILE_ATTR;
 // if (buffer + offset > buffer + sz) return NULL;
 attr->info.source_file_attr.sourcefile_idx = R_BIN_JAVA_USHORT (buffer, offset);
 offset += 2;
 attr->size = offset;
 // IFDBG r_bin_java_print_source_code_file_attr_summary(attr);
 return attr;
}

@@ -4095,14 +4104,15 @@ R_API ut64 r_bin_java_source_code_file_attr_calc_size(RBinJavaAttrInfo *attr) {
}

R_API RBinJavaAttrInfo *r_bin_java_synthetic_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut64 offset = 0;


 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 if (!attr) {
  return NULL;
 }
 offset += 6;
 attr->type = R_BIN_JAVA_ATTR_TYPE_SYNTHETIC_ATTR;
 attr->size = offset;
 return attr;
}

@@ -4133,24 +4143,21 @@ R_API RBinJavaInterfaceInfo *r_bin_java_interface_new(RBinJavaObj *bin, const ut

R_API RBinJavaVerificationObj *r_bin_java_verification_info_from_type(RBinJavaObj *bin, R_BIN_JAVA_STACKMAP_TYPE type, ut32 value) {
 RBinJavaVerificationObj *se = R_NEW0 (RBinJavaVerificationObj);
 if (!se) {
  return NULL;
 }
 se->tag = type;
 if (se->tag == R_BIN_JAVA_STACKMAP_OBJECT) {
  se->info.obj_val_cp_idx = (ut16) value;
 } else if (se->tag == R_BIN_JAVA_STACKMAP_UNINIT) {
  /*if (bin->offset_sz == 4) {
  se->info.uninit_offset = value;
  } else {
  se->info.uninit_offset = (ut16) value;
  }*/
  se->info.uninit_offset = (ut16) value;
 }
 return se;
}

R_API RBinJavaVerificationObj *r_bin_java_read_from_buffer_verification_info_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {



 ut64 offset = 0;
 RBinJavaVerificationObj *se = R_NEW0 (RBinJavaVerificationObj);
 if (!se) {
@@ -4270,6 +4277,9 @@ R_API ut64 r_bin_java_stack_map_frame_calc_size(RBinJavaStackMapFrame *sf) {
}

R_API RBinJavaStackMapFrame *r_bin_java_stack_map_frame_new(ut8 *buffer, ut64 sz, RBinJavaStackMapFrame *p_frame, ut64 buf_offset) {



 RBinJavaStackMapFrame *stack_frame = r_bin_java_default_stack_frame ();
 RBinJavaVerificationObj *se = NULL;
 ut64 offset = 0;
@@ -4573,13 +4583,16 @@ R_API ut64 r_bin_java_stack_map_table_attr_calc_size(RBinJavaAttrInfo *attr) {
R_API RBinJavaAttrInfo *r_bin_java_stack_map_table_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut32 i = 0;
 ut64 offset = 0;



 RBinJavaStackMapFrame *stack_frame = NULL, *new_stack_frame = NULL;
 if (sz < 10) {
  return NULL;
 }
 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 offset += 6;
 IFDBG eprintf(""r_bin_java_stack_map_table_attr_new: New stack map allocated.\n"");
 if (!attr) {
  return NULL;
 }
@@ -6354,8 +6367,10 @@ R_API ut64 r_bin_java_annotation_default_attr_calc_size(RBinJavaAttrInfo *attr)

R_API RBinJavaAttrInfo *r_bin_java_annotation_default_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut64 offset = 0;
 RBinJavaAttrInfo *attr = NULL;
 attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);


 offset += 6;
 if (attr && sz >= offset) {
  attr->type = R_BIN_JAVA_ATTR_TYPE_ANNOTATION_DEFAULT_ATTR;
@@ -6435,10 +6450,12 @@ R_API void r_bin_java_annotation_default_attr_free(void /*RBinJavaAttrInfo*/ *a)

R_API RBinJavaAnnotation *r_bin_java_annotation_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut32 i = 0;
 RBinJavaAnnotation *annotation = NULL;
 RBinJavaElementValuePair *evps = NULL;
 ut64 offset = 0;
 annotation = R_NEW0 (RBinJavaAnnotation);



 if (!annotation) {
  return NULL;
 }
@@ -6510,14 +6527,10 @@ R_API void r_bin_java_print_annotation_summary(RBinJavaAnnotation *annotation) {
}

R_API ut64 r_bin_java_element_pair_calc_size(RBinJavaElementValuePair *evp) {
 ut64 sz = 0;
 if (evp == NULL) {
  return sz;
 }
 // evp->element_name_idx = r_bin_java_read_short(bin, bin->b->cur);
 sz += 2;
 // evp->value = r_bin_java_element_value_new (bin, offset+2);
 if (evp->value) {
  sz += r_bin_java_element_value_calc_size (evp->value);
 }
 return sz;
@@ -6596,6 +6609,9 @@ R_API ut64 r_bin_java_element_value_calc_size(RBinJavaElementValue *element_valu
R_API RBinJavaElementValue *r_bin_java_element_value_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut32 i = 0;
 ut64 offset = 0;



 RBinJavaElementValue *element_value = R_NEW0 (RBinJavaElementValue);
 if (!element_value) {
  return NULL;
@@ -7011,7 +7027,7 @@ R_API RBinJavaAnnotationsArray *r_bin_java_annotation_array_new(ut8 *buffer, ut6
R_API RBinJavaAttrInfo *r_bin_java_rtv_annotations_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut32 i = 0;
 ut64 offset = 0;
 if (buf_offset + 8 > sz) {
  return NULL;
 }
 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);

","118
shlr/java/class.c
@@ -3627,6 +3627,9 @@ R_API ut64 r_bin_java_signature_attr_calc_size(RBinJavaAttrInfo *attr) {

R_API RBinJavaAttrInfo *r_bin_java_enclosing_methods_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut64 offset = 6;
 if (sz < 8) {
  return NULL;
 }
 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 if (!attr || sz < 10) {
  free (attr);
@@ -3715,27 +3718,24 @@ R_API ut64 r_bin_java_exceptions_attr_calc_size(RBinJavaAttrInfo *attr) {

R_API RBinJavaAttrInfo *r_bin_java_inner_classes_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 RBinJavaClassesAttribute *icattr;
 RBinJavaAttrInfo *attr = NULL;
 RBinJavaCPTypeObj *obj;
 ut32 i = 0;
 ut64 offset = 0, curpos;
 attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 offset += 6;
 if (buf_offset + offset + 8 > sz) {
  eprintf (""Invalid amount of inner classes\n"");
 if (sz < 8) {
  return NULL;
 }
 if (attr == NULL) {
  // TODO eprintf
  return attr;
 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 if (!attr) {
  return NULL;
 }
 offset += 6;
 attr->type = R_BIN_JAVA_ATTR_TYPE_INNER_CLASSES_ATTR;
 attr->info.inner_classes_attr.number_of_classes = R_BIN_JAVA_USHORT (buffer, offset);
 offset += 2;
 attr->info.inner_classes_attr.classes = r_list_newf (r_bin_java_inner_classes_attr_entry_free);
 for (i = 0; i < attr->info.inner_classes_attr.number_of_classes; i++) {
  curpos = buf_offset + offset;
  if (buf_offset + offset + 8 > sz) {
  if (offset + 8 > sz) {
   eprintf (""Invalid amount of inner classes\n"");
   break;
  }
@@ -3873,6 +3873,9 @@ R_API ut64 r_bin_java_line_number_table_attr_calc_size(RBinJavaAttrInfo *attr) {

R_API RBinJavaAttrInfo *r_bin_java_source_debug_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut64 offset = 6;
 if (sz < 8) {
  return NULL;
 }
 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 if (!attr) {
  return NULL;
@@ -3940,12 +3943,11 @@ R_API ut64 r_bin_java_local_variable_table_attr_calc_size(RBinJavaAttrInfo *attr
R_API RBinJavaAttrInfo *r_bin_java_local_variable_table_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 RBinJavaLocalVariableAttribute *lvattr;
 ut64 curpos = 0, offset = 6;
 RBinJavaAttrInfo *attr;
 ut32 i = 0;
 if (!buffer || sz < 1) {
 if (!bin || !buffer || sz < 8) {
  return NULL;
 }
 attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 if (!attr) {
  return NULL;
 }
@@ -4019,6 +4021,9 @@ R_API ut64 r_bin_java_local_variable_type_table_attr_calc_size(RBinJavaAttrInfo
}

R_API RBinJavaAttrInfo *r_bin_java_local_variable_type_table_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 if (sz < 8) {
  return NULL;
 }
 RBinJavaLocalVariableTypeAttribute *lvattr;
 ut64 offset = 6;
 ut32 i = 0;
@@ -4072,21 +4077,25 @@ R_API RBinJavaAttrInfo *r_bin_java_local_variable_type_table_attr_new(RBinJavaOb
}

R_API RBinJavaAttrInfo *r_bin_java_source_code_file_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 if (!sz) {
 if (!sz || sz == UT64_MAX) {
  return NULL;
 }
#if 0
 /// XXX this breaks tests
 if (sz < 8) {
  return NULL;
 }
#endif
 ut64 offset = 0;
 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 offset += 6;
 if (!attr) {
  return NULL;
 if (attr) {
  attr->type = R_BIN_JAVA_ATTR_TYPE_SOURCE_FILE_ATTR;
  attr->info.source_file_attr.sourcefile_idx = R_BIN_JAVA_USHORT (buffer, offset);
  offset += 2;
  attr->size = offset;
  // IFDBG r_bin_java_print_source_code_file_attr_summary(attr);
 }
 attr->type = R_BIN_JAVA_ATTR_TYPE_SOURCE_FILE_ATTR;
 // if (buffer + offset > buffer + sz) return NULL;
 attr->info.source_file_attr.sourcefile_idx = R_BIN_JAVA_USHORT (buffer, offset);
 offset += 2;
 attr->size = offset;
 // IFDBG r_bin_java_print_source_code_file_attr_summary(attr);
 return attr;
}

@@ -4095,14 +4104,15 @@ R_API ut64 r_bin_java_source_code_file_attr_calc_size(RBinJavaAttrInfo *attr) {
}

R_API RBinJavaAttrInfo *r_bin_java_synthetic_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut64 offset = 0;
 if (sz < 8) {
  return NULL;
 }
 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 if (!attr) {
  return NULL;
 }
 offset += 6;
 attr->type = R_BIN_JAVA_ATTR_TYPE_SYNTHETIC_ATTR;
 attr->size = offset;
 attr->size = 6;
 return attr;
}

@@ -4133,24 +4143,21 @@ R_API RBinJavaInterfaceInfo *r_bin_java_interface_new(RBinJavaObj *bin, const ut

R_API RBinJavaVerificationObj *r_bin_java_verification_info_from_type(RBinJavaObj *bin, R_BIN_JAVA_STACKMAP_TYPE type, ut32 value) {
 RBinJavaVerificationObj *se = R_NEW0 (RBinJavaVerificationObj);
 if (!se) {
  return NULL;
 }
 se->tag = type;
 if (se->tag == R_BIN_JAVA_STACKMAP_OBJECT) {
  se->info.obj_val_cp_idx = (ut16) value;
 } else if (se->tag == R_BIN_JAVA_STACKMAP_UNINIT) {
  /*if (bin->offset_sz == 4) {
  se->info.uninit_offset = value;
  } else {
  se->info.uninit_offset = (ut16) value;
  }*/
  se->info.uninit_offset = (ut16) value;
 if (se) {
  se->tag = type;
  if (se->tag == R_BIN_JAVA_STACKMAP_OBJECT) {
   se->info.obj_val_cp_idx = (ut16) value;
  } else if (se->tag == R_BIN_JAVA_STACKMAP_UNINIT) {
   se->info.uninit_offset = (ut16) value;
  }
 }
 return se;
}

R_API RBinJavaVerificationObj *r_bin_java_read_from_buffer_verification_info_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {
 if (sz < 8) {
  return NULL;
 }
 ut64 offset = 0;
 RBinJavaVerificationObj *se = R_NEW0 (RBinJavaVerificationObj);
 if (!se) {
@@ -4270,6 +4277,9 @@ R_API ut64 r_bin_java_stack_map_frame_calc_size(RBinJavaStackMapFrame *sf) {
}

R_API RBinJavaStackMapFrame *r_bin_java_stack_map_frame_new(ut8 *buffer, ut64 sz, RBinJavaStackMapFrame *p_frame, ut64 buf_offset) {
 if (sz < 8) {
  return NULL;
 }
 RBinJavaStackMapFrame *stack_frame = r_bin_java_default_stack_frame ();
 RBinJavaVerificationObj *se = NULL;
 ut64 offset = 0;
@@ -4573,13 +4583,16 @@ R_API ut64 r_bin_java_stack_map_table_attr_calc_size(RBinJavaAttrInfo *attr) {
R_API RBinJavaAttrInfo *r_bin_java_stack_map_table_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut32 i = 0;
 ut64 offset = 0;
 if (sz < 8) {
  return NULL;
 }
 RBinJavaStackMapFrame *stack_frame = NULL, *new_stack_frame = NULL;
 if (sz < 10) {
  return NULL;
 }
 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 offset += 6;
 IFDBG eprintf(""r_bin_java_stack_map_table_attr_new: New stack map allocated.\n"");
 IFDBG eprintf (""r_bin_java_stack_map_table_attr_new: New stack map allocated.\n"");
 if (!attr) {
  return NULL;
 }
@@ -6354,8 +6367,10 @@ R_API ut64 r_bin_java_annotation_default_attr_calc_size(RBinJavaAttrInfo *attr)

R_API RBinJavaAttrInfo *r_bin_java_annotation_default_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut64 offset = 0;
 RBinJavaAttrInfo *attr = NULL;
 attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 if (sz < 8) {
  return NULL;
 }
 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 offset += 6;
 if (attr && sz >= offset) {
  attr->type = R_BIN_JAVA_ATTR_TYPE_ANNOTATION_DEFAULT_ATTR;
@@ -6435,10 +6450,12 @@ R_API void r_bin_java_annotation_default_attr_free(void /*RBinJavaAttrInfo*/ *a)

R_API RBinJavaAnnotation *r_bin_java_annotation_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut32 i = 0;
 RBinJavaAnnotation *annotation = NULL;
 RBinJavaElementValuePair *evps = NULL;
 ut64 offset = 0;
 annotation = R_NEW0 (RBinJavaAnnotation);
 if (sz < 8) {
  return NULL;
 }
 RBinJavaAnnotation *annotation = R_NEW0 (RBinJavaAnnotation);
 if (!annotation) {
  return NULL;
 }
@@ -6510,14 +6527,10 @@ R_API void r_bin_java_print_annotation_summary(RBinJavaAnnotation *annotation) {
}

R_API ut64 r_bin_java_element_pair_calc_size(RBinJavaElementValuePair *evp) {
 ut64 sz = 0;
 if (evp == NULL) {
  return sz;
 }
 // evp->element_name_idx = r_bin_java_read_short(bin, bin->b->cur);
 sz += 2;
 // evp->value = r_bin_java_element_value_new (bin, offset+2);
 if (evp->value) {
 ut64 sz = 2;
 if (evp && evp->value) {
  // evp->element_name_idx = r_bin_java_read_short(bin, bin->b->cur);
  // evp->value = r_bin_java_element_value_new (bin, offset+2);
  sz += r_bin_java_element_value_calc_size (evp->value);
 }
 return sz;
@@ -6596,6 +6609,9 @@ R_API ut64 r_bin_java_element_value_calc_size(RBinJavaElementValue *element_valu
R_API RBinJavaElementValue *r_bin_java_element_value_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut32 i = 0;
 ut64 offset = 0;
 if (sz < 8) {
  return NULL;
 }
 RBinJavaElementValue *element_value = R_NEW0 (RBinJavaElementValue);
 if (!element_value) {
  return NULL;
@@ -7011,7 +7027,7 @@ R_API RBinJavaAnnotationsArray *r_bin_java_annotation_array_new(ut8 *buffer, ut6
R_API RBinJavaAttrInfo *r_bin_java_rtv_annotations_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
 ut32 i = 0;
 ut64 offset = 0;
 if (buf_offset + 8 > sz) {
 if (sz < 8) {
  return NULL;
 }
 RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);"
https://huntr.dev/bounties/10051adf-7ddc-4042-8fd0-8e9e0c5b1184/,Heap-based Buffer Overflow in radareorg/radare2,"This vulnerability is of out-of-bound read which accesses the address beyond/past the buffer. The bug exists in latest stable release (radare2-5.5.4) and lastest master branch (ed2030b79e68986bf04f3a6279463ab989fe400f, updated in Jan 22, 2022). Specifically, the vulnerable code is located in shlr/java/class.c line 7157 and the bug's basic explanation is highlighted as follows:",CVE-2022-0518,CWE-122: Heap-based Buffer Overflow,https://www.github.com/radareorg/radare2/commit/9650e3c352f675687bf6c6f65ff2c4a3d0e288fa,"@@ -3733,6 +3733,10 @@ R_API RBinJavaAttrInfo *r_bin_java_inner_classes_attr_new(RBinJavaObj *bin, ut8
 ut64 offset = 0, curpos;
 attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 offset += 6;




 if (attr == NULL) {
  // TODO eprintf
  return attr;
@@ -3743,7 +3747,7 @@ R_API RBinJavaAttrInfo *r_bin_java_inner_classes_attr_new(RBinJavaObj *bin, ut8
 attr->info.inner_classes_attr.classes = r_list_newf (r_bin_java_inner_classes_attr_entry_free);
 for (i = 0; i < attr->info.inner_classes_attr.number_of_classes; i++) {
  curpos = buf_offset + offset;
  if (offset + 8 > sz) {
   eprintf (""Invalid amount of inner classes\n"");
   break;
  }

","6
shlr/java/class.c
@@ -3733,6 +3733,10 @@ R_API RBinJavaAttrInfo *r_bin_java_inner_classes_attr_new(RBinJavaObj *bin, ut8
 ut64 offset = 0, curpos;
 attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
 offset += 6;
 if (buf_offset + offset + 8 > sz) {
  eprintf (""Invalid amount of inner classes\n"");
  return NULL;
 }
 if (attr == NULL) {
  // TODO eprintf
  return attr;
@@ -3743,7 +3747,7 @@ R_API RBinJavaAttrInfo *r_bin_java_inner_classes_attr_new(RBinJavaObj *bin, ut8
 attr->info.inner_classes_attr.classes = r_list_newf (r_bin_java_inner_classes_attr_entry_free);
 for (i = 0; i < attr->info.inner_classes_attr.number_of_classes; i++) {
  curpos = buf_offset + offset;
  if (offset + 8 > sz) {
  if (buf_offset + offset + 8 > sz) {
   eprintf (""Invalid amount of inner classes\n"");
   break;
  }"
https://huntr.dev/bounties/2d45e589-d614-4875-bba1-be0f729e7ca9/,Access of Memory Location Before Start of Buffer in radareorg/radare2,"This vulnerability is of out-of-bound read which is caused by negative buffer index. The bug exists in latest stable release (radare2-5.5.4) and lastest master branch (ed2030b79e68986bf04f3a6279463ab989fe400f, updated in Jan 22, 2022). Specifically, the vulnerable code is highlighted out as follows:",CVE-2022-0522,CWE-786: Access of Memory Location Before Start of Buffer,https://www.github.com/radareorg/radare2/commit/d17a7bdf166108a29a27cd89bf454f9fa6c050d6,"@@ -1015,7 +1015,7 @@ static const char *arg(RAnal *a, csh *handle, cs_insn *insn, char *buf, int n) {

#define VEC64(n) insn->detail->arm64.operands[n].vess
#define VEC64_APPEND(sb, n, i) vector64_append(sb, handle, insn, n, i)
#define VEC64_MASK(sh, sz) (bitmask_by_width[63]^(bitmask_by_width[sz-1]<<sh))

static void vector64_append(RStrBuf *sb, csh *handle, cs_insn *insn, int n, int i) {
 cs_arm64_op op = INSOP64 (n);
@@ -1079,7 +1079,6 @@ static void vector64_dst_append(RStrBuf *sb, csh *handle, cs_insn *insn, int n,
   shift -= 64;
   regc = ""h"";
  }

  if (shift > 0 && shift < 64) {
   r_strbuf_appendf (sb, ""%d,SWAP,0x%""PFMT64x"",&,<<,%s%s,0x%""PFMT64x"",&,|,%s%s"",
    shift, mask, REG64 (n), regc, VEC64_MASK (shift, size), REG64 (n), regc);

","3
libr/anal/p/anal_arm_cs.c
@@ -1015,7 +1015,7 @@ static const char *arg(RAnal *a, csh *handle, cs_insn *insn, char *buf, int n) {

#define VEC64(n) insn->detail->arm64.operands[n].vess
#define VEC64_APPEND(sb, n, i) vector64_append(sb, handle, insn, n, i)
#define VEC64_MASK(sh, sz) (bitmask_by_width[63]^(bitmask_by_width[sz-1]<<sh))
#define VEC64_MASK(sh, sz) (bitmask_by_width[63]^(bitmask_by_width[sz>0?sz-1:0]<<sh))

static void vector64_append(RStrBuf *sb, csh *handle, cs_insn *insn, int n, int i) {
 cs_arm64_op op = INSOP64 (n);
@@ -1079,7 +1079,6 @@ static void vector64_dst_append(RStrBuf *sb, csh *handle, cs_insn *insn, int n,
   shift -= 64;
   regc = ""h"";
  }

  if (shift > 0 && shift < 64) {
   r_strbuf_appendf (sb, ""%d,SWAP,0x%""PFMT64x"",&,<<,%s%s,0x%""PFMT64x"",&,|,%s%s"",
    shift, mask, REG64 (n), regc, VEC64_MASK (shift, size), REG64 (n), regc);"
https://huntr.dev/bounties/ce13c371-e5ef-4993-97f3-3d33dcd943a6/,Use After Free in radareorg/radare2,"This vulnerability is of type use-after-free. And after quick investigation I think it is very likely to be successfully exploited to remote code execution. The bug exists in latest stable release (radare2-5.5.4) and lastest master branch (ed2030b79e68986bf04f3a6279463ab989fe400f, updated in Jan 22, 2022). Specifically, the vulnerable code (located at libr/bin/format/pyc/marshal.c) and the bug's basic explanation are highlighted as follows:",CVE-2022-0520,CWE-416: Use After Free,https://www.github.com/radareorg/radare2/commit/8525ad0b9fd596f4b251bb3d7b114e6dc7ce1ee8,"@@ -1098,7 +1098,7 @@ static pyc_object *get_object(RBuffer *buffer) {
  break;
 case TYPE_UNKNOWN:
  eprintf (""Get not implemented for type 0x%x\n"", type);
  r_list_pop (refs);
  free_object (ret);
  return NULL;
 case 0:

","2
libr/bin/format/pyc/marshal.c
@@ -1098,7 +1098,7 @@ static pyc_object *get_object(RBuffer *buffer) {
  break;
 case TYPE_UNKNOWN:
  eprintf (""Get not implemented for type 0x%x\n"", type);
  r_list_pop (refs);
  // r_list_pop (refs);
  free_object (ret);
  return NULL;
 case 0:"
https://huntr.dev/bounties/9d8d6ae0-fe00-40b9-ae1e-b0e8103bac69/,Expired Pointer Dereference in radareorg/radare2,"This vulnerability is of type Expired Pointer Dereference ( or specifically, use-after-free). The bug exists in latest stable release (radare2-5.5.4) and lastest master branch (ed2030b79e68986bf04f3a6279463ab989fe400f, updated in Jan 22, 2022). Specifically, the vulnerable code (located at libr/bin/format/pyc/marshal.c) and the bug's basic explanation are highlighted as follows:",CVE-2022-0523,CWE-825: Expired Pointer Dereference,https://www.github.com/radareorg/radare2/commit/35482cb760db10f87a62569e2f8872dbd95e9269,"@@ -1,4 +1,4 @@
/* radare - LGPL3 - Copyright 2016-2021 - Matthieu (c0riolis) Tardy - l0stb1t*/

#include <r_io.h>
#include <r_bin.h>
@@ -9,9 +9,9 @@
#define if_true_return(cond,ret) if(cond){return(ret);}

// TODO: kill globals
static ut32 magic_int;
static ut32 symbols_ordinal = 0;
static RList *refs = NULL; // If you don't have a good reason, do not change this. And also checkout !refs in get_code_object()

/* interned_table is used to handle TYPE_INTERNED object */
extern RList *interned_table;
@@ -500,13 +500,9 @@ static pyc_object *get_array_object_generic(RBuffer *buffer, ut32 size) {
 }
 for (i = 0; i < size; i++) {
  tmp = get_object (buffer);
  if (!tmp) {
   r_list_free (ret->data);
   R_FREE (ret);
   return NULL;
  }
  if (!r_list_append (ret->data, tmp)) {
   free_object (tmp);

   r_list_free (ret->data);
   free (ret);
   return NULL;
@@ -516,7 +512,6 @@ static pyc_object *get_array_object_generic(RBuffer *buffer, ut32 size) {
}

/* small TYPE_SMALL_TUPLE doesn't exist in python2 */
/* */
static pyc_object *get_small_tuple_object(RBuffer *buffer) {
 pyc_object *ret = NULL;
 bool error = false;
@@ -535,32 +530,26 @@ static pyc_object *get_small_tuple_object(RBuffer *buffer) {
}

static pyc_object *get_tuple_object(RBuffer *buffer) {
 pyc_object *ret = NULL;
 bool error = false;
 ut32 n = 0;

 n = get_ut32 (buffer, &error);
 if (n > ST32_MAX) {
  eprintf (""bad marshal data (tuple size out of range)\n"");
  return NULL;
 }
 if (error) {
  return NULL;
 }
 ret = get_array_object_generic (buffer, n);
 if (ret) {
  ret->type = TYPE_TUPLE;
  return ret;
 }
 return NULL;
}

static pyc_object *get_list_object(RBuffer *buffer) {
 pyc_object *ret = NULL;
 bool error = false;
 ut32 n = 0;

 n = get_ut32 (buffer, &error);
 if (n > ST32_MAX) {
  eprintf (""bad marshal data (list size out of range)\n"");
  return NULL;
@@ -616,7 +605,6 @@ static pyc_object *get_dict_object(RBuffer *buffer) {
}

static pyc_object *get_set_object(RBuffer *buffer) {
 pyc_object *ret = NULL;
 bool error = false;
 ut32 n = get_ut32 (buffer, &error);
 if (n > ST32_MAX) {
@@ -626,11 +614,10 @@ static pyc_object *get_set_object(RBuffer *buffer) {
 if (error) {
  return NULL;
 }
 ret = get_array_object_generic (buffer, n);
 if (!ret) {
  return NULL;
 }
 ret->type = TYPE_SET;
 return ret;
}


","39
libr/bin/format/pyc/marshal.c
@@ -1,4 +1,4 @@
/* radare - LGPL3 - Copyright 2016-2021 - Matthieu (c0riolis) Tardy - l0stb1t*/
/* radare - LGPL3 - Copyright 2016-2022 - Matthieu (c0riolis) Tardy - l0stb1t */

#include <r_io.h>
#include <r_bin.h>
@@ -9,9 +9,9 @@
#define if_true_return(cond,ret) if(cond){return(ret);}

// TODO: kill globals
static ut32 magic_int;
static ut32 symbols_ordinal = 0;
static RList *refs = NULL; // If you don't have a good reason, do not change this. And also checkout !refs in get_code_object()
static R_TH_LOCAL ut32 magic_int;
static R_TH_LOCAL ut32 symbols_ordinal = 0;
static R_TH_LOCAL RList *refs = NULL; // If you don't have a good reason, do not change this. And also checkout !refs in get_code_object()

/* interned_table is used to handle TYPE_INTERNED object */
extern RList *interned_table;
@@ -500,13 +500,9 @@ static pyc_object *get_array_object_generic(RBuffer *buffer, ut32 size) {
 }
 for (i = 0; i < size; i++) {
  tmp = get_object (buffer);
  if (!tmp) {
   r_list_free (ret->data);
   R_FREE (ret);
   return NULL;
  }
  if (!r_list_append (ret->data, tmp)) {
  if (!tmp || !r_list_append (ret->data, tmp)) {
   free_object (tmp);
   ((RList*)ret->data)->free = NULL;
   r_list_free (ret->data);
   free (ret);
   return NULL;
@@ -516,7 +512,6 @@ static pyc_object *get_array_object_generic(RBuffer *buffer, ut32 size) {
}

/* small TYPE_SMALL_TUPLE doesn't exist in python2 */
/* */
static pyc_object *get_small_tuple_object(RBuffer *buffer) {
 pyc_object *ret = NULL;
 bool error = false;
@@ -535,32 +530,26 @@ static pyc_object *get_small_tuple_object(RBuffer *buffer) {
}

static pyc_object *get_tuple_object(RBuffer *buffer) {
 pyc_object *ret = NULL;
 bool error = false;
 ut32 n = 0;

 n = get_ut32 (buffer, &error);
 ut32 n = get_ut32 (buffer, &error);
 if (n > ST32_MAX) {
  eprintf (""bad marshal data (tuple size out of range)\n"");
  return NULL;
 }
 if (error) {
  return NULL;
 }
 ret = get_array_object_generic (buffer, n);
 pyc_object *ret = get_array_object_generic (buffer, n);
 if (ret) {
  ret->type = TYPE_TUPLE;
  return ret;
 }
 return NULL;
 return ret;
}

static pyc_object *get_list_object(RBuffer *buffer) {
 pyc_object *ret = NULL;
 bool error = false;
 ut32 n = 0;

 n = get_ut32 (buffer, &error);
 ut32 n = get_ut32 (buffer, &error);
 if (n > ST32_MAX) {
  eprintf (""bad marshal data (list size out of range)\n"");
  return NULL;
@@ -616,7 +605,6 @@ static pyc_object *get_dict_object(RBuffer *buffer) {
}

static pyc_object *get_set_object(RBuffer *buffer) {
 pyc_object *ret = NULL;
 bool error = false;
 ut32 n = get_ut32 (buffer, &error);
 if (n > ST32_MAX) {
@@ -626,11 +614,10 @@ static pyc_object *get_set_object(RBuffer *buffer) {
 if (error) {
  return NULL;
 }
 ret = get_array_object_generic (buffer, n);
 if (!ret) {
  return NULL;
 pyc_object *ret = get_array_object_generic (buffer, n);
 if (ret) {
  ret->type = TYPE_SET;
 }
 ret->type = TYPE_SET;
 return ret;
}"
https://huntr.dev/bounties/3dcb6f40-45cd-403b-929f-db123fde32c0/,Use After Free in radareorg/radare2,"This vulnerability is of use-after-free. The bug exists in latest stable release (radare2-5.5.4). Specifically, the vulnerable code is picked out as follows (libr/io/io_bank.c):",CVE-2022-0139,CWE-416: Use After Free,https://www.github.com/radareorg/radare2/commit/37897226a1a31f982bfefdc4aeefc2e50355c73c,"@@ -230,7 +230,10 @@ R_API bool r_io_bank_map_add_top(RIO *io, const ut32 bankid, const ut32 mapid) {
  //delete all submaps that are completly included in sm
  RRBNode *next = r_rbnode_next (entry);
  // this can be optimized, there is no need to do search here
  r_crbtree_delete (bank->submaps, entry->data, _find_sm_by_from_vaddr_cb, NULL);



  entry = next;
 }
 if (entry && r_io_submap_from (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {

","5
libr/io/io_bank.c
@@ -230,7 +230,10 @@ R_API bool r_io_bank_map_add_top(RIO *io, const ut32 bankid, const ut32 mapid) {
  //delete all submaps that are completly included in sm
  RRBNode *next = r_rbnode_next (entry);
  // this can be optimized, there is no need to do search here
  r_crbtree_delete (bank->submaps, entry->data, _find_sm_by_from_vaddr_cb, NULL);
  bool a = r_crbtree_delete (bank->submaps, entry->data, _find_sm_by_from_vaddr_cb, NULL);
  if (!a) {
   break;
  }
  entry = next;
 }
 if (entry && r_io_submap_from (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {"
https://huntr.dev/bounties/e19e109f-acf0-4048-8ee8-1b10a870f1e9/,Out-of-bounds Read in mruby/mruby,OOB read and OOB write in mrb_ary_push.,CVE-2022-0525,CWE-125: Out-of-bounds Read,https://www.github.com/mruby/mruby/commit/0849a2885f81cfd82134992c06df3ccd59052ac7,"@@ -1865,15 +1865,21 @@ gen_assignment(codegen_scope *s, node *tree, node *rhs, int sp, int val)
          }
        }
        if (tree->cdr->car) {       /* keyword arguments */






          gen_hash(s, tree->cdr->car->cdr, VAL, 0);
          if (n < 14) {
            n++;
            push();
          }
          else {
            pop();
            genop_2(s, OP_ARYPUSH, cursp(), 1);
          }

        }
      }
      if (rhs) {

","10
mrbgems/mruby-compiler/core/codegen.c
@@ -1865,15 +1865,21 @@ gen_assignment(codegen_scope *s, node *tree, node *rhs, int sp, int val)
          }
        }
        if (tree->cdr->car) {       /* keyword arguments */
          if (n == 14) {
            pop_n(n);
            genop_2(s, OP_ARRAY, cursp(), n);
            push();
            n = 15;
          }
          gen_hash(s, tree->cdr->car->cdr, VAL, 0);
          if (n < 14) {
            n++;
            push();
          }
          else {
            pop();
            pop_n(2);
            genop_2(s, OP_ARYPUSH, cursp(), 1);
          }
          push();
        }
      }
      if (rhs) {"
https://huntr.dev/bounties/41e1ac4e-fe08-4731-811e-1808bde0686d/,Generation of Error Message Containing Sensitive Information in luigirizzo/netmap,"In the Netmap source code, calls to DbgPrint(); can be found to contain a formatting argument (%p to be specific) yet no argument, this would (in most cases) lead to nearby data being printed to the debug stream.",,CWE-209: Generation of Error Message Containing Sensitive Information,https://www.github.com/luigirizzo/netmap/commit/df7abd260385456cdd1961df25bd472b234c4ce9,"@@ -940,7 +940,7 @@ nm_os_ifnet_mtu(struct ifnet *ifp)
void
generic_timer_handler(struct hrtimer *t)
{
 DbgPrint(""unimplemented generic_timer_handler %p\n"", t);
#if 0
 struct nm_generic_mit *mit =
  container_of(t, struct nm_generic_mit, mit_timer);
@@ -968,7 +968,7 @@ generic_timer_handler(struct hrtimer *t)
void nm_os_mitigation_init(struct nm_generic_mit *mit, int idx,
struct netmap_adapter *na)
{
 DbgPrint(""unimplemented generic_timer_handler %p\n"");
 //KeInitializeDpc(&mit->mit_timer.deferred_proc, &generic_timer_handler, NULL);
 //KeInitializeTimer(&mit->mit_timer.timer);
 //hrtimer_init(&mit->mit_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
@@ -980,7 +980,7 @@ struct netmap_adapter *na)

void nm_os_mitigation_start(struct nm_generic_mit *mit)
{
 DbgPrint(""unimplemented generic_timer_handler %p\n"");
 //LARGE_INTEGER test;
 //KeSetTimerEx(&mit->mit_timer.timer, test, 1000, &mit->mit_timer.deferred_proc);
 //mit->mit_timer.active = TRUE;
@@ -990,13 +990,13 @@ void nm_os_mitigation_start(struct nm_generic_mit *mit)

void nm_os_mitigation_restart(struct nm_generic_mit *mit)
{
 DbgPrint(""unimplemented nm_os_mitigation_start %p\n"");
 //hrtimer_forward_now(&mit->mit_timer, ktime_set(0, netmap_generic_mit));
}

int nm_os_mitigation_active(struct nm_generic_mit *mit)
{
 DbgPrint(""unimplemented nm_os_mitigation_active %p\n"");
 return 0;
 //return mit->mit_timer.active;
 //return hrtimer_active(&mit->mit_timer);

","10
WINDOWS/netmap_windows.c
@@ -940,7 +940,7 @@ nm_os_ifnet_mtu(struct ifnet *ifp)
void
generic_timer_handler(struct hrtimer *t)
{
 DbgPrint(""unimplemented generic_timer_handler %p\n"", t);
 DbgPrint(""unimplemented generic_timer_handler\n"", t);
#if 0
 struct nm_generic_mit *mit =
  container_of(t, struct nm_generic_mit, mit_timer);
@@ -968,7 +968,7 @@ generic_timer_handler(struct hrtimer *t)
void nm_os_mitigation_init(struct nm_generic_mit *mit, int idx,
struct netmap_adapter *na)
{
 DbgPrint(""unimplemented generic_timer_handler %p\n"");
 DbgPrint(""unimplemented generic_timer_handler\n"");
 //KeInitializeDpc(&mit->mit_timer.deferred_proc, &generic_timer_handler, NULL);
 //KeInitializeTimer(&mit->mit_timer.timer);
 //hrtimer_init(&mit->mit_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
@@ -980,7 +980,7 @@ struct netmap_adapter *na)

void nm_os_mitigation_start(struct nm_generic_mit *mit)
{
 DbgPrint(""unimplemented generic_timer_handler %p\n"");
 DbgPrint(""unimplemented generic_timer_handler\n"");
 //LARGE_INTEGER test;
 //KeSetTimerEx(&mit->mit_timer.timer, test, 1000, &mit->mit_timer.deferred_proc);
 //mit->mit_timer.active = TRUE;
@@ -990,13 +990,13 @@ void nm_os_mitigation_start(struct nm_generic_mit *mit)

void nm_os_mitigation_restart(struct nm_generic_mit *mit)
{
 DbgPrint(""unimplemented nm_os_mitigation_start %p\n"");
 DbgPrint(""unimplemented nm_os_mitigation_start\n"");
 //hrtimer_forward_now(&mit->mit_timer, ktime_set(0, netmap_generic_mit));
}

int nm_os_mitigation_active(struct nm_generic_mit *mit)
{
 DbgPrint(""unimplemented nm_os_mitigation_active %p\n"");
 DbgPrint(""unimplemented nm_os_mitigation_active\n"");
 return 0;
 //return mit->mit_timer.active;
 //return hrtimer_active(&mit->mit_timer);"
https://huntr.dev/bounties/2366180c-6d95-46a3-8c0c-373f6628e25f/,NULL Pointer Dereference in gpac/gpac,Null Pointer Dereference in afrt_box_read,,CWE-476: NULL Pointer Dereference,https://www.github.com/gpac/gpac/commit/34a23ca102a0030927ca369086ec3d9685a83ff2,"@@ -562,17 +562,18 @@ GF_Err asrt_box_read(GF_Box *s, GF_BitStream *bs)
 for (i=0; i<ptr->quality_entry_count; i++) {
  int j=0;
  u32 tmp_strsize=(u32)ptr->size;

  char *tmp_str = (char*) gf_malloc(tmp_strsize+1);
  if (!tmp_str) return GF_OUT_OF_MEM;
  tmp_str[tmp_strsize]=0;
  while (tmp_strsize) {
   tmp_str[j] = gf_bs_read_u8(bs);

   tmp_strsize--;
   if (!tmp_str[j])
    break;
   j++;
  }
  ISOM_DECREASE_SIZE(ptr, j)
  gf_list_insert(ptr->quality_segment_url_modifiers, tmp_str, i);
 }

@@ -678,23 +679,26 @@ GF_Err afrt_box_read(GF_Box *s, GF_BitStream *bs)
 if (ptr->size < ptr->quality_entry_count)
  return GF_ISOM_INVALID_FILE;


 for (i=0; i<ptr->quality_entry_count; i++) {
  int j=0;
  u32 tmp_strsize=(u32)ptr->size-8;

  char *tmp_str = (char*) gf_malloc(tmp_strsize+1);
  if (!tmp_str) return GF_OUT_OF_MEM;
  tmp_str[tmp_strsize]=0;
  while (tmp_strsize) {
   tmp_str[j] = gf_bs_read_u8(bs);

   tmp_strsize--;
   if (!tmp_str[j])
    break;
   j++;
  }
  ISOM_DECREASE_SIZE(ptr, j)
  gf_list_insert(ptr->quality_segment_url_modifiers, tmp_str, i);
 }


 ptr->fragment_run_entry_count = gf_bs_read_u32(bs);
 if (ptr->size / 16 < ptr->fragment_run_entry_count)
  return GF_ISOM_INVALID_FILE;

","10
src/isomedia/box_code_adobe.c
@@ -562,17 +562,18 @@ GF_Err asrt_box_read(GF_Box *s, GF_BitStream *bs)
 for (i=0; i<ptr->quality_entry_count; i++) {
  int j=0;
  u32 tmp_strsize=(u32)ptr->size;
  if (!tmp_strsize) return GF_ISOM_INVALID_FILE;
  char *tmp_str = (char*) gf_malloc(tmp_strsize+1);
  if (!tmp_str) return GF_OUT_OF_MEM;
  tmp_str[tmp_strsize]=0;
  while (tmp_strsize) {
   tmp_str[j] = gf_bs_read_u8(bs);
   ISOM_DECREASE_SIZE(ptr, 1)
   tmp_strsize--;
   if (!tmp_str[j])
    break;
   j++;
  }
  ISOM_DECREASE_SIZE(ptr, j)
  gf_list_insert(ptr->quality_segment_url_modifiers, tmp_str, i);
 }

@@ -678,23 +679,26 @@ GF_Err afrt_box_read(GF_Box *s, GF_BitStream *bs)
 if (ptr->size < ptr->quality_entry_count)
  return GF_ISOM_INVALID_FILE;


 for (i=0; i<ptr->quality_entry_count; i++) {
  int j=0;
  u32 tmp_strsize=(u32)ptr->size-8;
  u32 tmp_strsize = (u32) ptr->size;
  if (!tmp_strsize) return GF_ISOM_INVALID_FILE;
  char *tmp_str = (char*) gf_malloc(tmp_strsize+1);
  if (!tmp_str) return GF_OUT_OF_MEM;
  tmp_str[tmp_strsize]=0;
  while (tmp_strsize) {
   tmp_str[j] = gf_bs_read_u8(bs);
   ISOM_DECREASE_SIZE(ptr, 1)
   tmp_strsize--;
   if (!tmp_str[j])
    break;
   j++;
  }
  ISOM_DECREASE_SIZE(ptr, j)
  gf_list_insert(ptr->quality_segment_url_modifiers, tmp_str, i);
 }

 ISOM_DECREASE_SIZE(ptr, 4)
 ptr->fragment_run_entry_count = gf_bs_read_u32(bs);
 if (ptr->size / 16 < ptr->fragment_run_entry_count)
  return GF_ISOM_INVALID_FILE;"
https://huntr.dev/bounties/54725c8c-87f4-41b6-878c-01d8e0ee7027/,NULL Pointer Dereference in mruby/mruby,There is a NULL Pointer Dereference in iv_free (src/variable.c:232:20). This bug has been found on mruby lastest commit (hash 00f2b74ab2c1f03084908c815dcd0934f9fc702a) on Ubuntu 20.04 for x86_64/amd64.,CVE-2022-0481,CWE-476: NULL Pointer Dereference,https://www.github.com/mruby/mruby/commit/ae3c99767a27f5c6c584162e2adc6a5d0eb2c54e,"@@ -1603,7 +1603,7 @@ gen_hash(codegen_scope *s, node *tree, int val, int limit)

  while (tree) {
    if (nint(tree->car->car->car) == NODE_KW_REST_ARGS) {
      if (len > 0) {
        pop_n(len*2);
        if (!update) {
          genop_2(s, OP_HASH, cursp(), len);
@@ -1615,7 +1615,7 @@ gen_hash(codegen_scope *s, node *tree, int val, int limit)
        push();
      }
      codegen(s, tree->car->cdr, val);
      if (len > 0 || update) {
        pop(); pop();
        genop_1(s, OP_HASHCAT, cursp());
        push();

","4
mrbgems/mruby-compiler/core/codegen.c
@@ -1603,7 +1603,7 @@ gen_hash(codegen_scope *s, node *tree, int val, int limit)

  while (tree) {
    if (nint(tree->car->car->car) == NODE_KW_REST_ARGS) {
      if (len > 0) {
      if (val && len > 0) {
        pop_n(len*2);
        if (!update) {
          genop_2(s, OP_HASH, cursp(), len);
@@ -1615,7 +1615,7 @@ gen_hash(codegen_scope *s, node *tree, int val, int limit)
        push();
      }
      codegen(s, tree->car->cdr, val);
      if (len > 0 || update) {
      if (val && (len > 0 || update)) {
        pop(); pop();
        genop_1(s, OP_HASHCAT, cursp());
        push();"
https://huntr.dev/bounties/d7a534cb-df7a-48ba-8ce3-46b1551a9c47/,NULL Pointer Dereference in gpac/gpac,Null Pointer Dereference in gitn_box_del,CVE-2021-4043,CWE-476: NULL Pointer Dereference,https://www.github.com/gpac/gpac/commit/64a2e1b799352ac7d7aad1989bc06e7b0f2b01db,"@@ -11083,10 +11083,12 @@ void gitn_box_del(GF_Box *s)
 u32 i;
 GroupIdToNameBox *ptr = (GroupIdToNameBox *)s;
 if (ptr == NULL) return;
 for (i=0; i<ptr->nb_entries; i++) {
  if (ptr->entries[i].name) gf_free(ptr->entries[i].name);



 }
 if (ptr->entries) gf_free(ptr->entries);
 gf_free(ptr);
}


","8
src/isomedia/box_code_base.c
@@ -11083,10 +11083,12 @@ void gitn_box_del(GF_Box *s)
 u32 i;
 GroupIdToNameBox *ptr = (GroupIdToNameBox *)s;
 if (ptr == NULL) return;
 for (i=0; i<ptr->nb_entries; i++) {
  if (ptr->entries[i].name) gf_free(ptr->entries[i].name);
 if (ptr->entries) {
  for (i=0; i<ptr->nb_entries; i++) {
   if (ptr->entries[i].name) gf_free(ptr->entries[i].name);
  }
  gf_free(ptr->entries);
 }
 if (ptr->entries) gf_free(ptr->entries);
 gf_free(ptr);
}"
https://huntr.dev/bounties/1f84e79d-70e7-4b29-8b48-a108f81c89aa/,NULL Pointer Dereference in radareorg/radare2,radare2 suffers from a NULL pointer dereference error in load_buffer of bin_xnu_kernelcache.c,CVE-2022-0419,CWE-476: NULL Pointer Dereference,https://www.github.com/radareorg/radare2/commit/feaa4e7f7399c51ee6f52deb84dc3f795b4035d6,"@@ -242,7 +242,9 @@ static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadadd

beach:
 r_buf_free (fbuf);
 obj->cache_buf = NULL;


 MACH0_(mach0_free) (main_mach0);
 return false;
}

","4
libr/bin/p/bin_xnu_kernelcache.c
@@ -242,7 +242,9 @@ static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadadd

beach:
 r_buf_free (fbuf);
 obj->cache_buf = NULL;
 if (obj) {
  obj->cache_buf = NULL;
 }
 MACH0_(mach0_free) (main_mach0);
 return false;
}"
https://huntr.dev/bounties/779806b4-d1c4-42ec-a304-5d8db54fdc72/,Heap-based Buffer Overflow in gpac/gpac,Heap-based Buffer Overflow in gpac,,CWE-122: Heap-based Buffer Overflow,https://www.github.com/gpac/gpac/commit/9c74581c7827a6e1aea0f0a6f787ae22b4331a12,"@@ -624,6 +624,26 @@ Gets the current cookie on the bitstream
 */
u64 gf_bs_get_cookie(GF_BitStream *bs);





















/*! @} */

#ifdef __cplusplus

@@ -897,7 +897,7 @@ typedef struct
 Bool mem_mode;
 /*bitstream object for mem mode - this bitstream is NOT destroyed by gf_av1_reset_state(state, GF_TRUE) */
 GF_BitStream *bs;
 Bool bs_overread, unframed;
 u8 *frame_obus;
 u32 frame_obus_alloc;


@@ -440,10 +440,12 @@ static GF_Err nalu_process(BSAggCtx *ctx, BSAggOut *pctx, u32 codec_type)
{
 u32 size, pck_size, i, count, tot_size=0, nb_done=0;
 u64 min_dts = GF_FILTER_NO_TS;
 u32 min_timescale;
 GF_Err process_error = GF_OK;
 Bool has_svc_prefix = GF_FALSE;



 count = gf_list_count(pctx->ipids);
 for (i=0; i<count; i++) {
  u64 ts;
@@ -517,11 +519,21 @@ static GF_Err nalu_process(BSAggCtx *ctx, BSAggOut *pctx, u32 codec_type)
    e = GF_NON_COMPLIANT_BITSTREAM;
    break;
   }






   //AVC
   if (codec_type==0) {
    nal_type = data[size] & 0x1F;
    if ((nal_type == GF_AVC_NALU_SVC_PREFIX_NALU) || (nal_type==GF_AVC_NALU_SVC_SLICE)) {





     has_svc_prefix = GF_TRUE;
     //quick parse svc nal header (right after 1-byte nal header)
     //u32 prio_id = (data[size+1]) & 0x3F;

@@ -1014,7 +1014,7 @@ static GF_Err none_split_packet(BSSplitCtx *ctx, BSSplitIn *pctx, GF_FilterPacke

static GF_Err nalu_split_packet(BSSplitCtx *ctx, BSSplitIn *pctx, GF_FilterPacket *pck, u32 codec_type)
{
 u32 size, pck_size;
 GF_Err e;
 u64 pck_ts;
 Bool has_svc_prefix = GF_FALSE;
@@ -1034,6 +1034,7 @@ static GF_Err nalu_split_packet(BSSplitCtx *ctx, BSSplitIn *pctx, GF_FilterPacke
 if (!pctx->first_ts_plus_one) {
  pctx->first_ts_plus_one = pck_ts+1;
 }


 size=0;
 while (size<pck_size) {
@@ -1055,6 +1056,11 @@ static GF_Err nalu_split_packet(BSSplitCtx *ctx, BSSplitIn *pctx, GF_FilterPacke
   e = GF_NON_COMPLIANT_BITSTREAM;
   break;
  }






  //AVC
  if (codec_type==0) {

@@ -575,7 +575,7 @@ static void gf_inspect_dump_nalu_internal(FILE *dump, u8 *ptr, u32 ptr_size, Boo
 if (hevc) {
#ifndef GPAC_DISABLE_HEVC

  if (ptr_size==1) {
   gf_fprintf(dump, ""error=\""invalid nal size 1\""/>\n"");
   return;
  }
@@ -863,6 +863,11 @@ static void gf_inspect_dump_nalu_internal(FILE *dump, u8 *ptr, u32 ptr_size, Boo
 if (vvc) {
  u8 lid, tid;






  if (full_bs_dump) {
   vvc->parse_mode = 2;
   if (pctx) {
@@ -1015,6 +1020,10 @@ static void gf_inspect_dump_nalu_internal(FILE *dump, u8 *ptr, u32 ptr_size, Boo
 }

 //avc




 type = ptr[0] & 0x1F;
 nal_ref_idc = ptr[0] & 0x60;
 nal_ref_idc>>=5;

@@ -2159,6 +2159,8 @@ static s32 naludmx_parse_nal_hevc(GF_NALUDmxCtx *ctx, char *data, u32 size, Bool
 u8 nal_unit_type, temporal_id, layer_id;
 *skip_nal = GF_FALSE;



 gf_bs_reassign_buffer(ctx->bs_r, data, size);
 res = gf_hevc_parse_nalu_bs(ctx->bs_r, ctx->hevc_state, &nal_unit_type, &temporal_id, &layer_id);
 ctx->nb_nalus++;
@@ -2333,6 +2335,7 @@ static s32 naludmx_parse_nal_vvc(GF_NALUDmxCtx *ctx, char *data, u32 size, Bool
 u8 nal_unit_type, temporal_id, layer_id;
 *skip_nal = GF_FALSE;


 gf_bs_reassign_buffer(ctx->bs_r, data, size);
 res = gf_vvc_parse_nalu_bs(ctx->bs_r, ctx->vvc_state, &nal_unit_type, &temporal_id, &layer_id);
 ctx->nb_nalus++;
@@ -2510,6 +2513,7 @@ static s32 naludmx_parse_nal_avc(GF_NALUDmxCtx *ctx, char *data, u32 size, u32 n
 s32 ps_idx = 0;
 s32 res = 0;


 gf_bs_reassign_buffer(ctx->bs_r, data, size);
 *skip_nal = GF_FALSE;
 res = gf_avc_parse_nalu(ctx->bs_r, ctx->avc_state);

@@ -2746,6 +2746,7 @@ GF_Err avcc_box_read(GF_Box *s, GF_BitStream *bs)
 else
  is_avcc = GF_FALSE;


 ptr->config->configurationVersion = gf_bs_read_u8(bs);
 ptr->config->AVCProfileIndication = gf_bs_read_u8(bs);
 ptr->config->profile_compatibility = gf_bs_read_u8(bs);
@@ -2820,7 +2821,7 @@ GF_Err avcc_box_read(GF_Box *s, GF_BitStream *bs)
   }
  }
#endif
  GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (""AVCC: invalid syntax for REXT profile, patching.\n""));
  return GF_OK;
 }
 ISOM_DECREASE_SIZE(ptr, 4)

","20
include/gpac/bitstream.h
@@ -624,6 +624,26 @@ Gets the current cookie on the bitstream
 */
u64 gf_bs_get_cookie(GF_BitStream *bs);


/*!
\brief Marks overflow access
Marks the bitstream as overflown (reading outside of buffer range). Marking is done automatically when reading but can be forced using this function.
\param bs the target bitstream
\param reset if GF_TRUE, reset overflown state, otherwise mark as overflown
 */
void gf_bs_mark_overflow(GF_BitStream *bs, Bool reset);

/*!
\brief Gets overflow state
Gets overflow state of the bitstream
\param bs the target bitstream
\return 2 if an overflow was marked by user using \ref gf_bs_mark_overflow, 1 if an overflow occured, 0 otherwise
 */
u32 gf_bs_is_overflow(GF_BitStream *bs);

/*! @} */

#ifdef __cplusplus
2
include/gpac/internal/media_dev.h
@@ -897,7 +897,7 @@ typedef struct
 Bool mem_mode;
 /*bitstream object for mem mode - this bitstream is NOT destroyed by gf_av1_reset_state(state, GF_TRUE) */
 GF_BitStream *bs;
 Bool bs_overread, unframed;
 Bool unframed;
 u8 *frame_obus;
 u32 frame_obus_alloc;

14
src/filters/bs_agg.c
@@ -440,10 +440,12 @@ static GF_Err nalu_process(BSAggCtx *ctx, BSAggOut *pctx, u32 codec_type)
{
 u32 size, pck_size, i, count, tot_size=0, nb_done=0;
 u64 min_dts = GF_FILTER_NO_TS;
 u32 min_timescale;
 u32 min_timescale, min_nal_size;
 GF_Err process_error = GF_OK;
 Bool has_svc_prefix = GF_FALSE;

 min_nal_size = codec_type ? 2 : 1;

 count = gf_list_count(pctx->ipids);
 for (i=0; i<count; i++) {
  u64 ts;
@@ -517,11 +519,21 @@ static GF_Err nalu_process(BSAggCtx *ctx, BSAggOut *pctx, u32 codec_type)
    e = GF_NON_COMPLIANT_BITSTREAM;
    break;
   }
   if (nal_size < min_nal_size) {
    GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[BSAgg] Invalid NAL size %d but mn size %d\n"", nal_size, min_nal_size));
    e = GF_NON_COMPLIANT_BITSTREAM;
    break;
   }

   //AVC
   if (codec_type==0) {
    nal_type = data[size] & 0x1F;
    if ((nal_type == GF_AVC_NALU_SVC_PREFIX_NALU) || (nal_type==GF_AVC_NALU_SVC_SLICE)) {
     if (nal_size < 4) {
      GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[BSAgg] Invalid NAL size %d but mn size 4\n"", nal_size));
      e = GF_NON_COMPLIANT_BITSTREAM;
      break;
     }
     has_svc_prefix = GF_TRUE;
     //quick parse svc nal header (right after 1-byte nal header)
     //u32 prio_id = (data[size+1]) & 0x3F;
8
src/filters/bs_split.c
@@ -1014,7 +1014,7 @@ static GF_Err none_split_packet(BSSplitCtx *ctx, BSSplitIn *pctx, GF_FilterPacke

static GF_Err nalu_split_packet(BSSplitCtx *ctx, BSSplitIn *pctx, GF_FilterPacket *pck, u32 codec_type)
{
 u32 size, pck_size;
 u32 size, pck_size, min_nal_size;
 GF_Err e;
 u64 pck_ts;
 Bool has_svc_prefix = GF_FALSE;
@@ -1034,6 +1034,7 @@ static GF_Err nalu_split_packet(BSSplitCtx *ctx, BSSplitIn *pctx, GF_FilterPacke
 if (!pctx->first_ts_plus_one) {
  pctx->first_ts_plus_one = pck_ts+1;
 }
 min_nal_size = codec_type ? 2 : 1;

 size=0;
 while (size<pck_size) {
@@ -1055,6 +1056,11 @@ static GF_Err nalu_split_packet(BSSplitCtx *ctx, BSSplitIn *pctx, GF_FilterPacke
   e = GF_NON_COMPLIANT_BITSTREAM;
   break;
  }
  if (nal_size < min_nal_size) {
   GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[BSSplit] Invalid NAL size %d but mn size %d\n"", nal_size, min_nal_size));
   e = GF_NON_COMPLIANT_BITSTREAM;
   break;
  }

  //AVC
  if (codec_type==0) {
11
src/filters/inspect.c
@@ -575,7 +575,7 @@ static void gf_inspect_dump_nalu_internal(FILE *dump, u8 *ptr, u32 ptr_size, Boo
 if (hevc) {
#ifndef GPAC_DISABLE_HEVC

  if (ptr_size==1) {
  if (ptr_size<=1) {
   gf_fprintf(dump, ""error=\""invalid nal size 1\""/>\n"");
   return;
  }
@@ -863,6 +863,11 @@ static void gf_inspect_dump_nalu_internal(FILE *dump, u8 *ptr, u32 ptr_size, Boo
 if (vvc) {
  u8 lid, tid;

  if (ptr_size<=1) {
   gf_fprintf(dump, ""error=\""invalid nal size 1\""/>\n"");
   return;
  }

  if (full_bs_dump) {
   vvc->parse_mode = 2;
   if (pctx) {
@@ -1015,6 +1020,10 @@ static void gf_inspect_dump_nalu_internal(FILE *dump, u8 *ptr, u32 ptr_size, Boo
 }

 //avc
 if (!ptr_size) {
  gf_fprintf(dump, ""error=\""invalid nal size 1\""/>\n"");
  return;
 }
 type = ptr[0] & 0x1F;
 nal_ref_idc = ptr[0] & 0x60;
 nal_ref_idc>>=5;
4
src/filters/reframe_nalu.c
@@ -2159,6 +2159,8 @@ static s32 naludmx_parse_nal_hevc(GF_NALUDmxCtx *ctx, char *data, u32 size, Bool
 u8 nal_unit_type, temporal_id, layer_id;
 *skip_nal = GF_FALSE;

 if (size<2) return -1;

 gf_bs_reassign_buffer(ctx->bs_r, data, size);
 res = gf_hevc_parse_nalu_bs(ctx->bs_r, ctx->hevc_state, &nal_unit_type, &temporal_id, &layer_id);
 ctx->nb_nalus++;
@@ -2333,6 +2335,7 @@ static s32 naludmx_parse_nal_vvc(GF_NALUDmxCtx *ctx, char *data, u32 size, Bool
 u8 nal_unit_type, temporal_id, layer_id;
 *skip_nal = GF_FALSE;

 if (size<2) return -1;
 gf_bs_reassign_buffer(ctx->bs_r, data, size);
 res = gf_vvc_parse_nalu_bs(ctx->bs_r, ctx->vvc_state, &nal_unit_type, &temporal_id, &layer_id);
 ctx->nb_nalus++;
@@ -2510,6 +2513,7 @@ static s32 naludmx_parse_nal_avc(GF_NALUDmxCtx *ctx, char *data, u32 size, u32 n
 s32 ps_idx = 0;
 s32 res = 0;

 if (!size) return -1;
 gf_bs_reassign_buffer(ctx->bs_r, data, size);
 *skip_nal = GF_FALSE;
 res = gf_avc_parse_nalu(ctx->bs_r, ctx->avc_state);
3
src/isomedia/avc_ext.c
@@ -2746,6 +2746,7 @@ GF_Err avcc_box_read(GF_Box *s, GF_BitStream *bs)
 else
  is_avcc = GF_FALSE;

 //we don't use gf_odf_avc_cfg_read to deal with missing rext profile signaling on many files
 ptr->config->configurationVersion = gf_bs_read_u8(bs);
 ptr->config->AVCProfileIndication = gf_bs_read_u8(bs);
 ptr->config->profile_compatibility = gf_bs_read_u8(bs);
@@ -2820,7 +2821,7 @@ GF_Err avcc_box_read(GF_Box *s, GF_BitStream *bs)
   }
  }
#endif
  GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (""AVCC: invalid syntax for REXT profile, patching.\n""));
  GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (""[isom/avcc] Missing REXT profile signaling, patching.\n""));
  return GF_OK;
 }
 ISOM_DECREASE_SIZE(ptr, 4)"
https://huntr.dev/bounties/a08437cc-25aa-4116-8069-816f78a2247c/,NULL Pointer Dereference in gpac/gpac,Null Pointer Dereference in gf_dump_vrml_field.isra (),,CWE-476: NULL Pointer Dereference,https://www.github.com/gpac/gpac/commit/9f8510835b97a729baf3646a3171bf51b4a8592e,"@@ -480,10 +480,10 @@ void isor_reader_get_sample(ISOMChannel *ch)
     ch->sample_num--;
   } else {
    if (ch->to_init && ch->sample_num) {
     GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[IsoMedia] Failed to fetch initial sample %d for track %d\n""));
     ch->last_state = GF_ISOM_INVALID_FILE;
    }
    if (ch->sample_num >= gf_isom_get_sample_count(ch->owner->mov, ch->track)) {
     ch->last_state = GF_EOS;
    }
   }
@@ -507,6 +507,10 @@ void isor_reader_get_sample(ISOMChannel *ch)
  } else {
   e = gf_isom_last_error(ch->owner->mov);
   GF_LOG((e==GF_ISOM_INCOMPLETE_FILE) ? GF_LOG_DEBUG : GF_LOG_WARNING, GF_LOG_DASH, (""[IsoMedia] Track #%d fail to fetch sample %d / %d: %s\n"", ch->track, ch->sample_num, gf_isom_get_sample_count(ch->owner->mov, ch->track), gf_error_to_string(e) ));




  }
  return;
 }

@@ -1075,6 +1075,11 @@ GF_Err gf_media_export_saf(GF_MediaExporter *dumper)
   GF_ISOSample *samp;
   if (safs[i].last_sample==safs[i].nb_samp) continue;
   samp = gf_isom_get_sample(dumper->file, safs[i].track_num, safs[i].last_sample + 1, &di);





   gf_saf_mux_add_au(mux, safs[i].stream_id, (u32) (samp->DTS+samp->CTS_Offset), samp->data, samp->dataLength, (samp->IsRAP==RAP) ? 1 : 0);
   /*data is kept by muxer!!*/
   gf_free(samp);

@@ -939,10 +939,12 @@ static void gf_dump_vrml_field(GF_SceneDumper *sdump, GF_Node *node, GF_FieldInf
  }

  if (!sdump->XMLDump) gf_fprintf(sdump->trace, ""["");
  for (i=0; i<mffield->count; i++) {
   if (i) gf_fprintf(sdump->trace, "" "");
   gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);
   gf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, node);


  }
  if (!sdump->XMLDump) gf_fprintf(sdump->trace, ""]"");

@@ -1261,11 +1263,13 @@ static void gf_dump_vrml_proto_field(GF_SceneDumper *sdump, GF_Node *node, GF_Fi
    } else {
     gf_fprintf(sdump->trace, "" %s=\"""", GetXMTFieldTypeValueName(field.fieldType));
    }
    for (i=0; i<mffield->count; i++) {
     if (i) gf_fprintf(sdump->trace, "" "");
     if (field.fieldType != GF_SG_VRML_MFNODE) {
      gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);
      gf_dump_vrml_sffield(sdump, sf_type, slot_ptr, (mffield->count>1) ? 1 : 0, node);


     }
    }
    gf_fprintf(sdump->trace, ""\""/>\n"");



","10
src/filters/isoffin_read_ch.c
@@ -480,10 +480,10 @@ void isor_reader_get_sample(ISOMChannel *ch)
     ch->sample_num--;
   } else {
    if (ch->to_init && ch->sample_num) {
     GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[IsoMedia] Failed to fetch initial sample %d for track %d\n""));
     GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[IsoMedia] Failed to fetch initial sample %d for track %d\n"", ch->sample_num, ch->track));
     ch->last_state = GF_ISOM_INVALID_FILE;
    }
    if (ch->sample_num >= gf_isom_get_sample_count(ch->owner->mov, ch->track)) {
    } else {
     GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[IsoMedia] File truncated, aborting read for track %d\n"", ch->track));
     ch->last_state = GF_EOS;
    }
   }
@@ -507,6 +507,10 @@ void isor_reader_get_sample(ISOMChannel *ch)
  } else {
   e = gf_isom_last_error(ch->owner->mov);
   GF_LOG((e==GF_ISOM_INCOMPLETE_FILE) ? GF_LOG_DEBUG : GF_LOG_WARNING, GF_LOG_DASH, (""[IsoMedia] Track #%d fail to fetch sample %d / %d: %s\n"", ch->track, ch->sample_num, gf_isom_get_sample_count(ch->owner->mov, ch->track), gf_error_to_string(e) ));

   if ((e<GF_OK) && (e!=GF_ISOM_INCOMPLETE_FILE)) {
    ch->last_state = GF_EOS;
   }
  }
  return;
 }
5
src/media_tools/media_export.c
@@ -1075,6 +1075,11 @@ GF_Err gf_media_export_saf(GF_MediaExporter *dumper)
   GF_ISOSample *samp;
   if (safs[i].last_sample==safs[i].nb_samp) continue;
   samp = gf_isom_get_sample(dumper->file, safs[i].track_num, safs[i].last_sample + 1, &di);
   if (!samp) {
    gf_saf_mux_del(mux);
    return gf_isom_last_error(dumper->file);
   }

   gf_saf_mux_add_au(mux, safs[i].stream_id, (u32) (samp->DTS+samp->CTS_Offset), samp->data, samp->dataLength, (samp->IsRAP==RAP) ? 1 : 0);
   /*data is kept by muxer!!*/
   gf_free(samp);
22
src/scene_manager/scene_dump.c
@@ -939,10 +939,12 @@ static void gf_dump_vrml_field(GF_SceneDumper *sdump, GF_Node *node, GF_FieldInf
  }

  if (!sdump->XMLDump) gf_fprintf(sdump->trace, ""["");
  for (i=0; i<mffield->count; i++) {
   if (i) gf_fprintf(sdump->trace, "" "");
   gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);
   gf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, node);
  if (mffield) {
   for (i=0; i<mffield->count; i++) {
    if (i) gf_fprintf(sdump->trace, "" "");
    gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);
    gf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, node);
   }
  }
  if (!sdump->XMLDump) gf_fprintf(sdump->trace, ""]"");

@@ -1261,11 +1263,13 @@ static void gf_dump_vrml_proto_field(GF_SceneDumper *sdump, GF_Node *node, GF_Fi
    } else {
     gf_fprintf(sdump->trace, "" %s=\"""", GetXMTFieldTypeValueName(field.fieldType));
    }
    for (i=0; i<mffield->count; i++) {
     if (i) gf_fprintf(sdump->trace, "" "");
     if (field.fieldType != GF_SG_VRML_MFNODE) {
      gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);
      gf_dump_vrml_sffield(sdump, sf_type, slot_ptr, (mffield->count>1) ? 1 : 0, node);
    if (mffield) {
     for (i=0; i<mffield->count; i++) {
      if (i) gf_fprintf(sdump->trace, "" "");
      if (field.fieldType != GF_SG_VRML_MFNODE) {
       gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);
       gf_dump_vrml_sffield(sdump, sf_type, slot_ptr, (mffield->count>1) ? 1 : 0, node);
      }
     }
    }
    gf_fprintf(sdump->trace, ""\""/>\n"");
2
testsuite
Submodule testsuite updated 2 files
+6 −0 scripts/mp4box-io.sh
+1 −1 scripts/mp4box-sdp.sh"
https://huntr.dev/bounties/66e5def6-5463-4a57-a661-70e8ea604fc0/,Heap-based Buffer Overflow in gpac/gpac,When fuzzing gpac with clang 10 I found a heap overflow.,,CWE-122: Heap-based Buffer Overflow,https://www.github.com/gpac/gpac/commit/827d849fcb7a38c2c4a5a1ebcf6b1d4f3ff3a5b4,"@@ -242,9 +242,10 @@ GF_Err cprt_box_read(GF_Box *s,GF_BitStream *bs)
 }
 if (ptr->size) {
  u32 bytesToRead = (u32) ptr->size;
  ptr->notice = (char*)gf_malloc(bytesToRead * sizeof(char));
  if (ptr->notice == NULL) return GF_OUT_OF_MEM;
  gf_bs_read_data(bs, ptr->notice, bytesToRead);

 }
 return GF_OK;
}

","3
src/isomedia/box_code_base.c
@@ -242,9 +242,10 @@ GF_Err cprt_box_read(GF_Box *s,GF_BitStream *bs)
 }
 if (ptr->size) {
  u32 bytesToRead = (u32) ptr->size;
  ptr->notice = (char*)gf_malloc(bytesToRead * sizeof(char));
  ptr->notice = (char*)gf_malloc((bytesToRead+1) * sizeof(char));
  if (ptr->notice == NULL) return GF_OUT_OF_MEM;
  gf_bs_read_data(bs, ptr->notice, bytesToRead);
  ptr->notice[bytesToRead] = 0;
 }
 return GF_OK;
}"
https://huntr.dev/bounties/011ac07c-6139-4f43-b745-424143e60ac7/,Use After Free in gpac/gpac,Use After Free in gpac,,CWE-416: Use After Free,https://www.github.com/gpac/gpac/commit/96699aabae042f8f55cf8a85fa5758e3db752bae,"@@ -84,14 +84,15 @@ u32 gf_utf8_wcslen(const unsigned short *s);
/*!
\brief returns a UTF8 string from a string started with BOM

Returns the length in character of a wide-char string
\param data the string or wide-char string
\param size of the data buffer
  size of the data buffer
\param out_ptr set to an allocated buffer if needed for conversion, shall be destroyed by caller
\return the UTF8 string corresponding

 */
char *gf_utf_get_utf8_string_from_bom(u8 *data, u32 size, char **out_ptr);

/*!
\brief Checks validity of a UTF8 string

@@ -787,16 +787,17 @@ static const char *ctxload_probe_data(const u8 *probe_data, u32 size, GF_FilterP
{
 const char *mime_type = NULL;
 char *dst = NULL;
 u8 *res;


 /* check gzip magic header */
 if ((size>2) && (probe_data[0] == 0x1f) && (probe_data[1] == 0x8b)) {
  *score = GF_FPROBE_EXT_MATCH;
  return ""btz|bt.gz|xmt.gz|xmtz|wrl.gz|x3dv.gz|x3dvz|x3d.gz|x3dz"";
 }

 res = gf_utf_get_utf8_string_from_bom((char *)probe_data, size, &dst);
 if (res) probe_data = res;

 //strip all spaces and \r\n
 while (probe_data[0] && strchr(""\n\r\t "", (char) probe_data[0]))

@@ -3530,11 +3530,10 @@ void txtin_finalize(GF_Filter *filter)
static const char *txtin_probe_data(const u8 *data, u32 data_size, GF_FilterProbeScore *score)
{
 char *dst = NULL;
 u8 *res;

 res = gf_utf_get_utf8_string_from_bom((char *)data, data_size, &dst);
 if (res) data = res;

#define PROBE_OK(_score, _mime) \
  *score = _score;\
  if (dst) gf_free(dst);\

@@ -648,36 +648,47 @@ u32 gf_utf8_mbstowcs(unsigned short* dest, size_t len, const char** srcp)


GF_EXPORT
char *gf_utf_get_utf8_string_from_bom(u8 *data, u32 size, char **out_ptr)
{
 u32 unicode_type = 0;

 *out_ptr = NULL;


 if (size>=5) {
  /*0: no unicode, 1: UTF-16BE, 2: UTF-16LE*/
  if ((data[0]==0xFF) && (data[1]==0xFE)) {
   if (!data[2] && !data[3]) {
    return NULL;
   } else {
    unicode_type = 2;
   }
  } else if ((data[0]==0xFE) && (data[1]==0xFF)) {
   if (!data[2] && !data[3]) {
    return NULL;
   } else {
    unicode_type = 1;
   }
  } else if ((data[0]==0xEF) && (data[1]==0xBB) && (data[2]==0xBF)) {
   return data+4;

  }
 }

 if (!unicode_type) return data;




 if (size%2) size--;
 u16 *str_wc = gf_malloc(size+2);

 u16 *srcwc;
 char *dst = gf_malloc(size+2);




 *out_ptr = dst;
 u32 i;
 for (i=0; i<size; i+=2) {
@@ -704,10 +715,15 @@ char *gf_utf_get_utf8_string_from_bom(u8 *data, u32 size, char **out_ptr)
 }
 str_wc[i/2] = 0;
 srcwc = str_wc;
 gf_utf8_wcstombs(dst, size, (const unsigned short **) &srcwc);
 gf_free(str_wc);

 return dst;





}



","9
include/gpac/utf.h
@@ -84,14 +84,15 @@ u32 gf_utf8_wcslen(const unsigned short *s);
/*!
\brief returns a UTF8 string from a string started with BOM
Returns the length in character of a wide-char string
Returns UTF8 from data
\param data the string or wide-char string
\param size of the data buffer
  size of the data buffer
\param out_ptr set to an allocated buffer if needed for conversion, shall be destroyed by caller
\return the UTF8 string corresponding
\param out_ptr set to an allocated buffer if needed for conversion, shall be destroyed by caller. Must not be NULL
\param result set to resulting UTF8 string. Must not be NULL
\return error if any: GF_IO_ERR if UTF decode error or GF_BAD_PARAM
 */
char *gf_utf_get_utf8_string_from_bom(u8 *data, u32 size, char **out_ptr);
GF_Err gf_utf_get_utf8_string_from_bom(const u8 *data, u32 size, char **out_ptr, char **result);

/*!
\brief Checks validity of a UTF8 string
7
src/filters/load_bt_xmt.c
@@ -787,16 +787,17 @@ static const char *ctxload_probe_data(const u8 *probe_data, u32 size, GF_FilterP
{
 const char *mime_type = NULL;
 char *dst = NULL;
 u8 *res;
 GF_Err e;
 char *res=NULL;

 /* check gzip magic header */
 if ((size>2) && (probe_data[0] == 0x1f) && (probe_data[1] == 0x8b)) {
  *score = GF_FPROBE_EXT_MATCH;
  return ""btz|bt.gz|xmt.gz|xmtz|wrl.gz|x3dv.gz|x3dvz|x3d.gz|x3dz"";
 }

 res = gf_utf_get_utf8_string_from_bom((char *)probe_data, size, &dst);
 if (res) probe_data = res;
 e = gf_utf_get_utf8_string_from_bom(probe_data, size, &dst, &res);
 if (e) return NULL;

 //strip all spaces and \r\n
 while (probe_data[0] && strchr(""\n\r\t "", (char) probe_data[0]))
9
src/filters/load_text.c
@@ -3530,11 +3530,10 @@ void txtin_finalize(GF_Filter *filter)
static const char *txtin_probe_data(const u8 *data, u32 data_size, GF_FilterProbeScore *score)
{
 char *dst = NULL;
 u8 *res;

 res = gf_utf_get_utf8_string_from_bom((char *)data, data_size, &dst);
 if (res) data = res;

 char *res=NULL;
 GF_Err e = gf_utf_get_utf8_string_from_bom((char *)data, data_size, &dst, &res);
 if (e) return NULL;

#define PROBE_OK(_score, _mime) \
  *score = _score;\
  if (dst) gf_free(dst);\
32
src/utils/utf.c
@@ -648,36 +648,47 @@ u32 gf_utf8_mbstowcs(unsigned short* dest, size_t len, const char** srcp)


GF_EXPORT
char *gf_utf_get_utf8_string_from_bom(u8 *data, u32 size, char **out_ptr)
GF_Err gf_utf_get_utf8_string_from_bom(const u8 *data, u32 size, char **out_ptr, char **result)
{
 u32 unicode_type = 0;
 if (!out_ptr || !result || !data) return GF_BAD_PARAM;
 *out_ptr = NULL;
 *result = (char *) data;

 if (size>=5) {
  /*0: no unicode, 1: UTF-16BE, 2: UTF-16LE*/
  if ((data[0]==0xFF) && (data[1]==0xFE)) {
   if (!data[2] && !data[3]) {
    return NULL;
    return GF_OK;
   } else {
    unicode_type = 2;
   }
  } else if ((data[0]==0xFE) && (data[1]==0xFF)) {
   if (!data[2] && !data[3]) {
    return NULL;
    return GF_OK;
   } else {
    unicode_type = 1;
   }
  } else if ((data[0]==0xEF) && (data[1]==0xBB) && (data[2]==0xBF)) {
   return data+4;
   *result = (char *) (data+4);
   return GF_OK;
  }
 }

 if (!unicode_type) return data;
 if (!unicode_type) {
  *result = (char *) data;
  return GF_OK;
 }

 if (size%2) size--;
 u16 *str_wc = gf_malloc(size+2);
 if (!str_wc) return GF_OUT_OF_MEM;
 u16 *srcwc;
 char *dst = gf_malloc(size+2);
 if (!dst) {
  gf_free(str_wc);
  return GF_OUT_OF_MEM;
 }
 *out_ptr = dst;
 u32 i;
 for (i=0; i<size; i+=2) {
@@ -704,10 +715,15 @@ char *gf_utf_get_utf8_string_from_bom(u8 *data, u32 size, char **out_ptr)
 }
 str_wc[i/2] = 0;
 srcwc = str_wc;
 gf_utf8_wcstombs(dst, size, (const unsigned short **) &srcwc);
 u32 res = gf_utf8_wcstombs(dst, size, (const unsigned short **) &srcwc);
 gf_free(str_wc);

 return dst;
 if (res==GF_UTF8_FAIL) {
  gf_free(dst);
  *out_ptr = NULL;
  return GF_IO_ERR;
 }
 *result = dst;
 return GF_OK;
}"
https://huntr.dev/bounties/26179f9a-bbc2-4c17-b70f-211e875c7f4f/,Classic Buffer Overflow in gpac/gpac,Buffer Overflow in gpac,,CWE-120: Classic Buffer Overflow,https://www.github.com/gpac/gpac/commit/94cf5b14e7c846d3a0f6beb9d7a1bb87e586a280,"@@ -120,6 +120,10 @@ GF_Err gf_sg_script_get_field_index(GF_Node *node, u32 inField, u8 IndexMode, u3
  }
 }
 /*try with default*/




 return gf_sg_mpeg4_node_get_field_index(node, inField, IndexMode, allField);
}


","7
src/scenegraph/mpeg4_nodes.c
@@ -12780,8 +12780,6 @@ static const u16 Script_Def2All[] = { 0, 1, 2};
static const u16 Script_In2All[] = { 0};
static const u16 Script_Out2All[] = { 0};

//unused
#if 0
static u32 Script_get_field_count(GF_Node *node, u8 IndexMode)
{
 switch(IndexMode) {
@@ -12797,7 +12795,7 @@ static u32 Script_get_field_count(GF_Node *node, u8 IndexMode)
  return 3;
 }
}
#endif

static GF_Err Script_get_field_index(GF_Node *n, u32 inField, u8 IndexMode, u32 *allField)
{
 switch(IndexMode) {
@@ -38264,11 +38262,8 @@ u32 gf_sg_mpeg4_node_get_field_count(GF_Node *node, u8 code_mode)
  return Rectangle_get_field_count(node, code_mode);
 case TAG_MPEG4_ScalarInterpolator:
  return ScalarInterpolator_get_field_count(node, code_mode);
//unused
#if 0
 case TAG_MPEG4_Script:
  return Script_get_field_count(node, code_mode);
#endif
 case TAG_MPEG4_Shape:
  return Shape_get_field_count(node, code_mode);
 case TAG_MPEG4_Sound:
4
src/scenegraph/vrml_script.c
@@ -120,6 +120,10 @@ GF_Err gf_sg_script_get_field_index(GF_Node *node, u32 inField, u8 IndexMode, u3
  }
 }
 /*try with default*/

 if (gf_sg_mpeg4_node_get_field_count(node, IndexMode)>=inField)
  return GF_NON_COMPLIANT_BITSTREAM;

 return gf_sg_mpeg4_node_get_field_index(node, inField, IndexMode, allField);
}"
https://huntr.dev/bounties/6e13073e-ab19-47e4-873b-52e9365afab2/,Use After Free in gpac/gpac,Use After Free in gpac,,CWE-416: Use After Free,https://www.github.com/gpac/gpac/commit/20bf89461a690df89b0f3b6dbd2ae24d9c1c53d8,"@@ -292,6 +292,7 @@ GF_Err Q_DecCoordOnUnitSphere(GF_BifsDecoder *codec, GF_BitStream *bs, u32 NbBit
 if(NbComp == 2) dir -= 2 * gf_bs_read_int(bs, 1);

 orient = gf_bs_read_int(bs, 2);


 for(i=0; i<NbComp; i++) {
  value = gf_bs_read_int(bs, NbBits) - (1 << (NbBits-1) );
@@ -341,7 +342,7 @@ GF_Err Q_DecRotation(GF_BifsDecoder *codec, GF_BitStream *bs, u32 NbBits, void *
//parses a Normal vec
GF_Err Q_DecNormal(GF_BifsDecoder *codec, GF_BitStream *bs, u32 NbBits, void *field_ptr)
{
 Fixed comp[3];
 SFVec3f v;
 GF_Err e;
 e = Q_DecCoordOnUnitSphere(codec, bs, NbBits, 2, comp);

","3
src/bifs/unquantize.c
@@ -292,6 +292,7 @@ GF_Err Q_DecCoordOnUnitSphere(GF_BifsDecoder *codec, GF_BitStream *bs, u32 NbBit
 if(NbComp == 2) dir -= 2 * gf_bs_read_int(bs, 1);

 orient = gf_bs_read_int(bs, 2);
 if ((orient==3) && (NbComp==2)) return GF_NON_COMPLIANT_BITSTREAM;

 for(i=0; i<NbComp; i++) {
  value = gf_bs_read_int(bs, NbBits) - (1 << (NbBits-1) );
@@ -341,7 +342,7 @@ GF_Err Q_DecRotation(GF_BifsDecoder *codec, GF_BitStream *bs, u32 NbBits, void *
//parses a Normal vec
GF_Err Q_DecNormal(GF_BifsDecoder *codec, GF_BitStream *bs, u32 NbBits, void *field_ptr)
{
 Fixed comp[3];
 Fixed comp[4];
 SFVec3f v;
 GF_Err e;
 e = Q_DecCoordOnUnitSphere(codec, bs, NbBits, 2, comp);"
https://huntr.dev/bounties/1d9bf402-f756-4583-9a1d-436722609c1e/,Stack-based Buffer Overflow in gpac/gpac,Stack-based Buffer Overflow in gpac,,CWE-121: Stack-based Buffer Overflow,https://www.github.com/gpac/gpac/commit/b13e9986aa1134c764b0d84f0f66328429b9c2eb,"@@ -936,7 +936,12 @@ GF_Err gf_bifs_flush_command_list(GF_BifsDecoder *codec)
 GF_Err e;
 CommandBufferItem *cbi;
 GF_SceneGraph *prev_root = codec->current_graph;


 u32 NbPass = gf_list_count(codec->command_buffers);



 GF_List *nextPass = gf_list_new();
 while (NbPass) {
  while (gf_list_count(codec->command_buffers)) {
@@ -987,10 +992,17 @@ GF_Err gf_bifs_flush_command_list(GF_BifsDecoder *codec)
  }
  NbPass --;
  if (NbPass > gf_list_count(codec->command_buffers)) NbPass = gf_list_count(codec->command_buffers);






  codec->LastError = GF_OK;
 }
 gf_list_del(nextPass);
 codec->current_graph = prev_root;

 return GF_OK;
}


","12
src/bifs/memory_decoder.c
@@ -936,7 +936,12 @@ GF_Err gf_bifs_flush_command_list(GF_BifsDecoder *codec)
 GF_Err e;
 CommandBufferItem *cbi;
 GF_SceneGraph *prev_root = codec->current_graph;
 M_QuantizationParameter *prev_qp = codec->ActiveQP;
 u32 prev_qp_count = gf_list_count(codec->QPs);
 u32 NbPass = gf_list_count(codec->command_buffers);


 codec->ActiveQP = NULL;
 GF_List *nextPass = gf_list_new();
 while (NbPass) {
  while (gf_list_count(codec->command_buffers)) {
@@ -987,10 +992,17 @@ GF_Err gf_bifs_flush_command_list(GF_BifsDecoder *codec)
  }
  NbPass --;
  if (NbPass > gf_list_count(codec->command_buffers)) NbPass = gf_list_count(codec->command_buffers);

  //restore QP state
  while (gf_list_count(codec->QPs) > prev_qp_count) {
   gf_list_rem(codec->QPs, 0); //QPs are inserted at head of list
  }
  codec->ActiveQP = NULL;
  codec->LastError = GF_OK;
 }
 gf_list_del(nextPass);
 codec->current_graph = prev_root;
 codec->ActiveQP = prev_qp;
 return GF_OK;
}"
https://huntr.dev/bounties/c39b9a85-10b6-42ba-9cf7-bd7cc1207896/,Heap-based Buffer Overflow in gpac/gpac,Heap-based Buffer Overflow in gpac,,CWE-122: Heap-based Buffer Overflow,https://www.github.com/gpac/gpac/commit/b13e9986aa1134c764b0d84f0f66328429b9c2eb,"@@ -936,7 +936,12 @@ GF_Err gf_bifs_flush_command_list(GF_BifsDecoder *codec)
 GF_Err e;
 CommandBufferItem *cbi;
 GF_SceneGraph *prev_root = codec->current_graph;


 u32 NbPass = gf_list_count(codec->command_buffers);



 GF_List *nextPass = gf_list_new();
 while (NbPass) {
  while (gf_list_count(codec->command_buffers)) {
@@ -987,10 +992,17 @@ GF_Err gf_bifs_flush_command_list(GF_BifsDecoder *codec)
  }
  NbPass --;
  if (NbPass > gf_list_count(codec->command_buffers)) NbPass = gf_list_count(codec->command_buffers);






  codec->LastError = GF_OK;
 }
 gf_list_del(nextPass);
 codec->current_graph = prev_root;

 return GF_OK;
}


","12
src/bifs/memory_decoder.c
@@ -936,7 +936,12 @@ GF_Err gf_bifs_flush_command_list(GF_BifsDecoder *codec)
 GF_Err e;
 CommandBufferItem *cbi;
 GF_SceneGraph *prev_root = codec->current_graph;
 M_QuantizationParameter *prev_qp = codec->ActiveQP;
 u32 prev_qp_count = gf_list_count(codec->QPs);
 u32 NbPass = gf_list_count(codec->command_buffers);


 codec->ActiveQP = NULL;
 GF_List *nextPass = gf_list_new();
 while (NbPass) {
  while (gf_list_count(codec->command_buffers)) {
@@ -987,10 +992,17 @@ GF_Err gf_bifs_flush_command_list(GF_BifsDecoder *codec)
  }
  NbPass --;
  if (NbPass > gf_list_count(codec->command_buffers)) NbPass = gf_list_count(codec->command_buffers);

  //restore QP state
  while (gf_list_count(codec->QPs) > prev_qp_count) {
   gf_list_rem(codec->QPs, 0); //QPs are inserted at head of list
  }
  codec->ActiveQP = NULL;
  codec->LastError = GF_OK;
 }
 gf_list_del(nextPass);
 codec->current_graph = prev_root;
 codec->ActiveQP = prev_qp;
 return GF_OK;
}"
https://huntr.dev/bounties/795dcbd9-1695-44bb-8c59-ad327c97c976/,NULL Pointer Dereference in mruby/mruby,There is a NULL Pointer Dereference in iv_free (src/variable.c:232:20). This bug has been found on mruby lastest commit (hash 31fa3304049fc406a201a72293cce140f0557dca) on Ubuntu 20.04 for x86_64/amd64.,CVE-2022-0326,CWE-476: NULL Pointer Dereference,https://www.github.com/mruby/mruby/commit/b611c43a5de061ec21b343967e1b64c45c373d7e,"@@ -1644,14 +1644,13 @@ gen_hash(codegen_scope *s, node *tree, int val, int limit)
    }
  }
  if (update) {
    if (len > 0) {
      pop_n(len*2+1);
      genop_2(s, OP_HASHADD, cursp(), len);
      push();
    }
    return -1;                  /* variable length */
  }
  if (update) return -1;
  return len;
}


","3
mrbgems/mruby-compiler/core/codegen.c
@@ -1644,14 +1644,13 @@ gen_hash(codegen_scope *s, node *tree, int val, int limit)
    }
  }
  if (update) {
    if (len > 0) {
    if (val && len > 0) {
      pop_n(len*2+1);
      genop_2(s, OP_HASHADD, cursp(), len);
      push();
    }
    return -1;                  /* variable length */
  }
  if (update) return -1;
  return len;
}"
https://huntr.dev/bounties/1691cca3-ab54-4259-856b-751be2395b11/,Heap-based Buffer Overflow in gpac/gpac,Heap-based Buffer Overflow SFS_AddString () at bifs/script_dec.c:76,,CWE-122: Heap-based Buffer Overflow,https://www.github.com/gpac/gpac/commit/b5741da08e88e8dcc8da0a7669b92405b9862850,"@@ -72,13 +72,13 @@ static void SFS_AddString(ScriptParser *parser, char *str)
 char *new_str;
 if (!str) return;
 if (strlen(parser->string) + strlen(str) >= parser->length) {
  parser->length += PARSER_STEP_ALLOC;
  new_str = (char *)gf_malloc(sizeof(char)*parser->length);
  strcpy(new_str, parser->string);
  gf_free(parser->string);
  parser->string = new_str;
 }
 strcat(parser->string, str);
}

static void SFS_AddInt(ScriptParser *parser, s32 val)

","4
src/bifs/script_dec.c
@@ -72,13 +72,13 @@ static void SFS_AddString(ScriptParser *parser, char *str)
 char *new_str;
 if (!str) return;
 if (strlen(parser->string) + strlen(str) >= parser->length) {
  parser->length += PARSER_STEP_ALLOC;
  parser->length = strlen(parser->string) + strlen(str) + PARSER_STEP_ALLOC;
  new_str = (char *)gf_malloc(sizeof(char)*parser->length);
  strcpy(new_str, parser->string);
  gf_free(parser->string);
  parser->string = new_str;
 }
 strcat(parser->string, str);
 strncat(parser->string, str, parser->length - strlen(parser->string) - 1);
}

static void SFS_AddInt(ScriptParser *parser, s32 val)"
https://huntr.dev/bounties/0758b3a2-8ff2-45fc-8543-7633d605d24e/,NULL Pointer Dereference in gpac/gpac,Null Pointer Dereference in gf_utf8_wcslen (),,CWE-476: NULL Pointer Dereference,https://www.github.com/gpac/gpac/commit/586e817dcd531bb3e75438390f1f753cfe6e940a,"@@ -2835,7 +2835,17 @@ GF_Err iods_box_read(GF_Box *s, GF_BitStream *bs)
 e = gf_odf_desc_read(desc, descSize, &ptr->descriptor);
 //OK, free our desc
 gf_free(desc);
 return e;










}

GF_Box *iods_box_new()
@@ -5080,6 +5090,32 @@ GF_Err stbl_box_read(GF_Box *s, GF_BitStream *bs)
  if (!ptr->TimeToSample->nb_entries || !ptr->SampleToChunk->nb_entries)
   return GF_ISOM_INVALID_FILE;
 }


























 return GF_OK;
}


@@ -2822,6 +2822,7 @@ GF_Err gf_isom_remove_track(GF_ISOFile *movie, u32 trackNumber)
 i=0;
 while ((trak = (GF_TrackBox *)gf_list_enum(movie->moov->trackList, &i))) {
  if (trak->Media->handler->handlerType != GF_ISOM_MEDIA_OD) continue;

  //this is an OD track...
  j = gf_isom_get_sample_count(movie, i);
  for (k=0; k < j; k++) {
@@ -2845,7 +2846,6 @@ GF_Err gf_isom_remove_track(GF_ISOFile *movie, u32 trackNumber)
 //note that we don't touch scal references, as we don't want to rewrite AVC/HEVC samples ...
 i=0;
 while ((trak = (GF_TrackBox *)gf_list_enum(movie->moov->trackList, &i))) {
  if (trak == the_trak) continue;
  if (! trak->References || ! gf_list_count(trak->References->child_boxes)) continue;

  j=0;

","38
src/isomedia/box_code_base.c
@@ -2835,7 +2835,17 @@ GF_Err iods_box_read(GF_Box *s, GF_BitStream *bs)
 e = gf_odf_desc_read(desc, descSize, &ptr->descriptor);
 //OK, free our desc
 gf_free(desc);
 return e;

 if (e) return e;
 switch (ptr->descriptor->tag) {
 case GF_ODF_ISOM_OD_TAG:
 case GF_ODF_ISOM_IOD_TAG:
  break;
 default:
  GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Invalid descriptor in iods, tag %u found but only %u or %u allowed\n"", ptr->descriptor->tag, GF_ODF_ISOM_IOD_TAG, GF_ODF_ISOM_OD_TAG ));
  return GF_ISOM_INVALID_FILE;
 }
 return GF_OK;
}

GF_Box *iods_box_new()
@@ -5080,6 +5090,32 @@ GF_Err stbl_box_read(GF_Box *s, GF_BitStream *bs)
  if (!ptr->TimeToSample->nb_entries || !ptr->SampleToChunk->nb_entries)
   return GF_ISOM_INVALID_FILE;
 }
 u32 i, max_chunks=0;
 if (ptr->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {
  max_chunks = ((GF_ChunkOffsetBox *)ptr->ChunkOffset)->nb_entries;
 }
 else if (ptr->ChunkOffset->type == GF_ISOM_BOX_TYPE_CO64) {
  max_chunks = ((GF_ChunkOffsetBox *)ptr->ChunkOffset)->nb_entries;
 }

 //sanity check on stsc vs chunk offset tables
 for (i=0; i<ptr->SampleToChunk->nb_entries; i++) {
  GF_StscEntry *ent = &ptr->SampleToChunk->entries[i];
  if (!i && (ent->firstChunk!=1)) {
   GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] first_chunk of first entry shall be 1 but is %u\n"", ent->firstChunk));
   return GF_ISOM_INVALID_FILE;
  }
  if (ptr->SampleToChunk->entries[i].firstChunk > max_chunks) {
   GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] first_chunk is %u but number of chunks defined %u\n"", ptr->SampleToChunk->entries[i].firstChunk, max_chunks));
   return GF_ISOM_INVALID_FILE;
  }
  if (i+1 == ptr->SampleToChunk->nb_entries) break;
  GF_StscEntry *next_ent = &ptr->SampleToChunk->entries[i+1];
  if (next_ent->firstChunk < ent->firstChunk) {
   GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] first_chunk (%u) for entry %u is greater than first_chunk (%u) for entry %u\n"", i+1, ent->firstChunk, i+2, next_ent->firstChunk));
   return GF_ISOM_INVALID_FILE;
  }
 }
 return GF_OK;
}

2
src/isomedia/isom_write.c
@@ -2822,6 +2822,7 @@ GF_Err gf_isom_remove_track(GF_ISOFile *movie, u32 trackNumber)
 i=0;
 while ((trak = (GF_TrackBox *)gf_list_enum(movie->moov->trackList, &i))) {
  if (trak->Media->handler->handlerType != GF_ISOM_MEDIA_OD) continue;

  //this is an OD track...
  j = gf_isom_get_sample_count(movie, i);
  for (k=0; k < j; k++) {
@@ -2845,7 +2846,6 @@ GF_Err gf_isom_remove_track(GF_ISOFile *movie, u32 trackNumber)
 //note that we don't touch scal references, as we don't want to rewrite AVC/HEVC samples ...
 i=0;
 while ((trak = (GF_TrackBox *)gf_list_enum(movie->moov->trackList, &i))) {
  if (trak == the_trak) continue;
  if (! trak->References || ! gf_list_count(trak->References->child_boxes)) continue;

  j=0;"
https://huntr.dev/bounties/e055098a-5909-4bec-8b7f-ab0dbb703dbf/,NULL Pointer Dereference in gpac/gpac,A null pointer dereference was discovered in BD_CheckSFTimeOffset(). The vulnerability causes a segmentation fault and application crash.,,CWE-476: NULL Pointer Dereference,https://www.github.com/gpac/gpac/commit/b0de1a06c95f81bfb392cdf290b638d0e303d661,"@@ -296,6 +296,7 @@ GF_Err BD_DecMFFieldList(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node
 sffield.fieldIndex = field->fieldIndex;
 sffield.fieldType = gf_sg_vrml_get_sf_type(field->fieldType);
 sffield.NDTtype = field->NDTtype;


 nbF = 0;
 qp_on = qp_local = 0;
@@ -385,6 +386,7 @@ GF_Err BD_DecMFFieldVec(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node,
 sffield.fieldIndex = field->fieldIndex;
 sffield.fieldType = gf_sg_vrml_get_sf_type(field->fieldType);
 sffield.NDTtype = field->NDTtype;


 initial_qp = qp_local = qp_on = 0;


","2
src/bifs/field_decode.c
@@ -296,6 +296,7 @@ GF_Err BD_DecMFFieldList(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node
 sffield.fieldIndex = field->fieldIndex;
 sffield.fieldType = gf_sg_vrml_get_sf_type(field->fieldType);
 sffield.NDTtype = field->NDTtype;
 sffield.name = field->name;

 nbF = 0;
 qp_on = qp_local = 0;
@@ -385,6 +386,7 @@ GF_Err BD_DecMFFieldVec(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node,
 sffield.fieldIndex = field->fieldIndex;
 sffield.fieldType = gf_sg_vrml_get_sf_type(field->fieldType);
 sffield.NDTtype = field->NDTtype;
 sffield.name = field->name;

 initial_qp = qp_local = qp_on = 0;"
https://huntr.dev/bounties/5857eced-aad9-417d-864e-0bdf17226cbb/,NULL Pointer Dereference in mruby/mruby,There is a NULL Pointer Dereference in prepare_singleton_class (src/class.c:360:13). This bug has been found on mruby lastest commit (hash 171d32c0071d776207174a40a8fa26def3dbb931) on Ubuntu 20.04 for x86_64/amd64.,CVE-2022-0240,CWE-476: NULL Pointer Dereference,https://www.github.com/mruby/mruby/commit/31fa3304049fc406a201a72293cce140f0557dca,"@@ -357,6 +357,7 @@ prepare_singleton_class(mrb_state *mrb, struct RBasic *o)
{
  struct RClass *sc, *c;


  if (o->c->tt == MRB_TT_SCLASS) return;
  sc = MRB_OBJ_ALLOC(mrb, MRB_TT_SCLASS, mrb->class_class);
  sc->flags |= MRB_FL_CLASS_IS_INHERITED;
@@ -1682,6 +1683,7 @@ mrb_singleton_class_ptr(mrb_state *mrb, mrb_value v)
    break;
  }
  obj = mrb_basic_ptr(v);

  prepare_singleton_class(mrb, obj);
  return obj->c;
}

","2
src/class.c
@@ -357,6 +357,7 @@ prepare_singleton_class(mrb_state *mrb, struct RBasic *o)
{
  struct RClass *sc, *c;

  mrb_assert(o->c);
  if (o->c->tt == MRB_TT_SCLASS) return;
  sc = MRB_OBJ_ALLOC(mrb, MRB_TT_SCLASS, mrb->class_class);
  sc->flags |= MRB_FL_CLASS_IS_INHERITED;
@@ -1682,6 +1683,7 @@ mrb_singleton_class_ptr(mrb_state *mrb, mrb_value v)
    break;
  }
  obj = mrb_basic_ptr(v);
  if (obj->c == NULL) return NULL;
  prepare_singleton_class(mrb, obj);
  return obj->c;
}"
https://huntr.dev/bounties/727d8600-88bc-4dde-8dea-ee3d192600e5/,Out-of-bounds Read in radareorg/radare2,"This vulnerability is of out-of-bound read. The bug exists in latest stable release (radare2-5.5.4). Specifically, the vulnerable code is picked out as follows:",CVE-2022-0173,CWE-125: Out-of-bounds Read,https://www.github.com/radareorg/radare2/commit/37897226a1a31f982bfefdc4aeefc2e50355c73c,"@@ -230,7 +230,10 @@ R_API bool r_io_bank_map_add_top(RIO *io, const ut32 bankid, const ut32 mapid) {
  //delete all submaps that are completly included in sm
  RRBNode *next = r_rbnode_next (entry);
  // this can be optimized, there is no need to do search here
  r_crbtree_delete (bank->submaps, entry->data, _find_sm_by_from_vaddr_cb, NULL);



  entry = next;
 }
 if (entry && r_io_submap_from (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {

","5
libr/io/io_bank.c
@@ -230,7 +230,10 @@ R_API bool r_io_bank_map_add_top(RIO *io, const ut32 bankid, const ut32 mapid) {
  //delete all submaps that are completly included in sm
  RRBNode *next = r_rbnode_next (entry);
  // this can be optimized, there is no need to do search here
  r_crbtree_delete (bank->submaps, entry->data, _find_sm_by_from_vaddr_cb, NULL);
  bool a = r_crbtree_delete (bank->submaps, entry->data, _find_sm_by_from_vaddr_cb, NULL);
  if (!a) {
   break;
  }
  entry = next;
 }
 if (entry && r_io_submap_from (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {"
https://huntr.dev/bounties/c21406f6-e4f9-4307-9d88-1053244c7687/,Heap-based Buffer Overflow in neomutt/neomutt,"When connected through imap/imaps with a server, neomutt is prone to a heap buffer overflow when using the auto completion feature.",,CWE-122: Heap-based Buffer Overflow,https://www.github.com/neomutt/neomutt/commit/fd84fbfcb7fd22fead839d5b4e8dbddc04b47865,"@@ -1350,7 +1350,7 @@ int imap_complete(char *buf, size_t buflen, const char *path)
  char tmp[2048];
  struct ImapList listresp = { 0 };
  char completion[1024];
  int clen;
  size_t matchlen = 0;
  int completions = 0;
  int rc;

","2
imap/imap.c
@@ -1350,7 +1350,7 @@ int imap_complete(char *buf, size_t buflen, const char *path)
  char tmp[2048];
  struct ImapList listresp = { 0 };
  char completion[1024];
  int clen;
  size_t clen;
  size_t matchlen = 0;
  int completions = 0;
  int rc;"
https://huntr.dev/bounties/59a70392-4864-4ce3-8e35-6ac2111d1e2e/,Heap-based Buffer Overflow in mruby/mruby,Heap Base Buffer Overflow mrb_irep_cutref,CVE-2022-0080,CWE-122: Heap-based Buffer Overflow,https://www.github.com/mruby/mruby/commit/28ccc664e5dcd3f9d55173e9afde77c4705a9ab6,"@@ -207,12 +207,12 @@ mrb_proc_copy(mrb_state *mrb, struct RProc *a, struct RProc *b)
    /* already initialized proc */
    return;
  }



  a->flags = b->flags;
  a->body = b->body;
  a->upper = b->upper;
  if (!MRB_PROC_CFUNC_P(a) && a->body.irep) {
    mrb_irep_incref(mrb, (mrb_irep*)a->body.irep);
  }
  a->e.env = b->e.env;
  /* a->e.target_class = a->e.target_class; */
}

","6
src/proc.c
@@ -207,12 +207,12 @@ mrb_proc_copy(mrb_state *mrb, struct RProc *a, struct RProc *b)
    /* already initialized proc */
    return;
  }
  if (!MRB_PROC_CFUNC_P(b) && b->body.irep) {
    mrb_irep_incref(mrb, (mrb_irep*)b->body.irep);
  }
  a->flags = b->flags;
  a->body = b->body;
  a->upper = b->upper;
  if (!MRB_PROC_CFUNC_P(a) && a->body.irep) {
    mrb_irep_incref(mrb, (mrb_irep*)a->body.irep);
  }
  a->e.env = b->e.env;
  /* a->e.target_class = a->e.target_class; */
}"
https://huntr.dev/bounties/78533fb9-f3e0-47c2-86dc-d1f96d5bea28/,NULL Pointer Dereference in mruby/mruby,A NULL Pointer Dereference was discovered in mrb_class(). The vulnerability causes a segmentation fault and application crash.,CVE-2021-4188,CWE-476: NULL Pointer Dereference,https://www.github.com/mruby/mruby/commit/27d1e0132a0804581dca28df042e7047fd27eaa8,"@@ -581,14 +581,16 @@ mrb_ary_shift(mrb_state *mrb, mrb_value self)
static mrb_value
mrb_ary_shift_m(mrb_state *mrb, mrb_value self)
{
  struct RArray *a = mrb_ary_ptr(self);
  mrb_int len = ARY_LEN(a);
  mrb_int n;
  mrb_value val;

  if (mrb_get_args(mrb, ""|i"", &n) == 0) {
    return mrb_ary_shift(mrb, self);
  };





  ary_modify_check(mrb, a);
  if (len == 0 || n == 0) return mrb_ary_new(mrb);
  if (n < 0) mrb_raise(mrb, E_ARGUMENT_ERROR, ""negative array shift"");

","10
src/array.c
@@ -581,14 +581,16 @@ mrb_ary_shift(mrb_state *mrb, mrb_value self)
static mrb_value
mrb_ary_shift_m(mrb_state *mrb, mrb_value self)
{
  struct RArray *a = mrb_ary_ptr(self);
  mrb_int len = ARY_LEN(a);
  mrb_int n;
  mrb_value val;

  if (mrb_get_args(mrb, ""|i"", &n) == 0) {
    return mrb_ary_shift(mrb, self);
  };
  }

  struct RArray *a = mrb_ary_ptr(self);
  mrb_int len = ARY_LEN(a);
  mrb_value val;

  ary_modify_check(mrb, a);
  if (len == 0 || n == 0) return mrb_ary_new(mrb);
  if (n < 0) mrb_raise(mrb, E_ARGUMENT_ERROR, ""negative array shift"");"
https://huntr.dev/bounties/de68550e-8b81-4f7a-89c9-5356efa268e5/,Heap-based Buffer Overflow in allinurl/goaccess,"Good evening and Happy Turkey Day! We are truly thankful for the Open Source Security community this year. Whilst testing goaccess built from commit 9774249, we discovered a crafted log which can trigger a heap-buffer-overflow during a memcmp operation on line 1525 of /src/parser.c",,CWE-122: Heap-based Buffer Overflow,https://www.github.com/allinurl/goaccess/commit/ec853386b06a2d99dabce906601f7316652347c5,"@@ -1521,11 +1521,13 @@ ignore_static (const char *req) {
 * If the request is a 404, 1 is returned. */
static int
is_404 (GLogItem * logitem) {


  /* is this a 404? */
  if (logitem->status && !memcmp (logitem->status, ""404"", 3))
    return 1;
  /* treat 444 as 404? */
  else if (logitem->status && !memcmp (logitem->status, ""444"", 3) && conf.code444_as_404)
    return 1;
  return 0;
}

","6
src/parser.c
@@ -1521,11 +1521,13 @@ ignore_static (const char *req) {
 * If the request is a 404, 1 is returned. */
static int
is_404 (GLogItem * logitem) {
  if (!logitem->status || *logitem->status == '\0')
    return 0;
  /* is this a 404? */
  if (logitem->status && !memcmp (logitem->status, ""404"", 3))
  if (!memcmp (logitem->status, ""404"", 3))
    return 1;
  /* treat 444 as 404? */
  else if (logitem->status && !memcmp (logitem->status, ""444"", 3) && conf.code444_as_404)
  else if (!memcmp (logitem->status, ""444"", 3) && conf.code444_as_404)
    return 1;
  return 0;
}"
https://huntr.dev/bounties/a6ca142e-60aa-4d6f-b231-5d1bcd1b7190/,Cross-site Scripting (XSS) - Stored in meetecho/janus-gateway,The stored XSS vulnerability occurs in the chat window because the user's input value is inserted into the web page without verification.,CVE-2021-4124,CWE-79: Cross-site Scripting (XSS) - Stored,https://www.github.com/meetecho/janus-gateway/commit/f62bba6513ec840761f2434b93168106c7c65a3d,"@@ -351,7 +351,7 @@ function sendPrivateMsg(username) {
    text: JSON.stringify(message),
    error: function(reason) { bootbox.alert(reason); },
    success: function() {
     $('#chatroom').append('<p style=""color: purple;"">[' + getDateString() + '] <b>[whisper to ' + display + ']</b> ' + result);
     $('#chatroom').get(0).scrollTop = $('#chatroom').get(0).scrollHeight;
    }
   });

","2
html/textroomtest.js
@@ -351,7 +351,7 @@ function sendPrivateMsg(username) {
    text: JSON.stringify(message),
    error: function(reason) { bootbox.alert(reason); },
    success: function() {
     $('#chatroom').append('<p style=""color: purple;"">[' + getDateString() + '] <b>[whisper to ' + display + ']</b> ' + result);
     $('#chatroom').append('<p style=""color: purple;"">[' + getDateString() + '] <b>[whisper to ' + display + ']</b> ' + escapeXmlTags(result));
     $('#chatroom').get(0).scrollTop = $('#chatroom').get(0).scrollHeight;
    }
   });"
https://huntr.dev/bounties/4ce5dc47-2512-4c87-8609-453adc8cad20/,NULL Pointer Dereference in mruby/mruby,NULL Pointer Dereference in mrb_full_gc,CVE-2021-4110,CWE-476: NULL Pointer Dereference,https://www.github.com/mruby/mruby/commit/f5e10c5a79a17939af763b1dcf5232ce47e24a34,"@@ -92,7 +92,7 @@ struct RProc *mrb_proc_new(mrb_state*, const mrb_irep*);
struct RProc *mrb_closure_new(mrb_state*, const mrb_irep*);
MRB_API struct RProc *mrb_proc_new_cfunc(mrb_state*, mrb_func_t);
MRB_API struct RProc *mrb_closure_new_cfunc(mrb_state *mrb, mrb_func_t func, int nlocals);
void mrb_proc_copy(struct RProc *a, struct RProc *b);
mrb_int mrb_proc_arity(const struct RProc *p);

/* following functions are defined in mruby-proc-ext so please include it when using */

@@ -2569,7 +2569,7 @@ mrb_mod_define_method_m(mrb_state *mrb, struct RClass *c)
    mrb_raise(mrb, E_ARGUMENT_ERROR, ""no block given"");
  }
  p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb->proc_class);
  mrb_proc_copy(p, mrb_proc_ptr(blk));
  p->flags |= MRB_PROC_STRICT;
  MRB_METHOD_FROM_PROC(m, p);
  mrb_define_method_raw(mrb, c, mid, m);

@@ -201,18 +201,18 @@ mrb_proc_cfunc_env_get(mrb_state *mrb, mrb_int idx)
}

void
mrb_proc_copy(struct RProc *a, struct RProc *b)
{
  if (a->body.irep) {
    /* already initialized proc */
    return;
  }
  a->flags = b->flags;
  a->body = b->body;

  if (!MRB_PROC_CFUNC_P(a) && a->body.irep) {
    mrb_irep_incref(NULL, (mrb_irep*)a->body.irep);
  }
  a->upper = b->upper;
  a->e.env = b->e.env;
  /* a->e.target_class = a->e.target_class; */
}
@@ -227,7 +227,7 @@ mrb_proc_s_new(mrb_state *mrb, mrb_value proc_class)
  /* Calling Proc.new without a block is not implemented yet */
  mrb_get_args(mrb, ""&!"", &blk);
  p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb_class_ptr(proc_class));
  mrb_proc_copy(p, mrb_proc_ptr(blk));
  proc = mrb_obj_value(p);
  mrb_funcall_with_block(mrb, proc, MRB_SYM(initialize), 0, NULL, proc);
  if (!MRB_PROC_STRICT_P(p) &&
@@ -245,7 +245,7 @@ mrb_proc_init_copy(mrb_state *mrb, mrb_value self)
  if (!mrb_proc_p(proc)) {
    mrb_raise(mrb, E_ARGUMENT_ERROR, ""not a proc"");
  }
  mrb_proc_copy(mrb_proc_ptr(self), mrb_proc_ptr(proc));
  return self;
}

@@ -281,7 +281,7 @@ proc_lambda(mrb_state *mrb, mrb_value self)
  p = mrb_proc_ptr(blk);
  if (!MRB_PROC_STRICT_P(p)) {
    struct RProc *p2 = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, p->c);
    mrb_proc_copy(p2, p);
    p2->flags |= MRB_PROC_STRICT;
    return mrb_obj_value(p2);
  }

","2
include/mruby/proc.h
@@ -92,7 +92,7 @@ struct RProc *mrb_proc_new(mrb_state*, const mrb_irep*);
struct RProc *mrb_closure_new(mrb_state*, const mrb_irep*);
MRB_API struct RProc *mrb_proc_new_cfunc(mrb_state*, mrb_func_t);
MRB_API struct RProc *mrb_closure_new_cfunc(mrb_state *mrb, mrb_func_t func, int nlocals);
void mrb_proc_copy(struct RProc *a, struct RProc *b);
void mrb_proc_copy(mrb_state *mrb, struct RProc *a, struct RProc *b);
mrb_int mrb_proc_arity(const struct RProc *p);

/* following functions are defined in mruby-proc-ext so please include it when using */
2
src/class.c
@@ -2569,7 +2569,7 @@ mrb_mod_define_method_m(mrb_state *mrb, struct RClass *c)
    mrb_raise(mrb, E_ARGUMENT_ERROR, ""no block given"");
  }
  p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb->proc_class);
  mrb_proc_copy(p, mrb_proc_ptr(blk));
  mrb_proc_copy(mrb, p, mrb_proc_ptr(blk));
  p->flags |= MRB_PROC_STRICT;
  MRB_METHOD_FROM_PROC(m, p);
  mrb_define_method_raw(mrb, c, mid, m);
12
src/proc.c
@@ -201,18 +201,18 @@ mrb_proc_cfunc_env_get(mrb_state *mrb, mrb_int idx)
}

void
mrb_proc_copy(struct RProc *a, struct RProc *b)
mrb_proc_copy(mrb_state *mrb, struct RProc *a, struct RProc *b)
{
  if (a->body.irep) {
    /* already initialized proc */
    return;
  }
  a->flags = b->flags;
  a->body = b->body;
  a->upper = b->upper;
  if (!MRB_PROC_CFUNC_P(a) && a->body.irep) {
    mrb_irep_incref(NULL, (mrb_irep*)a->body.irep);
    mrb_irep_incref(mrb, (mrb_irep*)a->body.irep);
  }
  a->upper = b->upper;
  a->e.env = b->e.env;
  /* a->e.target_class = a->e.target_class; */
}
@@ -227,7 +227,7 @@ mrb_proc_s_new(mrb_state *mrb, mrb_value proc_class)
  /* Calling Proc.new without a block is not implemented yet */
  mrb_get_args(mrb, ""&!"", &blk);
  p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb_class_ptr(proc_class));
  mrb_proc_copy(p, mrb_proc_ptr(blk));
  mrb_proc_copy(mrb, p, mrb_proc_ptr(blk));
  proc = mrb_obj_value(p);
  mrb_funcall_with_block(mrb, proc, MRB_SYM(initialize), 0, NULL, proc);
  if (!MRB_PROC_STRICT_P(p) &&
@@ -245,7 +245,7 @@ mrb_proc_init_copy(mrb_state *mrb, mrb_value self)
  if (!mrb_proc_p(proc)) {
    mrb_raise(mrb, E_ARGUMENT_ERROR, ""not a proc"");
  }
  mrb_proc_copy(mrb_proc_ptr(self), mrb_proc_ptr(proc));
  mrb_proc_copy(mrb, mrb_proc_ptr(self), mrb_proc_ptr(proc));
  return self;
}

@@ -281,7 +281,7 @@ proc_lambda(mrb_state *mrb, mrb_value self)
  p = mrb_proc_ptr(blk);
  if (!MRB_PROC_STRICT_P(p)) {
    struct RProc *p2 = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, p->c);
    mrb_proc_copy(p2, p);
    mrb_proc_copy(mrb, p2, p);
    p2->flags |= MRB_PROC_STRICT;
    return mrb_obj_value(p2);
  }"
https://huntr.dev/bounties/640605a7-9970-4d35-bd7e-fecc9dea69bc/,Use After Free in fcambus/logswan,"Good morning, I hope you're doing well today. Whilst testing logswan built with Clang12 + ASan on Ubuntu 20.04.3 LTS from commit bcfd41, we discovered a heap-use-after-free situation during a strcmp operation on line 259 of logswan/src/logswan.c.",,CWE-416: Use After Free,https://www.github.com/fcambus/logswan/commit/c3fc63fe8661d17272a5840b26a7e45cf21fb82a,"@@ -4,7 +4,7 @@
 * https://www.logswan.org
 *
 * Created:      2015-05-31
 * Last Updated: 2021-02-15
 *
 * Logswan is released under the BSD 2-Clause license.
 * See LICENSE file for details.
@@ -60,6 +60,8 @@ parse_request(struct request *parsed_request, char *request)
{
 char *pch = strrchr(request, ' ');



 if (pch) {
  parsed_request->protocol = pch + 1;
  parsed_request->method = strtok(request, "" "");

","4
src/parse.c
@@ -4,7 +4,7 @@
 * https://www.logswan.org
 *
 * Created:      2015-05-31
 * Last Updated: 2021-02-15
 * Last Updated: 2021-12-02
 *
 * Logswan is released under the BSD 2-Clause license.
 * See LICENSE file for details.
@@ -60,6 +60,8 @@ parse_request(struct request *parsed_request, char *request)
{
 char *pch = strrchr(request, ' ');

 memset(parsed_request, 0, sizeof(*parsed_request));

 if (pch) {
  parsed_request->protocol = pch + 1;
  parsed_request->method = strtok(request, "" "");"
https://huntr.dev/bounties/bd0fac4a-bf71-4dbe-bd36-3d86da6f3148/,Heap-based Buffer Overflow in allinurl/goaccess,"Good evening, I hope you're doing well during these challenging times. During recent research, we discovered a heap-buffer-overflow vulnerability impacting count_invalid() on line 555 of src/gstorage.c. It appears that this is caused by an excessive number of invalid log strings combined with no bounds checking in this area of code.",,CWE-122: Heap-based Buffer Overflow,https://www.github.com/allinurl/goaccess/commit/97742499009a1937504b9558a781affcefd81dd2,"@@ -551,7 +551,7 @@ count_invalid (GLog * glog, const char *line) {
    LOG_INVALID ((""%s"", line));
  }

  if (glog->items->errstr && glog->invalid < MAX_LOG_ERRORS) {
    glog->errors[glog->log_erridx++] = xstrdup (glog->items->errstr);
  }
}

","2
src/gstorage.c
@@ -551,7 +551,7 @@ count_invalid (GLog * glog, const char *line) {
    LOG_INVALID ((""%s"", line));
  }

  if (glog->items->errstr && glog->invalid < MAX_LOG_ERRORS) {
  if (glog->items->errstr && glog->log_erridx < MAX_LOG_ERRORS) {
    glog->errors[glog->log_erridx++] = xstrdup (glog->items->errstr);
  }
}"
https://huntr.dev/bounties/9814baa8-7bdd-4e31-a132-d9d15653409e/,Cross-site Scripting (XSS) - Stored in meetecho/janus-gateway,an user can enter a text room in janus gateway with a malicious name that contains a xss payload and could poison other users on the room,CVE-2021-4020,CWE-79: Cross-site Scripting (XSS) - Stored,https://www.github.com/meetecho/janus-gateway/commit/d3fc00ec803d6c41d8f98908732f44e7f4911a1c,"@@ -178,7 +178,7 @@ $(document).ready(function() {
            Janus.debug(""Got a list of participants:"", list);
            for(var f in list) {
             var id = list[f][""id""];
             var display = list[f][""display""];
             var setup = list[f][""setup""];
             var muted = list[f][""muted""];
             var spatial = list[f][""spatial_position""];
@@ -222,7 +222,7 @@ $(document).ready(function() {
            Janus.debug(""Got a list of participants:"", list);
            for(var f in list) {
             var id = list[f][""id""];
             var display = list[f][""display""];
             var setup = list[f][""setup""];
             var muted = list[f][""muted""];
             var spatial = list[f][""spatial_position""];
@@ -267,7 +267,7 @@ $(document).ready(function() {
            Janus.debug(""Got a list of participants:"", list);
            for(var f in list) {
             var id = list[f][""id""];
             var display = list[f][""display""];
             var setup = list[f][""setup""];
             var muted = list[f][""muted""];
             var spatial = list[f][""spatial_position""];
@@ -429,7 +429,7 @@ function registerUsername() {
   return;
  }
  var register = { request: ""join"", room: myroom, display: username };
  myusername = username;
  // Check if we need to join using G.711 instead of (default) Opus
  if(acodec === 'opus' || acodec === 'pcmu' || acodec === 'pcma')
   register.codec = acodec;
@@ -448,3 +448,12 @@ function getQueryStringValue(name) {
  results = regex.exec(location.search);
 return results === null ? """" : decodeURIComponent(results[1].replace(/\+/g, "" ""));
}









@@ -423,11 +423,11 @@ function updateRecsList() {
   Janus.debug(""Got a list of available recordings:"", list);
   for(var mp in list) {
    Janus.debug(""  >> ["" + list[mp][""id""] + ""] "" + list[mp][""name""] + "" ("" + list[mp][""date""] + "")"");
    $('#recslist').append(""<li><a href='#' id='"" + list[mp][""id""] + ""'>"" + list[mp][""name""] + "" ["" + list[mp][""date""] + ""]"" + ""</a></li>"");
   }
   $('#recslist a').unbind('click').click(function() {
    selectedRecording = $(this).attr(""id"");
    selectedRecordingInfo = $(this).text();
    $('#recset').html($(this).html()).parent().removeClass('open');
    $('#play').removeAttr('disabled').click(startPlayout);
    return false;
@@ -545,3 +545,12 @@ function getQueryStringValue(name) {
  results = regex.exec(location.search);
 return results === null ? """" : decodeURIComponent(results[1].replace(/\+/g, "" ""));
}









@@ -161,7 +161,7 @@ $(document).ready(function() {
          if(event === ""joined"") {
           myid = msg[""id""];
           $('#session').html(room);
           $('#title').html(msg[""description""]);
           Janus.log(""Successfully joined room "" + msg[""room""] + "" with ID "" + myid);
           if(role === ""publisher"") {
            // This is our session, publish our stream
@@ -514,3 +514,12 @@ function newRemoteFeed(id, display) {
   }
  });
}









@@ -323,7 +323,7 @@ function updateStreamsList() {
   Janus.debug(list);
   for(var mp in list) {
    Janus.debug(""  >> ["" + list[mp][""id""] + ""] "" + list[mp][""description""] + "" ("" + list[mp][""type""] + "")"");
    $('#streamslist').append(""<li><a href='#' id='"" + list[mp][""id""] + ""'>"" + list[mp][""description""] + "" ("" + list[mp][""type""] + "")"" + ""</a></li>"");
   }
   $('#streamslist a').unbind('click').click(function() {
    selectedStream = $(this).attr(""id"");
@@ -345,7 +345,7 @@ function getStreamInfo() {
 var body = { request: ""info"", id: parseInt(selectedStream) || selectedStream };
 streaming.send({ message: body, success: function(result) {
  if(result && result.info && result.info.metadata) {
   $('#metadata').html(result.info.metadata);
   $('#info').removeClass('hide').show();
  }
 }});
@@ -394,6 +394,15 @@ function stopStream() {
 simulcastStarted = false;
}










// Helpers to create Simulcast-related UI, if enabled
function addSimulcastButtons() {
 $('#curres').parent().append(

@@ -153,9 +153,7 @@ $(document).ready(function() {
         var what = json[""textroom""];
         if(what === ""message"") {
          // Incoming message: public or private?
          var msg = json[""text""];
          msg = msg.replace(new RegExp('<', 'g'), '&lt');
          msg = msg.replace(new RegExp('>', 'g'), '&gt');
          var from = json[""from""];
          var dateString = getDateString(json[""date""]);
          var whisper = json[""whisper""];
@@ -170,17 +168,15 @@ $(document).ready(function() {
          }
         } else if(what === ""announcement"") {
          // Room announcement
          var msg = json[""text""];
          msg = msg.replace(new RegExp('<', 'g'), '&lt');
          msg = msg.replace(new RegExp('>', 'g'), '&gt');
          var dateString = getDateString(json[""date""]);
          $('#chatroom').append('<p style=""color: purple;"">[' + dateString + '] <i>' + msg + '</i>');
          $('#chatroom').get(0).scrollTop = $('#chatroom').get(0).scrollHeight;
         } else if(what === ""join"") {
          // Somebody joined
          var username = json[""username""];
          var display = json[""display""];
          participants[username] = display ? display : username;
          if(username !== myid && $('#rp' + username).length === 0) {
           // Add to the participants list
           $('#list').append('<li id=""rp' + username + '"" class=""list-group-item"">' + participants[username] + '</li>');
@@ -282,7 +278,7 @@ function registerUsername() {
   username: myid,
   display: username
  };
  myusername = username;
  transactions[transaction] = function(response) {
   if(response[""textroom""] === ""error"") {
    // Something went wrong
@@ -312,7 +308,7 @@ function registerUsername() {
   if(response.participants && response.participants.length > 0) {
    for(var i in response.participants) {
     var p = response.participants[i];
     participants[p.username] = p.display ? p.display : p.username;
     if(p.username !== myid && $('#rp' + p.username).length === 0) {
      // Add to the participants list
      $('#list').append('<li id=""rp' + p.username + '"" class=""list-group-item"">' + participants[p.username] + '</li>');
@@ -418,3 +414,12 @@ function getQueryStringValue(name) {
  results = regex.exec(location.search);
 return results === null ? """" : decodeURIComponent(results[1].replace(/\+/g, "" ""));
}









@@ -148,7 +148,7 @@ $(document).ready(function() {
          } else if(result[""event""]) {
           var event = result[""event""];
           if(event === 'registered') {
            myusername = result[""username""];
            Janus.log(""Successfully registered as "" + myusername + ""!"");
            $('#youok').removeClass('hide').show().html(""Registered as '"" + myusername + ""'"");
            // Get a list of available peers, just for fun
@@ -163,7 +163,7 @@ $(document).ready(function() {
            bootbox.alert(""Waiting for the peer to answer..."");
           } else if(event === 'incomingcall') {
            Janus.log(""Incoming call from "" + result[""username""] + ""!"");
            yourusername = result[""username""];
            // Notify user
            bootbox.hideAll();
            incoming = bootbox.dialog({
@@ -213,7 +213,7 @@ $(document).ready(function() {
            });
           } else if(event === 'accepted') {
            bootbox.hideAll();
            var peer = result[""username""];
            if(!peer) {
             Janus.log(""Call started!"");
            } else {
@@ -598,6 +598,15 @@ function getQueryStringValue(name) {
 return results === null ? """" : decodeURIComponent(results[1].replace(/\+/g, "" ""));
}










// Helpers to create Simulcast-related UI, if enabled
function addSimulcastButtons(temporal) {
 $('#curres').parent().append(

@@ -400,7 +400,7 @@ function registerUsername() {
   ptype: ""publisher"",
   display: username
  };
  myusername = username;
  sfutest.send({ message: register });
 }
}
@@ -530,7 +530,7 @@ function newRemoteFeed(id, display, audio, video) {
       }
      }
      remoteFeed.rfid = msg[""id""];
      remoteFeed.rfdisplay = msg[""display""];
      if(!remoteFeed.spinner) {
       var target = document.getElementById('videoremote'+remoteFeed.rfindex);
       remoteFeed.spinner = new Spinner({top:100}).spin(target);
@@ -685,6 +685,15 @@ function getQueryStringValue(name) {
 return results === null ? """" : decodeURIComponent(results[1].replace(/\+/g, "" ""));
}










// Helpers to create Simulcast-related UI, if enabled
function addSimulcastButtons(feed, temporal) {
 var index = feed;

@@ -387,7 +387,7 @@ function registerUsername() {
   ptype: ""publisher"",
   display: username
  };
  myusername = username;
  sfutest.send({ message: register });
 }
}
@@ -486,7 +486,7 @@ function newRemoteFeed(id, display, audio, video) {
       }
      }
      remoteFeed.rfid = msg[""id""];
      remoteFeed.rfdisplay = msg[""display""];
      if(!remoteFeed.spinner) {
       var target = document.getElementById('videoremote'+remoteFeed.rfindex);
       remoteFeed.spinner = new Spinner({top:100}).spin(target);
@@ -630,6 +630,15 @@ function newRemoteFeed(id, display, audio, video) {
  });
}










// Helpers to create SVC-related UI for a new viewer
function addSvcButtons(feed) {
 var index = feed;

","17
html/audiobridgetest.js
@@ -178,7 +178,7 @@ $(document).ready(function() {
            Janus.debug(""Got a list of participants:"", list);
            for(var f in list) {
             var id = list[f][""id""];
             var display = list[f][""display""];
             var display = escapeXmlTags(list[f][""display""]);
             var setup = list[f][""setup""];
             var muted = list[f][""muted""];
             var spatial = list[f][""spatial_position""];
@@ -222,7 +222,7 @@ $(document).ready(function() {
            Janus.debug(""Got a list of participants:"", list);
            for(var f in list) {
             var id = list[f][""id""];
             var display = list[f][""display""];
             var display = escapeXmlTags(list[f][""display""]);
             var setup = list[f][""setup""];
             var muted = list[f][""muted""];
             var spatial = list[f][""spatial_position""];
@@ -267,7 +267,7 @@ $(document).ready(function() {
            Janus.debug(""Got a list of participants:"", list);
            for(var f in list) {
             var id = list[f][""id""];
             var display = list[f][""display""];
             var display = escapeXmlTags(list[f][""display""]);
             var setup = list[f][""setup""];
             var muted = list[f][""muted""];
             var spatial = list[f][""spatial_position""];
@@ -429,7 +429,7 @@ function registerUsername() {
   return;
  }
  var register = { request: ""join"", room: myroom, display: username };
  myusername = username;
  myusername = escapeXmlTags(username);
  // Check if we need to join using G.711 instead of (default) Opus
  if(acodec === 'opus' || acodec === 'pcmu' || acodec === 'pcma')
   register.codec = acodec;
@@ -448,3 +448,12 @@ function getQueryStringValue(name) {
  results = regex.exec(location.search);
 return results === null ? """" : decodeURIComponent(results[1].replace(/\+/g, "" ""));
}

// Helper to escape XML tags
function escapeXmlTags(value) {
 if(value) {
  var escapedValue = value.replace(new RegExp('<', 'g'), '&lt');
  escapedValue = escapedValue.replace(new RegExp('>', 'g'), '&gt');
  return escapedValue;
 }
}
13
html/recordplaytest.js
@@ -423,11 +423,11 @@ function updateRecsList() {
   Janus.debug(""Got a list of available recordings:"", list);
   for(var mp in list) {
    Janus.debug(""  >> ["" + list[mp][""id""] + ""] "" + list[mp][""name""] + "" ("" + list[mp][""date""] + "")"");
    $('#recslist').append(""<li><a href='#' id='"" + list[mp][""id""] + ""'>"" + list[mp][""name""] + "" ["" + list[mp][""date""] + ""]"" + ""</a></li>"");
    $('#recslist').append(""<li><a href='#' id='"" + list[mp][""id""] + ""'>"" + escapeXmlTags(list[mp][""name""]) + "" ["" + list[mp][""date""] + ""]"" + ""</a></li>"");
   }
   $('#recslist a').unbind('click').click(function() {
    selectedRecording = $(this).attr(""id"");
    selectedRecordingInfo = $(this).text();
    selectedRecordingInfo = escapeXmlTags($(this).text());
    $('#recset').html($(this).html()).parent().removeClass('open');
    $('#play').removeAttr('disabled').click(startPlayout);
    return false;
@@ -545,3 +545,12 @@ function getQueryStringValue(name) {
  results = regex.exec(location.search);
 return results === null ? """" : decodeURIComponent(results[1].replace(/\+/g, "" ""));
}

// Helper to escape XML tags
function escapeXmlTags(value) {
 if(value) {
  var escapedValue = value.replace(new RegExp('<', 'g'), '&lt');
  escapedValue = escapedValue.replace(new RegExp('>', 'g'), '&gt');
  return escapedValue;
 }
}
11
html/screensharingtest.js
@@ -161,7 +161,7 @@ $(document).ready(function() {
          if(event === ""joined"") {
           myid = msg[""id""];
           $('#session').html(room);
           $('#title').html(msg[""description""]);
           $('#title').html(escapeXmlTags(msg[""description""]));
           Janus.log(""Successfully joined room "" + msg[""room""] + "" with ID "" + myid);
           if(role === ""publisher"") {
            // This is our session, publish our stream
@@ -514,3 +514,12 @@ function newRemoteFeed(id, display) {
   }
  });
}

// Helper to escape XML tags
function escapeXmlTags(value) {
 if(value) {
  var escapedValue = value.replace(new RegExp('<', 'g'), '&lt');
  escapedValue = escapedValue.replace(new RegExp('>', 'g'), '&gt');
  return escapedValue;
 }
}
13
html/streamingtest.js
@@ -323,7 +323,7 @@ function updateStreamsList() {
   Janus.debug(list);
   for(var mp in list) {
    Janus.debug(""  >> ["" + list[mp][""id""] + ""] "" + list[mp][""description""] + "" ("" + list[mp][""type""] + "")"");
    $('#streamslist').append(""<li><a href='#' id='"" + list[mp][""id""] + ""'>"" + list[mp][""description""] + "" ("" + list[mp][""type""] + "")"" + ""</a></li>"");
    $('#streamslist').append(""<li><a href='#' id='"" + list[mp][""id""] + ""'>"" + escapeXmlTags(list[mp][""description""]) + "" ("" + list[mp][""type""] + "")"" + ""</a></li>"");
   }
   $('#streamslist a').unbind('click').click(function() {
    selectedStream = $(this).attr(""id"");
@@ -345,7 +345,7 @@ function getStreamInfo() {
 var body = { request: ""info"", id: parseInt(selectedStream) || selectedStream };
 streaming.send({ message: body, success: function(result) {
  if(result && result.info && result.info.metadata) {
   $('#metadata').html(result.info.metadata);
   $('#metadata').html(escapeXmlTags(result.info.metadata));
   $('#info').removeClass('hide').show();
  }
 }});
@@ -394,6 +394,15 @@ function stopStream() {
 simulcastStarted = false;
}

// Helper to escape XML tags
function escapeXmlTags(value) {
 if(value) {
  var escapedValue = value.replace(new RegExp('<', 'g'), '&lt');
  escapedValue = escapedValue.replace(new RegExp('>', 'g'), '&gt');
  return escapedValue;
 }
}

// Helpers to create Simulcast-related UI, if enabled
function addSimulcastButtons() {
 $('#curres').parent().append(
23
html/textroomtest.js
@@ -153,9 +153,7 @@ $(document).ready(function() {
         var what = json[""textroom""];
         if(what === ""message"") {
          // Incoming message: public or private?
          var msg = json[""text""];
          msg = msg.replace(new RegExp('<', 'g'), '&lt');
          msg = msg.replace(new RegExp('>', 'g'), '&gt');
          var msg = escapeXmlTags(json[""text""]);
          var from = json[""from""];
          var dateString = getDateString(json[""date""]);
          var whisper = json[""whisper""];
@@ -170,17 +168,15 @@ $(document).ready(function() {
          }
         } else if(what === ""announcement"") {
          // Room announcement
          var msg = json[""text""];
          msg = msg.replace(new RegExp('<', 'g'), '&lt');
          msg = msg.replace(new RegExp('>', 'g'), '&gt');
          var msg = escapeXmlTags(json[""text""]);
          var dateString = getDateString(json[""date""]);
          $('#chatroom').append('<p style=""color: purple;"">[' + dateString + '] <i>' + msg + '</i>');
          $('#chatroom').get(0).scrollTop = $('#chatroom').get(0).scrollHeight;
         } else if(what === ""join"") {
          // Somebody joined
          var username = json[""username""];
          var display = json[""display""];
          participants[username] = display ? display : username;
          participants[username] = escapeXmlTags(display ? display : username);
          if(username !== myid && $('#rp' + username).length === 0) {
           // Add to the participants list
           $('#list').append('<li id=""rp' + username + '"" class=""list-group-item"">' + participants[username] + '</li>');
@@ -282,7 +278,7 @@ function registerUsername() {
   username: myid,
   display: username
  };
  myusername = username;
  myusername = escapeXmlTags(username);
  transactions[transaction] = function(response) {
   if(response[""textroom""] === ""error"") {
    // Something went wrong
@@ -312,7 +308,7 @@ function registerUsername() {
   if(response.participants && response.participants.length > 0) {
    for(var i in response.participants) {
     var p = response.participants[i];
     participants[p.username] = p.display ? p.display : p.username;
     participants[p.username] = escapeXmlTags(p.display ? p.display : p.username);
     if(p.username !== myid && $('#rp' + p.username).length === 0) {
      // Add to the participants list
      $('#list').append('<li id=""rp' + p.username + '"" class=""list-group-item"">' + participants[p.username] + '</li>');
@@ -418,3 +414,12 @@ function getQueryStringValue(name) {
  results = regex.exec(location.search);
 return results === null ? """" : decodeURIComponent(results[1].replace(/\+/g, "" ""));
}

// Helper to escape XML tags
function escapeXmlTags(value) {
 if(value) {
  var escapedValue = value.replace(new RegExp('<', 'g'), '&lt');
  escapedValue = escapedValue.replace(new RegExp('>', 'g'), '&gt');
  return escapedValue;
 }
}
15
html/videocalltest.js
@@ -148,7 +148,7 @@ $(document).ready(function() {
          } else if(result[""event""]) {
           var event = result[""event""];
           if(event === 'registered') {
            myusername = result[""username""];
            myusername = escapeXmlTags(result[""username""]);
            Janus.log(""Successfully registered as "" + myusername + ""!"");
            $('#youok').removeClass('hide').show().html(""Registered as '"" + myusername + ""'"");
            // Get a list of available peers, just for fun
@@ -163,7 +163,7 @@ $(document).ready(function() {
            bootbox.alert(""Waiting for the peer to answer..."");
           } else if(event === 'incomingcall') {
            Janus.log(""Incoming call from "" + result[""username""] + ""!"");
            yourusername = result[""username""];
            yourusername = escapeXmlTags(result[""username""]);
            // Notify user
            bootbox.hideAll();
            incoming = bootbox.dialog({
@@ -213,7 +213,7 @@ $(document).ready(function() {
            });
           } else if(event === 'accepted') {
            bootbox.hideAll();
            var peer = result[""username""];
            var peer = escapeXmlTags(result[""username""]);
            if(!peer) {
             Janus.log(""Call started!"");
            } else {
@@ -598,6 +598,15 @@ function getQueryStringValue(name) {
 return results === null ? """" : decodeURIComponent(results[1].replace(/\+/g, "" ""));
}

// Helper to escape XML tags
function escapeXmlTags(value) {
 if(value) {
  var escapedValue = value.replace(new RegExp('<', 'g'), '&lt');
  escapedValue = escapedValue.replace(new RegExp('>', 'g'), '&gt');
  return escapedValue;
 }
}

// Helpers to create Simulcast-related UI, if enabled
function addSimulcastButtons(temporal) {
 $('#curres').parent().append(
13
html/videoroomtest.js
@@ -400,7 +400,7 @@ function registerUsername() {
   ptype: ""publisher"",
   display: username
  };
  myusername = username;
  myusername = escapeXmlTags(username);
  sfutest.send({ message: register });
 }
}
@@ -530,7 +530,7 @@ function newRemoteFeed(id, display, audio, video) {
       }
      }
      remoteFeed.rfid = msg[""id""];
      remoteFeed.rfdisplay = msg[""display""];
      remoteFeed.rfdisplay = escapeXmlTags(msg[""display""]);
      if(!remoteFeed.spinner) {
       var target = document.getElementById('videoremote'+remoteFeed.rfindex);
       remoteFeed.spinner = new Spinner({top:100}).spin(target);
@@ -685,6 +685,15 @@ function getQueryStringValue(name) {
 return results === null ? """" : decodeURIComponent(results[1].replace(/\+/g, "" ""));
}

// Helper to escape XML tags
function escapeXmlTags(value) {
 if(value) {
  var escapedValue = value.replace(new RegExp('<', 'g'), '&lt');
  escapedValue = escapedValue.replace(new RegExp('>', 'g'), '&gt');
  return escapedValue;
 }
}

// Helpers to create Simulcast-related UI, if enabled
function addSimulcastButtons(feed, temporal) {
 var index = feed;
13
html/vp9svctest.js
@@ -387,7 +387,7 @@ function registerUsername() {
   ptype: ""publisher"",
   display: username
  };
  myusername = username;
  myusername = escapeXmlTags(username);
  sfutest.send({ message: register });
 }
}
@@ -486,7 +486,7 @@ function newRemoteFeed(id, display, audio, video) {
       }
      }
      remoteFeed.rfid = msg[""id""];
      remoteFeed.rfdisplay = msg[""display""];
      remoteFeed.rfdisplay = escapeXmlTags(msg[""display""]);
      if(!remoteFeed.spinner) {
       var target = document.getElementById('videoremote'+remoteFeed.rfindex);
       remoteFeed.spinner = new Spinner({top:100}).spin(target);
@@ -630,6 +630,15 @@ function newRemoteFeed(id, display, audio, video) {
  });
}

// Helper to escape XML tags
function escapeXmlTags(value) {
 if(value) {
  var escapedValue = value.replace(new RegExp('<', 'g'), '&lt');
  escapedValue = escapedValue.replace(new RegExp('>', 'g'), '&gt');
  return escapedValue;
 }
}

// Helpers to create SVC-related UI for a new viewer
function addSvcButtons(feed) {
 var index = feed;"
https://huntr.dev/bounties/d2536d7d-36ce-4723-928c-98d1ee039784/,Heap-based Buffer Overflow in zyantific/zydis,Description,,CWE-122: Heap-based Buffer Overflow,https://www.github.com/zyantific/zydis/commit/330b259583ade789886ce11af2ebcd030097dcbf,"@@ -62,13 +62,30 @@ void ZydisFormatterBufferInit(ZydisFormatterBuffer* buffer, char* user_buffer,
    ZYAN_ASSERT(user_buffer);
    ZYAN_ASSERT(length);

    buffer->is_token_list              = ZYAN_FALSE;
    buffer->string.flags               = ZYAN_STRING_HAS_FIXED_CAPACITY;
    buffer->string.vector.allocator    = ZYAN_NULL;
    buffer->string.vector.element_size = sizeof(char);
    buffer->string.vector.size         = 1;
    buffer->string.vector.capacity     = length;
    buffer->string.vector.data         = user_buffer;

















    *user_buffer = '\0';
}

@@ -87,14 +104,30 @@ void ZydisFormatterBufferInitTokenized(ZydisFormatterBuffer* buffer,
    user_buffer = (ZyanU8*)user_buffer + sizeof(ZydisFormatterToken);
    length -= sizeof(ZydisFormatterToken);

    buffer->is_token_list              = ZYAN_TRUE;
    buffer->capacity                   = length;
    buffer->string.flags               = ZYAN_STRING_HAS_FIXED_CAPACITY;
    buffer->string.vector.allocator    = ZYAN_NULL;
    buffer->string.vector.element_size = sizeof(char);
    buffer->string.vector.size         = 1;
    buffer->string.vector.capacity     = length;
    buffer->string.vector.data         = user_buffer;
















    *(char*)user_buffer = '\0';
}


","63
src/Formatter.c
@@ -62,13 +62,30 @@ void ZydisFormatterBufferInit(ZydisFormatterBuffer* buffer, char* user_buffer,
    ZYAN_ASSERT(user_buffer);
    ZYAN_ASSERT(length);

    buffer->is_token_list              = ZYAN_FALSE;
    buffer->string.flags               = ZYAN_STRING_HAS_FIXED_CAPACITY;
    buffer->string.vector.allocator    = ZYAN_NULL;
    buffer->string.vector.element_size = sizeof(char);
    buffer->string.vector.size         = 1;
    buffer->string.vector.capacity     = length;
    buffer->string.vector.data         = user_buffer;
    buffer->is_token_list                   = ZYAN_FALSE;
    buffer->capacity                        = 0;
    buffer->string.flags                    = ZYAN_STRING_HAS_FIXED_CAPACITY;
    buffer->string.vector.allocator         = ZYAN_NULL;
#if defined(ZYAN_NO_LIBC) // no-libc correlates quite well with kernel environments
    // We can't use floats in kernel. Initialize them via memcpy hack.
    // Note: this is only required in the backported version for Zydis v3.0.
    // Newer version depend on a version of zycore that got rid of the floats.

    ZYAN_STATIC_ASSERT(sizeof(buffer->string.vector.growth_factor) == 4);
    ZYAN_STATIC_ASSERT(sizeof(buffer->string.vector.shrink_threshold) == 4);

    ZYAN_MEMCPY(&buffer->string.vector.growth_factor, ""\x00\x00\x80\x3F"", 4);
    ZYAN_MEMCPY(&buffer->string.vector.shrink_threshold, ""\x00\x00\x00\x00"", 4);
#else
    buffer->string.vector.growth_factor     = 1.0f;
    buffer->string.vector.shrink_threshold  = 0.0f;
#endif
    buffer->string.vector.destructor        = ZYAN_NULL;
    buffer->string.vector.element_size      = sizeof(char);
    buffer->string.vector.size              = 1;
    buffer->string.vector.capacity          = length;
    buffer->string.vector.data              = user_buffer;

    *user_buffer = '\0';
}

@@ -87,14 +104,30 @@ void ZydisFormatterBufferInitTokenized(ZydisFormatterBuffer* buffer,
    user_buffer = (ZyanU8*)user_buffer + sizeof(ZydisFormatterToken);
    length -= sizeof(ZydisFormatterToken);

    buffer->is_token_list              = ZYAN_TRUE;
    buffer->capacity                   = length;
    buffer->string.flags               = ZYAN_STRING_HAS_FIXED_CAPACITY;
    buffer->string.vector.allocator    = ZYAN_NULL;
    buffer->string.vector.element_size = sizeof(char);
    buffer->string.vector.size         = 1;
    buffer->string.vector.capacity     = length;
    buffer->string.vector.data         = user_buffer;
    buffer->is_token_list                  = ZYAN_TRUE;
    buffer->capacity                       = length;
    buffer->string.flags                   = ZYAN_STRING_HAS_FIXED_CAPACITY;
    buffer->string.vector.allocator        = ZYAN_NULL;
#if defined(ZYAN_NO_LIBC) // no-libc correlates quite well with kernel environments
    // We can't use floats in kernel. Initialize them via memcpy hack.
    // Note: this is only required in the backported version for Zydis v3.0.
    // Newer version depend on a version of zycore that got rid of the floats.

    ZYAN_STATIC_ASSERT(sizeof(buffer->string.vector.growth_factor) == 4);
    ZYAN_STATIC_ASSERT(sizeof(buffer->string.vector.shrink_threshold) == 4);

    ZYAN_MEMCPY(&buffer->string.vector.growth_factor, ""\x00\x00\x80\x3F"", 4);
    ZYAN_MEMCPY(&buffer->string.vector.shrink_threshold, ""\x00\x00\x00\x00"", 4);
#else
    buffer->string.vector.growth_factor     = 1.0f;
    buffer->string.vector.shrink_threshold  = 0.0f;
#endif
    buffer->string.vector.destructor       = ZYAN_NULL;
    buffer->string.vector.element_size     = sizeof(char);
    buffer->string.vector.size             = 1;
    buffer->string.vector.capacity         = length;
    buffer->string.vector.data             = user_buffer;

    *(char*)user_buffer = '\0';
}"
https://huntr.dev/bounties/c411000a-0190-4669-a676-4f1285cae135/,Heap-based Buffer Overflow in hoene/libmysofa,"The variable st->filt_len in the function speex_resampler_reset_mem is not checked to see if it is 0 before it is used, and after subtracting one, it becomes 0xffffffff, causing heap overflow",,CWE-122: Heap-based Buffer Overflow,https://www.github.com/hoene/libmysofa/commit/151e71be90cacd625c7d8dac78a07e2f6d6491e6,"@@ -19,8 +19,8 @@ set(CPACK_PACKAGE_CONTACT ""umlaeute@debian.org"")
set(CPACK_GENERATOR ""DEB"")
set(CPACK_DEBIAN_PACKAGE_MAINTAINER ""IOhannes m zmölnig"")
set(CPACK_PACKAGE_VERSION_MAJOR ""1"")
set(CPACK_PACKAGE_VERSION_MINOR ""1"")
set(CPACK_PACKAGE_VERSION_PATCH ""0"")
set(CPACK_DEBIAN_PACKAGE_DEPENDS ""zlib1g"")

set(PKG_CONFIG_PRIVATELIBS """")

","4
CMakeLists.txt
@@ -19,8 +19,8 @@ set(CPACK_PACKAGE_CONTACT ""umlaeute@debian.org"")
set(CPACK_GENERATOR ""DEB"")
set(CPACK_DEBIAN_PACKAGE_MAINTAINER ""IOhannes m zmölnig"")
set(CPACK_PACKAGE_VERSION_MAJOR ""1"")
set(CPACK_PACKAGE_VERSION_MINOR ""1"")
set(CPACK_PACKAGE_VERSION_PATCH ""0"")
set(CPACK_PACKAGE_VERSION_MINOR ""2"")
set(CPACK_PACKAGE_VERSION_PATCH ""2"")
set(CPACK_DEBIAN_PACKAGE_DEPENDS ""zlib1g"")

set(PKG_CONFIG_PRIVATELIBS """")"
https://huntr.dev/bounties/3bf0a9c0-c375-4819-918f-e404278785d2/,Heap-based Buffer Overflow in zyantific/zydis,"Hello, we hope you're doing well during these challenging times. Whilst testing zydis built from commit 077b185 with Clang12 + ASan on Ubuntu 18.04, we discovered a crafted PE file that when fed to ZydisPE triggers a heap-buffer-overflow, READ of size 1.",,CWE-122: Heap-based Buffer Overflow,https://www.github.com/zyantific/zydis/commit/869dfb42992236ba61376ba983a2c323200a2b0e,"@@ -306,13 +306,5 @@ if (ZYDIS_BUILD_TOOLS AND NOT ZYAN_NO_LIBC)
        zyan_maybe_enable_wpo(""ZydisInfo"")
        _maybe_set_emscripten_cfg(""ZydisInfo"")
        install(TARGETS ""ZydisInfo"" RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})

        add_executable(""ZydisPE"" ""tools/ZydisPE.c"")
        target_link_libraries(""ZydisPE"" ""Zydis"")
        set_target_properties (""ZydisPE"" PROPERTIES FOLDER ""Tools"")
        target_compile_definitions(""ZydisPE"" PRIVATE ""_CRT_SECURE_NO_WARNINGS"")
        zyan_set_common_flags(""ZydisPE"")
        zyan_maybe_enable_wpo(""ZydisPE"")
        _maybe_set_emscripten_cfg(""ZydisPE"")
    endif ()
endif ()
","8
CMakeLists.txt
@@ -306,13 +306,5 @@ if (ZYDIS_BUILD_TOOLS AND NOT ZYAN_NO_LIBC)
        zyan_maybe_enable_wpo(""ZydisInfo"")
        _maybe_set_emscripten_cfg(""ZydisInfo"")
        install(TARGETS ""ZydisInfo"" RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})

        add_executable(""ZydisPE"" ""tools/ZydisPE.c"")
        target_link_libraries(""ZydisPE"" ""Zydis"")
        set_target_properties (""ZydisPE"" PROPERTIES FOLDER ""Tools"")
        target_compile_definitions(""ZydisPE"" PRIVATE ""_CRT_SECURE_NO_WARNINGS"")
        zyan_set_common_flags(""ZydisPE"")
        zyan_maybe_enable_wpo(""ZydisPE"")
        _maybe_set_emscripten_cfg(""ZydisPE"")
    endif ()
endif ()"
https://huntr.dev/bounties/166a178d-b376-4b74-b2cc-5349a4b3bd24/,Heap-based Buffer Overflow in timetoogo/ff-proxy,Heap based buffer overflow in ff_client_send_request. Can be triggered if the buffer size is more than FF_CLIENT_MAX_PACKET_LENGTH,,CWE-122: Heap-based Buffer Overflow,https://www.github.com/timetoogo/ff-proxy/commit/50566a15fb0ed3a964bb8f37cca0bdd8e56f2595,"@@ -339,20 +339,27 @@ uint8_t ff_client_send_request(struct ff_client_config *config, struct ff_client

    for (uint16_t i = 0; i < packets_count; i++)
    {
        do













        {
            ff_log(FF_INFO, ""test: %d"", packets_count);
            chunk_length = sendto(sockfd, packets[i].value + sent_length, packets[i].length, 0, res->ai_addr, res->ai_addrlen);

            if (chunk_length <= 0)
            {
                printf(""errno: %d\n"", errno);
                ff_log(FF_FATAL, ""Failed to send UDP datagrams during byte range %d - %hu"", sent_length, packets[i].length);
                goto error;
            }

            sent_length += chunk_length;
        } while (sent_length < packets[i].length);
    }

    ff_log(FF_DEBUG, ""Finished sending %d bytes"", sent_length);

","33
client/c/client.c
@@ -339,20 +339,27 @@ uint8_t ff_client_send_request(struct ff_client_config *config, struct ff_client

    for (uint16_t i = 0; i < packets_count; i++)
    {
        do
        ff_log(
            FF_INFO, ""sending packet %d byte range [%d, %d]"", 
            i, 0, (int)packets[i].length
        );
        chunk_length = sendto(
            sockfd, 
            packets[i].value, 
            (int)packets[i].length, 
            0, 
            res->ai_addr, 
            res->ai_addrlen
        );

        if (chunk_length <= 0)
        {
            ff_log(FF_INFO, ""test: %d"", packets_count);
            chunk_length = sendto(sockfd, packets[i].value + sent_length, packets[i].length, 0, res->ai_addr, res->ai_addrlen);

            if (chunk_length <= 0)
            {
                printf(""errno: %d\n"", errno);
                ff_log(FF_FATAL, ""Failed to send UDP datagrams during byte range %d - %hu"", sent_length, packets[i].length);
                goto error;
            }

            sent_length += chunk_length;
        } while (sent_length < packets[i].length);
            printf(""errno: %d\n"", errno);
            ff_log(FF_FATAL, ""Failed to send UDP datagrams during byte range %d - %hu"", 0, packets[i].length);
            goto error;
        }

        sent_length += chunk_length;
    }

    ff_log(FF_DEBUG, ""Finished sending %d bytes"", sent_length);"
https://huntr.dev/bounties/aef565f2-86c7-46b9-a721-720622b86aa5/,Heap-based Buffer Overflow in hoene/libmysofa,system : ubuntu 20.04,,CWE-122: Heap-based Buffer Overflow,https://www.github.com/hoene/libmysofa/commit/e846c89c421f123984d2daf011323b1ac39e9d79,"@@ -87,7 +87,8 @@ if(BUILD_TESTS)
    163
    167a
    167b
    168  

)
    # issues with osx    96)
    add_test(fail-issue-${ISSUE} ${PROJECT_SOURCE_DIR}/tests/notcrashed.sh

@@ -27,7 +27,7 @@ MYSOFA_EXPORT float mysofa_loudness(struct MYSOFA_HRTF *hrtf) {
  /*
   * find frontal source position
   */
  for (i = 0; i < hrtf->SourcePosition.elements; i += hrtf->C) {
    c[0] = hrtf->SourcePosition.values[i];
    c[1] = hrtf->SourcePosition.values[i + 1];
    c[2] = hrtf->SourcePosition.values[i + 2];

","3
CMakeLists.txt
@@ -87,7 +87,8 @@ if(BUILD_TESTS)
    163
    167a
    167b
    168  
    168
    171
)
    # issues with osx    96)
    add_test(fail-issue-${ISSUE} ${PROJECT_SOURCE_DIR}/tests/notcrashed.sh
2
src/hrtf/loudness.c
@@ -27,7 +27,7 @@ MYSOFA_EXPORT float mysofa_loudness(struct MYSOFA_HRTF *hrtf) {
  /*
   * find frontal source position
   */
  for (i = 0; i < hrtf->SourcePosition.elements; i += hrtf->C) {
  for (i = 0; i + 2 < hrtf->SourcePosition.elements; i += hrtf->C) {
    c[0] = hrtf->SourcePosition.values[i];
    c[1] = hrtf->SourcePosition.values[i + 1];
    c[2] = hrtf->SourcePosition.values[i + 2];
BIN +89.3 KB
tests/fail-issue-171.sofa
Binary file not shown."
https://huntr.dev/bounties/86baca8e-b382-4743-93a6-d9b6f48ee535/,Classic Buffer Overflow in sjord/checkmate,"Good morning, I hope this message finds you well during these challenging times. Whilst testing checkmate built from commit 8e497d8, we discovered crafted input which triggers a bug in the frame parsing code, leading to a global-buffer-overflow, READ of size 4.",,CWE-120: Classic Buffer Overflow,https://www.github.com/sjord/checkmate/commit/2e730a9d846466e4e8ef4bd6d22f21f397419547,"@@ -38,14 +38,17 @@
#include <errno.h>
#endif




/* samplerate in Hz of frame fi with headervalue h */
#define samplerate(h, fi)  samplerate_matrix[h][fi->version]

/* the duration of this frame in ms */
#define frametime(fi)      (1000*fi->samples/fi->samplerate)

/* the number of samples in frame fi */
#define framesamples(fi)   samples_matrix[fi->layer][fi->version]

/* the layer for headervalue h */
#define layer(h)     (4-(h))
@@ -108,7 +111,7 @@ setconsistent(file_info * file, const frame_info * frame)
/* returns bitrate in bps */
static int bitrate(int headervalue, frame_info * fi)
{
 return 1000*bitrate_matrix[3*fi->version+fi->layer-1][headervalue];
}

static int 

","9
mpck/checkframe.c
@@ -38,14 +38,17 @@
#include <errno.h>
#endif

/* return matrix[x][y], or 0 if x or y are out of bounds */
#define matrix_lookup(matrix, x, y) (x < sizeof(matrix) / sizeof(matrix[0]) && y < sizeof(matrix[0]) / sizeof(matrix[0][0]) ? matrix[x][y] : 0)

/* samplerate in Hz of frame fi with headervalue h */
#define samplerate(h, fi)  samplerate_matrix[h][fi->version]
#define samplerate(h, fi)  matrix_lookup(samplerate_matrix, h, fi->version)

/* the duration of this frame in ms */
#define frametime(fi)      (1000*fi->samples/fi->samplerate)

/* the number of samples in frame fi */
#define framesamples(fi)   samples_matrix[fi->layer][fi->version]
#define framesamples(fi)   matrix_lookup(samples_matrix, fi->layer, fi->version)

/* the layer for headervalue h */
#define layer(h)     (4-(h))
@@ -108,7 +111,7 @@ setconsistent(file_info * file, const frame_info * frame)
/* returns bitrate in bps */
static int bitrate(int headervalue, frame_info * fi)
{
 return 1000*bitrate_matrix[3*fi->version+fi->layer-1][headervalue];
 return 1000*matrix_lookup(bitrate_matrix, 3*fi->version+fi->layer-1, headervalue);
}

static int "
https://huntr.dev/bounties/a012e939-0f28-483f-ab24-37aa857b9112/,NULL Pointer Dereference in mruby/mruby,SEGV on mrb_ary_push,,CWE-476: NULL Pointer Dereference,https://www.github.com/mruby/mruby/commit/de2b4bd0dce06da05bdac22eee57e80f847377a8,"@@ -1642,7 +1642,7 @@ gen_call(codegen_scope *s, node *tree, mrb_sym name, int sp, int val, int safe)
{
  mrb_sym sym = name ? name : nsym(tree->cdr->car);
  int skip = 0;
  int n = 0, nk = 0, st = 0, noop = 0, blk = 0;

  codegen(s, tree->car, VAL); /* receiver */
  if (safe) {
@@ -1653,9 +1653,8 @@ gen_call(codegen_scope *s, node *tree, mrb_sym name, int sp, int val, int safe)
  tree = tree->cdr->cdr->car;
  if (tree) {
    if (tree->car) {            /* positional arguments */
      st = n = gen_values(s, tree->car, VAL, sp?1:0, 14);
      if (n < 0) {              /* variable length */
        st = 1;                 /* one stack element */
        noop = 1;               /* not operator */
        n = 15;
        push();
@@ -1664,12 +1663,22 @@ gen_call(codegen_scope *s, node *tree, mrb_sym name, int sp, int val, int safe)
    if (tree->cdr->car) {       /* keyword arguments */
      noop = 1;
      nk = gen_hash(s, tree->cdr->car->cdr, VAL, 14);
      if (nk < 0) {st++; nk = 15;}
      else st += 2*nk;
    }
  }
  if (sp) {                     /* last argument pushed (attr=, []=) */






    if (n == CALL_MAXARGS) {





      gen_move(s, cursp(), sp, 0);
      pop();
      genop_2(s, OP_ARYPUSH, cursp(), 1);
@@ -1678,8 +1687,10 @@ gen_call(codegen_scope *s, node *tree, mrb_sym name, int sp, int val, int safe)
    else {
      gen_move(s, cursp(), sp, 0);
      push();
      n++; st++;

    }

  }
  if (tree && tree->cdr && tree->cdr->cdr) {
    codegen(s, tree->cdr->cdr, VAL);
@@ -1688,7 +1699,7 @@ gen_call(codegen_scope *s, node *tree, mrb_sym name, int sp, int val, int safe)
    blk = 1;
  }
  push();pop();
  pop_n(st+1);
  if (!noop && sym == MRB_OPSYM_2(s->mrb, add) && n == 1)  {
    gen_addsub(s, OP_ADD, cursp());
  }

","25
mrbgems/mruby-compiler/core/codegen.c
@@ -1642,7 +1642,7 @@ gen_call(codegen_scope *s, node *tree, mrb_sym name, int sp, int val, int safe)
{
  mrb_sym sym = name ? name : nsym(tree->cdr->car);
  int skip = 0;
  int n = 0, nk = 0, st = 0, noop = 0, blk = 0;
  int n = 0, nk = 0, noop = 0, blk = 0, sp_save = cursp();

  codegen(s, tree->car, VAL); /* receiver */
  if (safe) {
@@ -1653,9 +1653,8 @@ gen_call(codegen_scope *s, node *tree, mrb_sym name, int sp, int val, int safe)
  tree = tree->cdr->cdr->car;
  if (tree) {
    if (tree->car) {            /* positional arguments */
      st = n = gen_values(s, tree->car, VAL, sp?1:0, 14);
      n = gen_values(s, tree->car, VAL, sp?1:0, 14);
      if (n < 0) {              /* variable length */
        st = 1;                 /* one stack element */
        noop = 1;               /* not operator */
        n = 15;
        push();
@@ -1664,12 +1663,22 @@ gen_call(codegen_scope *s, node *tree, mrb_sym name, int sp, int val, int safe)
    if (tree->cdr->car) {       /* keyword arguments */
      noop = 1;
      nk = gen_hash(s, tree->cdr->car->cdr, VAL, 14);
      if (nk < 0) {st++; nk = 15;}
      else st += 2*nk;
      if (nk < 0) nk = 15;
    }
  }
  if (sp) {                     /* last argument pushed (attr=, []=) */
    /* pack keyword arguments */
    if (nk > 0 && nk < 15) {
      pop_n(nk*2);
      genop_2(s, OP_HASH, cursp(), nk);
      push();
    }
    if (n == CALL_MAXARGS) {
      if (nk > 0) {
        pop(); pop();
        genop_2(s, OP_ARYPUSH, cursp(), 1);
        push();
      }
      gen_move(s, cursp(), sp, 0);
      pop();
      genop_2(s, OP_ARYPUSH, cursp(), 1);
@@ -1678,8 +1687,10 @@ gen_call(codegen_scope *s, node *tree, mrb_sym name, int sp, int val, int safe)
    else {
      gen_move(s, cursp(), sp, 0);
      push();
      n++; st++;
      if (nk > 0) n++;
      n++;
    }
    nk = 0;
  }
  if (tree && tree->cdr && tree->cdr->cdr) {
    codegen(s, tree->cdr->cdr, VAL);
@@ -1688,7 +1699,7 @@ gen_call(codegen_scope *s, node *tree, mrb_sym name, int sp, int val, int safe)
    blk = 1;
  }
  push();pop();
  pop_n(st+1);
  s->sp = sp_save;
  if (!noop && sym == MRB_OPSYM_2(s->mrb, add) && n == 1)  {
    gen_addsub(s, OP_ADD, cursp());
  }"
https://huntr.dev/bounties/ab0e4044-624e-4855-927e-e1964064c2a9/,NULL Pointer Dereference in mruby/mruby,Please enter a description of the vulnerability.,,CWE-476: NULL Pointer Dereference,https://www.github.com/mruby/mruby/commit/be189ae9f90df298bf3e3bf720ea053297126246,"@@ -2830,7 +2830,8 @@ codegen(codegen_scope *s, node *tree, int val)
        st++;
      }
      else {
        gen_blkmove(s, s2->ainfo, lv);

        st++;
      }
      pop_n(st+1);

","3
mrbgems/mruby-compiler/core/codegen.c
@@ -2830,7 +2830,8 @@ codegen(codegen_scope *s, node *tree, int val)
        st++;
      }
      else {
        gen_blkmove(s, s2->ainfo, lv);
        if (!s2) push();
        else gen_blkmove(s, s2->ainfo, lv);
        st++;
      }
      pop_n(st+1);"
https://huntr.dev/bounties/299abef4-0830-431b-964c-65b78260c264/,Heap-based Buffer Overflow in hoene/libmysofa,system : ubuntu 20.04,,CWE-122: Heap-based Buffer Overflow,https://www.github.com/hoene/libmysofa/commit/ba82b15c551a3fb3607d42f17aa990ed758a03c0,"@@ -161,10 +161,10 @@ MYSOFA_EXPORT int mysofa_check(struct MYSOFA_HRTF *hrtf)
  else if (verifyAttribute(hrtf->ReceiverPosition.attributes,
                           ""DIMENSION_LIST"", ""R,C,M""))
  {
    if (hrtf->ReceiverPosition.elements != 6 * hrtf->M)
      return MYSOFA_INVALID_RECEIVER_POSITIONS;

    for (int i = 0; i < 6; i++)
    {
      int offset = i * hrtf->M;
      double receiverPosition = hrtf->ReceiverPosition.values[offset];
@@ -182,7 +182,7 @@ MYSOFA_EXPORT int mysofa_check(struct MYSOFA_HRTF *hrtf)
  if (!verifyAttribute(hrtf->ReceiverPosition.attributes, ""Type"", ""cartesian""))
    return MYSOFA_RECEIVERS_WITH_CARTESIAN_SUPPORTED; // LCOV_EXCL_LINE

  if (hrtf->ReceiverPosition.elements < 6 ||
      !fequals(hrtf->ReceiverPosition.values[0], 0.f) ||
      !fequals(hrtf->ReceiverPosition.values[2], 0.f) ||
      !fequals(hrtf->ReceiverPosition.values[3], 0.f) ||

","6
src/hrtf/check.c
@@ -161,10 +161,10 @@ MYSOFA_EXPORT int mysofa_check(struct MYSOFA_HRTF *hrtf)
  else if (verifyAttribute(hrtf->ReceiverPosition.attributes,
                           ""DIMENSION_LIST"", ""R,C,M""))
  {
    if (hrtf->ReceiverPosition.elements != 6 * hrtf->M)
    if (hrtf->ReceiverPosition.elements != hrtf->C * hrtf->R * hrtf->M)
      return MYSOFA_INVALID_RECEIVER_POSITIONS;

    for (int i = 0; i < 6; i++)
    for (int i = 0; i < hrtf->C * hrtf->R; i++)
    {
      int offset = i * hrtf->M;
      double receiverPosition = hrtf->ReceiverPosition.values[offset];
@@ -182,7 +182,7 @@ MYSOFA_EXPORT int mysofa_check(struct MYSOFA_HRTF *hrtf)
  if (!verifyAttribute(hrtf->ReceiverPosition.attributes, ""Type"", ""cartesian""))
    return MYSOFA_RECEIVERS_WITH_CARTESIAN_SUPPORTED; // LCOV_EXCL_LINE

  if (hrtf->ReceiverPosition.elements < 6 ||
  if (hrtf->ReceiverPosition.elements < hrtf->C * hrtf->R ||
      !fequals(hrtf->ReceiverPosition.values[0], 0.f) ||
      !fequals(hrtf->ReceiverPosition.values[2], 0.f) ||
      !fequals(hrtf->ReceiverPosition.values[3], 0.f) ||"
https://huntr.dev/bounties/a6f4e4fe-f9e8-44fa-89aa-ce70bd29dadb/,Heap-based Buffer Overflow in hoene/libmysofa,system : ubuntu 20.04,,CWE-122: Heap-based Buffer Overflow,https://www.github.com/hoene/libmysofa/commit/b6a36985580fdf8ebf958cab5ee0d1cf5bdede5e,"@@ -84,7 +84,9 @@ if(BUILD_TESTS)
    137
    138
    156
    163)


    # issues with osx    96)
    add_test(fail-issue-${ISSUE} ${PROJECT_SOURCE_DIR}/tests/notcrashed.sh
             ${PROJECT_SOURCE_DIR}/tests/fail-issue-${ISSUE})

@@ -21,11 +21,13 @@
static struct MYSOFA_EASY *
mysofa_open_default(const char *filename, float samplerate, int *filterlength,
                    int *err, bool applyNorm, float neighbor_angle_step,
                    float neighbor_radius_step) {


  struct MYSOFA_EASY *easy = malloc(sizeof(struct MYSOFA_EASY));

  if (!easy) {

    *err = MYSOFA_NO_MEMORY;
    return NULL;
  }
@@ -35,24 +37,28 @@ mysofa_open_default(const char *filename, float samplerate, int *filterlength,
  *easy = (struct MYSOFA_EASY){0};

  easy->hrtf = mysofa_load(filename, err);
  if (!easy->hrtf) {

    mysofa_close(easy);
    return NULL;
  }

  *err = mysofa_check(easy->hrtf);
  if (*err != MYSOFA_OK) {

    mysofa_close(easy);
    return NULL;
  }

  *err = mysofa_resample(easy->hrtf, samplerate);
  if (*err != MYSOFA_OK) {

    mysofa_close(easy);
    return NULL;
  }

  if (applyNorm) {

    mysofa_loudness(easy->hrtf);
  }

@@ -62,8 +68,16 @@ mysofa_open_default(const char *filename, float samplerate, int *filterlength,

  mysofa_tocartesian(easy->hrtf);








  easy->lookup = mysofa_lookup_init(easy->hrtf);
  if (easy->lookup == NULL) {

    *err = MYSOFA_INTERNAL_ERROR;
    mysofa_close(easy);
    return NULL;
@@ -82,7 +96,8 @@ mysofa_open_default(const char *filename, float samplerate, int *filterlength,

MYSOFA_EXPORT struct MYSOFA_EASY *mysofa_open(const char *filename,
                                              float samplerate,
                                              int *filterlength, int *err) {

  return mysofa_open_default(filename, samplerate, filterlength, err, true,
                             MYSOFA_DEFAULT_NEIGH_STEP_ANGLE,
                             MYSOFA_DEFAULT_NEIGH_STEP_RADIUS);
@@ -91,7 +106,8 @@ MYSOFA_EXPORT struct MYSOFA_EASY *mysofa_open(const char *filename,
MYSOFA_EXPORT struct MYSOFA_EASY *mysofa_open_no_norm(const char *filename,
                                                      float samplerate,
                                                      int *filterlength,
                                                      int *err) {

  return mysofa_open_default(filename, samplerate, filterlength, err, false,
                             MYSOFA_DEFAULT_NEIGH_STEP_ANGLE,
                             MYSOFA_DEFAULT_NEIGH_STEP_RADIUS);
@@ -100,22 +116,26 @@ MYSOFA_EXPORT struct MYSOFA_EASY *mysofa_open_no_norm(const char *filename,
MYSOFA_EXPORT struct MYSOFA_EASY *
mysofa_open_advanced(const char *filename, float samplerate, int *filterlength,
                     int *err, bool norm, float neighbor_angle_step,
                     float neighbor_radius_step) {

  return mysofa_open_default(filename, samplerate, filterlength, err, norm,
                             neighbor_angle_step, neighbor_radius_step);
}

MYSOFA_EXPORT struct MYSOFA_EASY *mysofa_open_cached(const char *filename,
                                                     float samplerate,
                                                     int *filterlength,
                                                     int *err) {

  struct MYSOFA_EASY *res = mysofa_cache_lookup(filename, samplerate);
  if (res) {

    *filterlength = res->hrtf->N;
    return res;
  }
  res = mysofa_open(filename, samplerate, filterlength, err);
  if (res) {

    res = mysofa_cache_store(res, filename, samplerate);
  }
  return res;
@@ -124,7 +144,8 @@ MYSOFA_EXPORT struct MYSOFA_EASY *mysofa_open_cached(const char *filename,
MYSOFA_EXPORT void mysofa_getfilter_short(struct MYSOFA_EASY *easy, float x,
                                          float y, float z, short *IRleft,
                                          short *IRright, int *delayLeft,
                                          int *delayRight) {

  float c[3];
  float delays[2];
  float *fl;
@@ -147,15 +168,17 @@ MYSOFA_EXPORT void mysofa_getfilter_short(struct MYSOFA_EASY *easy, float x,

  fl = easy->fir;
  fr = easy->fir + easy->hrtf->N;
  for (i = easy->hrtf->N; i > 0; i--) {

    *IRleft++ = (short)(*fl++ * 32767.);
    *IRright++ = (short)(*fr++ * 32767.);
  }
}

MYSOFA_EXPORT void mysofa_getfilter_float_advanced(
    struct MYSOFA_EASY *easy, float x, float y, float z, float *IRleft,
    float *IRright, float *delayLeft, float *delayRight, bool interpolate) {

  float c[3];
  float delays[2];
  float *fl;
@@ -172,7 +195,8 @@ MYSOFA_EXPORT void mysofa_getfilter_float_advanced(
  neighbors = mysofa_neighborhood(easy->neighborhood, nearest);

  // bypass interpolate by forcing current cooordinates to nearest's
  if (!interpolate) {

    memcpy(c, easy->hrtf->SourcePosition.values + nearest * easy->hrtf->C,
           sizeof(float) * easy->hrtf->C);
  }
@@ -185,7 +209,8 @@ MYSOFA_EXPORT void mysofa_getfilter_float_advanced(

  fl = res;
  fr = res + easy->hrtf->N;
  for (i = easy->hrtf->N; i > 0; i--) {

    *IRleft++ = *fl++;
    *IRright++ = *fr++;
  }
@@ -194,21 +219,25 @@ MYSOFA_EXPORT void mysofa_getfilter_float_advanced(
MYSOFA_EXPORT void mysofa_getfilter_float(struct MYSOFA_EASY *easy, float x,
                                          float y, float z, float *IRleft,
                                          float *IRright, float *delayLeft,
                                          float *delayRight) {

  mysofa_getfilter_float_advanced(easy, x, y, z, IRleft, IRright, delayLeft,
                                  delayRight, true);
}

MYSOFA_EXPORT void
mysofa_getfilter_float_nointerp(struct MYSOFA_EASY *easy, float x, float y,
                                float z, float *IRleft, float *IRright,
                                float *delayLeft, float *delayRight) {

  mysofa_getfilter_float_advanced(easy, x, y, z, IRleft, IRright, delayLeft,
                                  delayRight, false);
}

MYSOFA_EXPORT void mysofa_close(struct MYSOFA_EASY *easy) {
  if (easy) {


    if (easy->fir)
      free(easy->fir);
    if (easy->neighborhood)
@@ -221,6 +250,7 @@ MYSOFA_EXPORT void mysofa_close(struct MYSOFA_EASY *easy) {
  }
}

MYSOFA_EXPORT void mysofa_close_cached(struct MYSOFA_EASY *easy) {

  mysofa_cache_release(easy);
}
@@ -16,7 +16,8 @@
#include ""tools.h""

MYSOFA_EXPORT struct MYSOFA_LOOKUP *
mysofa_lookup_init(struct MYSOFA_HRTF *hrtf) {

  int i;
  struct MYSOFA_LOOKUP *lookup;

@@ -42,26 +43,33 @@ mysofa_lookup_init(struct MYSOFA_HRTF *hrtf) {
  lookup->theta_max = FLT_MIN;
  lookup->radius_min = FLT_MAX;
  lookup->radius_max = FLT_MIN;
  for (i = 0; i < hrtf->M; i++) {

    memcpy(origin, hrtf->SourcePosition.values + i * hrtf->C,
           sizeof(float) * hrtf->C);
    convertCartesianToSpherical(origin, hrtf->C);
    if (origin[0] < lookup->phi_min) {

      lookup->phi_min = origin[0];
    }
    if (origin[0] > lookup->phi_max) {

      lookup->phi_max = origin[0];
    }
    if (origin[1] < lookup->theta_min) {

      lookup->theta_min = origin[1];
    }
    if (origin[1] > lookup->theta_max) {

      lookup->theta_max = origin[1];
    }
    if (origin[2] < lookup->radius_min) {

      lookup->radius_min = origin[2];
    }
    if (origin[2] > lookup->radius_max) {

      lookup->radius_max = origin[2];
    }
  }
@@ -71,15 +79,17 @@ mysofa_lookup_init(struct MYSOFA_HRTF *hrtf) {
   * Allocate kd tree
   */
  lookup->kdtree = kd_create();
  if (!lookup->kdtree) {

    free(lookup);
    return NULL;
  }

  /*
   * add coordinates to the tree
   */
  for (i = 0; i < hrtf->M; i++) {

    float *f = hrtf->SourcePosition.values + i * hrtf->C;
    kd_insert((struct kdtree *)lookup->kdtree, f, (void *)(intptr_t)i);
  }
@@ -93,34 +103,41 @@ mysofa_lookup_init(struct MYSOFA_HRTF *hrtf) {
 * A return value of -1 = MYSOFA_INTERNAL_ERROR indicates an error
 */
MYSOFA_EXPORT int mysofa_lookup(struct MYSOFA_LOOKUP *lookup,
                                float *coordinate) {


  int index;
  void *res;
  int success;
  float r = radius(coordinate);
  if (r > lookup->radius_max) {

    r = lookup->radius_max / r;
    coordinate[0] *= r;
    coordinate[1] *= r;
    coordinate[2] *= r;
  } else if (r < lookup->radius_min) {


    r = lookup->radius_min / r;
    coordinate[0] *= r;
    coordinate[1] *= r;
    coordinate[2] *= r;
  }

  success = kd_nearest((struct kdtree *)lookup->kdtree, coordinate, &res);
  if (success != 0) {

    return MYSOFA_INTERNAL_ERROR;
  }
  index = (uintptr_t)res;
  return index;
}

MYSOFA_EXPORT void mysofa_lookup_free(struct MYSOFA_LOOKUP *lookup) {
  if (lookup) {


    kd_free((struct kdtree *)lookup->kdtree);
    free(lookup);
  }

@@ -15,7 +15,8 @@









@@ -24,7 +25,7 @@ MYSOFA_EXPORT int mysofa_resample(struct MYSOFA_HRTF *hrtf, float samplerate) {








@@ -36,20 +37,21 @@ MYSOFA_EXPORT int mysofa_resample(struct MYSOFA_HRTF *hrtf, float samplerate) {

























@@ -58,15 +60,16 @@ MYSOFA_EXPORT int mysofa_resample(struct MYSOFA_HRTF *hrtf, float samplerate) {




























","4
CMakeLists.txt
@@ -84,7 +84,9 @@ if(BUILD_TESTS)
    137
    138
    156
    163)
    163
    167a
    167b)
    # issues with osx    96)
    add_test(fail-issue-${ISSUE} ${PROJECT_SOURCE_DIR}/tests/notcrashed.sh
             ${PROJECT_SOURCE_DIR}/tests/fail-issue-${ISSUE})
76
src/hrtf/easy.c
@@ -21,11 +21,13 @@
static struct MYSOFA_EASY *
mysofa_open_default(const char *filename, float samplerate, int *filterlength,
                    int *err, bool applyNorm, float neighbor_angle_step,
                    float neighbor_radius_step) {
                    float neighbor_radius_step)
{

  struct MYSOFA_EASY *easy = malloc(sizeof(struct MYSOFA_EASY));

  if (!easy) {
  if (!easy)
  {
    *err = MYSOFA_NO_MEMORY;
    return NULL;
  }
@@ -35,24 +37,28 @@ mysofa_open_default(const char *filename, float samplerate, int *filterlength,
  *easy = (struct MYSOFA_EASY){0};

  easy->hrtf = mysofa_load(filename, err);
  if (!easy->hrtf) {
  if (!easy->hrtf)
  {
    mysofa_close(easy);
    return NULL;
  }

  *err = mysofa_check(easy->hrtf);
  if (*err != MYSOFA_OK) {
  if (*err != MYSOFA_OK)
  {
    mysofa_close(easy);
    return NULL;
  }

  *err = mysofa_resample(easy->hrtf, samplerate);
  if (*err != MYSOFA_OK) {
  if (*err != MYSOFA_OK)
  {
    mysofa_close(easy);
    return NULL;
  }

  if (applyNorm) {
  if (applyNorm)
  {
    mysofa_loudness(easy->hrtf);
  }

@@ -62,8 +68,16 @@ mysofa_open_default(const char *filename, float samplerate, int *filterlength,

  mysofa_tocartesian(easy->hrtf);

  if (easy->hrtf->SourcePosition.elements != easy->hrtf->C * easy->hrtf->M)
  {
    *err = MYSOFA_INVALID_FORMAT;
    mysofa_close(easy);
    return NULL;
  }

  easy->lookup = mysofa_lookup_init(easy->hrtf);
  if (easy->lookup == NULL) {
  if (easy->lookup == NULL)
  {
    *err = MYSOFA_INTERNAL_ERROR;
    mysofa_close(easy);
    return NULL;
@@ -82,7 +96,8 @@ mysofa_open_default(const char *filename, float samplerate, int *filterlength,

MYSOFA_EXPORT struct MYSOFA_EASY *mysofa_open(const char *filename,
                                              float samplerate,
                                              int *filterlength, int *err) {
                                              int *filterlength, int *err)
{
  return mysofa_open_default(filename, samplerate, filterlength, err, true,
                             MYSOFA_DEFAULT_NEIGH_STEP_ANGLE,
                             MYSOFA_DEFAULT_NEIGH_STEP_RADIUS);
@@ -91,7 +106,8 @@ MYSOFA_EXPORT struct MYSOFA_EASY *mysofa_open(const char *filename,
MYSOFA_EXPORT struct MYSOFA_EASY *mysofa_open_no_norm(const char *filename,
                                                      float samplerate,
                                                      int *filterlength,
                                                      int *err) {
                                                      int *err)
{
  return mysofa_open_default(filename, samplerate, filterlength, err, false,
                             MYSOFA_DEFAULT_NEIGH_STEP_ANGLE,
                             MYSOFA_DEFAULT_NEIGH_STEP_RADIUS);
@@ -100,22 +116,26 @@ MYSOFA_EXPORT struct MYSOFA_EASY *mysofa_open_no_norm(const char *filename,
MYSOFA_EXPORT struct MYSOFA_EASY *
mysofa_open_advanced(const char *filename, float samplerate, int *filterlength,
                     int *err, bool norm, float neighbor_angle_step,
                     float neighbor_radius_step) {
                     float neighbor_radius_step)
{
  return mysofa_open_default(filename, samplerate, filterlength, err, norm,
                             neighbor_angle_step, neighbor_radius_step);
}

MYSOFA_EXPORT struct MYSOFA_EASY *mysofa_open_cached(const char *filename,
                                                     float samplerate,
                                                     int *filterlength,
                                                     int *err) {
                                                     int *err)
{
  struct MYSOFA_EASY *res = mysofa_cache_lookup(filename, samplerate);
  if (res) {
  if (res)
  {
    *filterlength = res->hrtf->N;
    return res;
  }
  res = mysofa_open(filename, samplerate, filterlength, err);
  if (res) {
  if (res)
  {
    res = mysofa_cache_store(res, filename, samplerate);
  }
  return res;
@@ -124,7 +144,8 @@ MYSOFA_EXPORT struct MYSOFA_EASY *mysofa_open_cached(const char *filename,
MYSOFA_EXPORT void mysofa_getfilter_short(struct MYSOFA_EASY *easy, float x,
                                          float y, float z, short *IRleft,
                                          short *IRright, int *delayLeft,
                                          int *delayRight) {
                                          int *delayRight)
{
  float c[3];
  float delays[2];
  float *fl;
@@ -147,15 +168,17 @@ MYSOFA_EXPORT void mysofa_getfilter_short(struct MYSOFA_EASY *easy, float x,

  fl = easy->fir;
  fr = easy->fir + easy->hrtf->N;
  for (i = easy->hrtf->N; i > 0; i--) {
  for (i = easy->hrtf->N; i > 0; i--)
  {
    *IRleft++ = (short)(*fl++ * 32767.);
    *IRright++ = (short)(*fr++ * 32767.);
  }
}

MYSOFA_EXPORT void mysofa_getfilter_float_advanced(
    struct MYSOFA_EASY *easy, float x, float y, float z, float *IRleft,
    float *IRright, float *delayLeft, float *delayRight, bool interpolate) {
    float *IRright, float *delayLeft, float *delayRight, bool interpolate)
{
  float c[3];
  float delays[2];
  float *fl;
@@ -172,7 +195,8 @@ MYSOFA_EXPORT void mysofa_getfilter_float_advanced(
  neighbors = mysofa_neighborhood(easy->neighborhood, nearest);

  // bypass interpolate by forcing current cooordinates to nearest's
  if (!interpolate) {
  if (!interpolate)
  {
    memcpy(c, easy->hrtf->SourcePosition.values + nearest * easy->hrtf->C,
           sizeof(float) * easy->hrtf->C);
  }
@@ -185,7 +209,8 @@ MYSOFA_EXPORT void mysofa_getfilter_float_advanced(

  fl = res;
  fr = res + easy->hrtf->N;
  for (i = easy->hrtf->N; i > 0; i--) {
  for (i = easy->hrtf->N; i > 0; i--)
  {
    *IRleft++ = *fl++;
    *IRright++ = *fr++;
  }
@@ -194,21 +219,25 @@ MYSOFA_EXPORT void mysofa_getfilter_float_advanced(
MYSOFA_EXPORT void mysofa_getfilter_float(struct MYSOFA_EASY *easy, float x,
                                          float y, float z, float *IRleft,
                                          float *IRright, float *delayLeft,
                                          float *delayRight) {
                                          float *delayRight)
{
  mysofa_getfilter_float_advanced(easy, x, y, z, IRleft, IRright, delayLeft,
                                  delayRight, true);
}

MYSOFA_EXPORT void
mysofa_getfilter_float_nointerp(struct MYSOFA_EASY *easy, float x, float y,
                                float z, float *IRleft, float *IRright,
                                float *delayLeft, float *delayRight) {
                                float *delayLeft, float *delayRight)
{
  mysofa_getfilter_float_advanced(easy, x, y, z, IRleft, IRright, delayLeft,
                                  delayRight, false);
}

MYSOFA_EXPORT void mysofa_close(struct MYSOFA_EASY *easy) {
  if (easy) {
MYSOFA_EXPORT void mysofa_close(struct MYSOFA_EASY *easy)
{
  if (easy)
  {
    if (easy->fir)
      free(easy->fir);
    if (easy->neighborhood)
@@ -221,6 +250,7 @@ MYSOFA_EXPORT void mysofa_close(struct MYSOFA_EASY *easy) {
  }
}

MYSOFA_EXPORT void mysofa_close_cached(struct MYSOFA_EASY *easy) {
MYSOFA_EXPORT void mysofa_close_cached(struct MYSOFA_EASY *easy)
{
  mysofa_cache_release(easy);
}
49
src/hrtf/lookup.c
@@ -16,7 +16,8 @@
#include ""tools.h""

MYSOFA_EXPORT struct MYSOFA_LOOKUP *
mysofa_lookup_init(struct MYSOFA_HRTF *hrtf) {
mysofa_lookup_init(struct MYSOFA_HRTF *hrtf)
{
  int i;
  struct MYSOFA_LOOKUP *lookup;

@@ -42,26 +43,33 @@ mysofa_lookup_init(struct MYSOFA_HRTF *hrtf) {
  lookup->theta_max = FLT_MIN;
  lookup->radius_min = FLT_MAX;
  lookup->radius_max = FLT_MIN;
  for (i = 0; i < hrtf->M; i++) {
  for (i = 0; i < hrtf->M; i++)
  {
    memcpy(origin, hrtf->SourcePosition.values + i * hrtf->C,
           sizeof(float) * hrtf->C);
    convertCartesianToSpherical(origin, hrtf->C);
    if (origin[0] < lookup->phi_min) {
    if (origin[0] < lookup->phi_min)
    {
      lookup->phi_min = origin[0];
    }
    if (origin[0] > lookup->phi_max) {
    if (origin[0] > lookup->phi_max)
    {
      lookup->phi_max = origin[0];
    }
    if (origin[1] < lookup->theta_min) {
    if (origin[1] < lookup->theta_min)
    {
      lookup->theta_min = origin[1];
    }
    if (origin[1] > lookup->theta_max) {
    if (origin[1] > lookup->theta_max)
    {
      lookup->theta_max = origin[1];
    }
    if (origin[2] < lookup->radius_min) {
    if (origin[2] < lookup->radius_min)
    {
      lookup->radius_min = origin[2];
    }
    if (origin[2] > lookup->radius_max) {
    if (origin[2] > lookup->radius_max)
    {
      lookup->radius_max = origin[2];
    }
  }
@@ -71,15 +79,17 @@ mysofa_lookup_init(struct MYSOFA_HRTF *hrtf) {
   * Allocate kd tree
   */
  lookup->kdtree = kd_create();
  if (!lookup->kdtree) {
  if (!lookup->kdtree)
  {
    free(lookup);
    return NULL;
  }

  /*
   * add coordinates to the tree
   */
  for (i = 0; i < hrtf->M; i++) {
  for (i = 0; i < hrtf->M; i++)
  {
    float *f = hrtf->SourcePosition.values + i * hrtf->C;
    kd_insert((struct kdtree *)lookup->kdtree, f, (void *)(intptr_t)i);
  }
@@ -93,34 +103,41 @@ mysofa_lookup_init(struct MYSOFA_HRTF *hrtf) {
 * A return value of -1 = MYSOFA_INTERNAL_ERROR indicates an error
 */
MYSOFA_EXPORT int mysofa_lookup(struct MYSOFA_LOOKUP *lookup,
                                float *coordinate) {
                                float *coordinate)
{

  int index;
  void *res;
  int success;
  float r = radius(coordinate);
  if (r > lookup->radius_max) {
  if (r > lookup->radius_max)
  {
    r = lookup->radius_max / r;
    coordinate[0] *= r;
    coordinate[1] *= r;
    coordinate[2] *= r;
  } else if (r < lookup->radius_min) {
  }
  else if (r < lookup->radius_min)
  {
    r = lookup->radius_min / r;
    coordinate[0] *= r;
    coordinate[1] *= r;
    coordinate[2] *= r;
  }

  success = kd_nearest((struct kdtree *)lookup->kdtree, coordinate, &res);
  if (success != 0) {
  if (success != 0)
  {
    return MYSOFA_INTERNAL_ERROR;
  }
  index = (uintptr_t)res;
  return index;
}

MYSOFA_EXPORT void mysofa_lookup_free(struct MYSOFA_LOOKUP *lookup) {
  if (lookup) {
MYSOFA_EXPORT void mysofa_lookup_free(struct MYSOFA_LOOKUP *lookup)
{
  if (lookup)
  {
    kd_free((struct kdtree *)lookup->kdtree);
    free(lookup);
  }"
https://huntr.dev/bounties/eb8b8a1e-8520-4231-aaac-6521061104cf/,NULL Pointer Dereference in mruby/mruby,NULL Pointer Dereference on mrb_full_gc,,CWE-476: NULL Pointer Dereference,https://www.github.com/mruby/mruby/commit/bec074e6a31fd7a577e2c0e726167da8dc44c4c6,"@@ -39,9 +39,9 @@ void abort(void);
#define MRB_STACK_GROWTH 128
#endif

/* Maximum mrb_funcall() depth. Should be set lower on memory constrained systems. */
#ifndef MRB_FUNCALL_DEPTH_MAX
#define MRB_FUNCALL_DEPTH_MAX 512
#endif

/* Maximum stack depth. Should be set lower on memory constrained systems.
@@ -251,6 +251,9 @@ cipush(mrb_state *mrb, mrb_int push_stacks, uint8_t cci,
  if (ci + 1 == c->ciend) {
    ptrdiff_t size = ci - c->cibase;




    c->cibase = (mrb_callinfo *)mrb_realloc(mrb, c->cibase, sizeof(mrb_callinfo)*size*2);
    c->ci = c->cibase + size;
    c->ciend = c->cibase + size * 2;
@@ -464,9 +467,6 @@ mrb_funcall_with_block(mrb_state *mrb, mrb_value self, mrb_sym mid, mrb_int argc
      mrb->c->ci->stack[n+1] = args;
      argc = -1;
    }
    if (mrb->c->ci - mrb->c->cibase > MRB_FUNCALL_DEPTH_MAX) {
      mrb_exc_raise(mrb, mrb_obj_value(mrb->stack_err));
    }
    ci = cipush(mrb, n, 0, c, NULL, mid, argc);
    if (argc < 0) argc = 1;
    if (mrb->c->stbase <= argv && argv < mrb->c->stend) {
@@ -740,9 +740,6 @@ mrb_yield_with_class(mrb_state *mrb, mrb_value b, mrb_int argc, const mrb_value
  }
  ci = mrb->c->ci;
  n = ci_nregs(ci);
  if (ci - mrb->c->cibase > MRB_FUNCALL_DEPTH_MAX) {
    mrb_exc_raise(mrb, mrb_obj_value(mrb->stack_err));
  }
  p = mrb_proc_ptr(b);
  ci = cipush(mrb, n, CINFO_SKIP, c, p, mid, 0 /* dummy */);
  if (argc >= CALL_MAXARGS) {

","15
src/vm.c
@@ -39,9 +39,9 @@ void abort(void);
#define MRB_STACK_GROWTH 128
#endif

/* Maximum mrb_funcall() depth. Should be set lower on memory constrained systems. */
#ifndef MRB_FUNCALL_DEPTH_MAX
#define MRB_FUNCALL_DEPTH_MAX 512
/* Maximum recursive depth. Should be set lower on memory constrained systems. */
#ifndef MRB_CALL_LEVEL_MAX
#define MRB_CALL_LEVEL_MAX 512
#endif

/* Maximum stack depth. Should be set lower on memory constrained systems.
@@ -251,6 +251,9 @@ cipush(mrb_state *mrb, mrb_int push_stacks, uint8_t cci,
  if (ci + 1 == c->ciend) {
    ptrdiff_t size = ci - c->cibase;

    if (size > MRB_CALL_LEVEL_MAX) {
      mrb_exc_raise(mrb, mrb_obj_value(mrb->stack_err));
    }
    c->cibase = (mrb_callinfo *)mrb_realloc(mrb, c->cibase, sizeof(mrb_callinfo)*size*2);
    c->ci = c->cibase + size;
    c->ciend = c->cibase + size * 2;
@@ -464,9 +467,6 @@ mrb_funcall_with_block(mrb_state *mrb, mrb_value self, mrb_sym mid, mrb_int argc
      mrb->c->ci->stack[n+1] = args;
      argc = -1;
    }
    if (mrb->c->ci - mrb->c->cibase > MRB_FUNCALL_DEPTH_MAX) {
      mrb_exc_raise(mrb, mrb_obj_value(mrb->stack_err));
    }
    ci = cipush(mrb, n, 0, c, NULL, mid, argc);
    if (argc < 0) argc = 1;
    if (mrb->c->stbase <= argv && argv < mrb->c->stend) {
@@ -740,9 +740,6 @@ mrb_yield_with_class(mrb_state *mrb, mrb_value b, mrb_int argc, const mrb_value
  }
  ci = mrb->c->ci;
  n = ci_nregs(ci);
  if (ci - mrb->c->cibase > MRB_FUNCALL_DEPTH_MAX) {
    mrb_exc_raise(mrb, mrb_obj_value(mrb->stack_err));
  }
  p = mrb_proc_ptr(b);
  ci = cipush(mrb, n, CINFO_SKIP, c, p, mid, 0 /* dummy */);
  if (argc >= CALL_MAXARGS) {"
https://huntr.dev/bounties/7ca8d9ea-e2a6-4294-af28-70260bb53bc1/,Heap-based Buffer Overflow in hoene/libmysofa,"There are some heap-buffer-overflows in mysofa2json of libmysofa. They are in function loudness, mysofa_check and readOHDRHeaderMessageDataLayout.",CVE-2021-3756,CWE-122: Heap-based Buffer Overflow,https://www.github.com/hoene/libmysofa/commit/890400ebd092c574707d0c132124f8ff047e20e1,"@@ -500,14 +500,17 @@ static int readOHDRHeaderMessageDataLayout(struct READER *reader,
      store = ftell(reader->fhd);
      if (fseek(reader->fhd, data_address, SEEK_SET) < 0)
        return errno; // LCOV_EXCL_LINE
      if (!data->data) {
        if (data_size > 0x10000000)
          return MYSOFA_INVALID_FORMAT;
        data->data_len = data_size;
        data->data = calloc(1, data_size);
        if (!data->data)
          return MYSOFA_NO_MEMORY; // LCOV_EXCL_LINE
      }







      err = fread(data->data, 1, data_size, reader->fhd);
      if (err != data_size)
        return MYSOFA_READ_ERROR; // LCOV_EXCL_LINE

","17
src/hdf/dataobject.c
@@ -500,14 +500,17 @@ static int readOHDRHeaderMessageDataLayout(struct READER *reader,
      store = ftell(reader->fhd);
      if (fseek(reader->fhd, data_address, SEEK_SET) < 0)
        return errno; // LCOV_EXCL_LINE
      if (!data->data) {
        if (data_size > 0x10000000)
          return MYSOFA_INVALID_FORMAT;
        data->data_len = data_size;
        data->data = calloc(1, data_size);
        if (!data->data)
          return MYSOFA_NO_MEMORY; // LCOV_EXCL_LINE
      if (data->data) {
        free(data->data);
        data->data = NULL;
      }
      if (data_size > 0x10000000)
        return MYSOFA_INVALID_FORMAT;
      data->data_len = data_size;
      data->data = calloc(1, data_size);
      if (!data->data)
        return MYSOFA_NO_MEMORY; // LCOV_EXCL_LINE

      err = fread(data->data, 1, data_size, reader->fhd);
      if (err != data_size)
        return MYSOFA_READ_ERROR; // LCOV_EXCL_LINE"
https://huntr.dev/bounties/e5199ee4-09b8-4346-a25c-e19b5cfc277b/,Stack-based Buffer Overflow in gwsw/less,"The less utility is a pager used by many applications and setups. One such setup is access to log files. If permissions are not sufficient for regular users, less can be called with sudo. LESSSECURE=1 can be set to disable many dangerous operations which a regular user should not be able to run while having root privileges. Also less can be compiled with many features disabled to further reduce the possible attack vector.",,CWE-121: Stack-based Buffer Overflow,https://www.github.com/gwsw/less/commit/6a860ee977eea7bfa065789ea4319ecab5af703c,"@@ -723,7 +723,7 @@ opt_x(type, s)
 extern int tabstops[];
 extern int ntabstops;
 extern int tabdefault;
 char msg[60+(4*TABSTOP_MAX)];
 int i;
 PARG p;


","2
optfunc.c
@@ -723,7 +723,7 @@ opt_x(type, s)
 extern int tabstops[];
 extern int ntabstops;
 extern int tabdefault;
 char msg[60+(4*TABSTOP_MAX)];
 char msg[60+((INT_STRLEN_BOUND(int)+1)*TABSTOP_MAX)];
 int i;
 PARG p;"
https://huntr.dev/bounties/c8f69ac0-84b0-4b72-ae74-8971b33a5139/,Heap-based Buffer Overflow in mruby/mruby,Heap buffer overflow on mrb-vm-exec,,CWE-122: Heap-based Buffer Overflow,https://www.github.com/mruby/mruby/commit/368e8ce3d5fc117081316aefa25a40b3b1f7a5a9,"@@ -2263,11 +2263,6 @@ codegen(codegen_scope *s, node *tree, int val)
  case NODE_WHILE:
  case NODE_UNTIL:
    {
      struct loopinfo *lp = loop_push(s, LOOP_NORMAL);
      uint32_t pos = JMPLINK_START;

      if (!val) lp->reg = -1;
      lp->pc0 = new_label(s);
      if (true_always(tree->car)) {
        if (nt == NODE_UNTIL) {
          if (val) {
@@ -2286,6 +2281,12 @@ codegen(codegen_scope *s, node *tree, int val)
          goto exit;
        }
      }






      codegen(s, tree->car, VAL);
      pop();
      if (nt == NODE_WHILE) {

","11
mrbgems/mruby-compiler/core/codegen.c
@@ -2263,11 +2263,6 @@ codegen(codegen_scope *s, node *tree, int val)
  case NODE_WHILE:
  case NODE_UNTIL:
    {
      struct loopinfo *lp = loop_push(s, LOOP_NORMAL);
      uint32_t pos = JMPLINK_START;

      if (!val) lp->reg = -1;
      lp->pc0 = new_label(s);
      if (true_always(tree->car)) {
        if (nt == NODE_UNTIL) {
          if (val) {
@@ -2286,6 +2281,12 @@ codegen(codegen_scope *s, node *tree, int val)
          goto exit;
        }
      }

      uint32_t pos = JMPLINK_START;
      struct loopinfo *lp = loop_push(s, LOOP_NORMAL);

      if (!val) lp->reg = -1;
      lp->pc0 = new_label(s);
      codegen(s, tree->car, VAL);
      pop();
      if (nt == NODE_WHILE) {"
https://huntr.dev/bounties/374927df-59b2-4758-a04d-5e22c2f1a13a/,NULL Pointer Dereference in mruby/mruby,NULL Pointer Dereference on ea_set,,CWE-476: NULL Pointer Dereference,https://www.github.com/mruby/mruby/commit/c70159b3562e09a37577b4c6913de3ec7b8f06b4,"@@ -2687,7 +2687,7 @@ mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)
      int lim = a+b*2+1;

      hash = regs[a];
      mrb_assert(mrb_type(hash) == MRB_TT_HASH);
      for (i=a+1; i<lim; i+=2) {
        mrb_hash_set(mrb, hash, regs[i], regs[i+1]);
      }
@@ -2697,7 +2697,7 @@ mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)
    CASE(OP_HASHCAT, B) {
      mrb_value hash = regs[a];

      mrb_assert(mrb_type(hash) == MRB_TT_HASH);
      mrb_hash_merge(mrb, hash, regs[a+1]);
      mrb_gc_arena_restore(mrb, ai);
      NEXT;

","4
src/vm.c
@@ -2687,7 +2687,7 @@ mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)
      int lim = a+b*2+1;

      hash = regs[a];
      mrb_assert(mrb_type(hash) == MRB_TT_HASH);
      mrb_ensure_hash_type(mrb, hash);
      for (i=a+1; i<lim; i+=2) {
        mrb_hash_set(mrb, hash, regs[i], regs[i+1]);
      }
@@ -2697,7 +2697,7 @@ mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)
    CASE(OP_HASHCAT, B) {
      mrb_value hash = regs[a];

      mrb_assert(mrb_type(hash) == MRB_TT_HASH);
      mrb_ensure_hash_type(mrb, hash);
      mrb_hash_merge(mrb, hash, regs[a+1]);
      mrb_gc_arena_restore(mrb, ai);
      NEXT;"
https://huntr.dev/bounties/4458e0b9-0ad3-4036-a032-1b3c4705b889/,Heap-based Buffer Overflow in mruby/mruby,Heap buffer overflow in mruby,,CWE-122: Heap-based Buffer Overflow,https://www.github.com/mruby/mruby/commit/a844f8965584c0737c436cfaf98bdccdf8d8b39e,"@@ -1136,6 +1136,7 @@ gen_int(codegen_scope *s, uint16_t dst, mrb_int i)
static mrb_bool
gen_uniop(codegen_scope *s, mrb_sym sym, uint16_t dst)
{

  struct mrb_insn_data data = mrb_last_insn(s);
  mrb_int n;


","1
mrbgems/mruby-compiler/core/codegen.c
@@ -1136,6 +1136,7 @@ gen_int(codegen_scope *s, uint16_t dst, mrb_int i)
static mrb_bool
gen_uniop(codegen_scope *s, mrb_sym sym, uint16_t dst)
{
  if (no_peephole(s)) return FALSE;
  struct mrb_insn_data data = mrb_last_insn(s);
  mrb_int n;"
https://huntr.dev/bounties/efb3e261-3f7d-4a45-8114-e0ace6b21516/,Use of Out-of-range Pointer Offset in bfabiszewski/libmobi,Overview,CVE-2021-3889,CWE-823: Use of Out-of-range Pointer Offset,https://www.github.com/bfabiszewski/libmobi/commit/bec783e6212439a335ba6e8df7ab8ed610ca9a21,"@@ -141,7 +141,10 @@ static MOBI_RET mobi_decompress_huffman_internal(MOBIBuffer *buf_out, MOBIBuffer
        if (!(t1 & 0x80)) {
            /* get offset from mincode, maxcode tables */
            while (code < huffcdic->mincode_table[code_length]) {
                code_length++;



            }
            maxcode = huffcdic->maxcode_table[code_length];
        }

@@ -20,6 +20,7 @@

/* FIXME: what is the reasonable value? */
#define MOBI_HUFFMAN_MAXDEPTH 20 /**< Maximal recursion level for huffman decompression routine */



/**
@@ -30,8 +31,8 @@ typedef struct {
    size_t index_read; /**< Number of indices parsed, used by parser */
    size_t code_length; /**< Code length value stored in CDIC record header */
    uint32_t table1[256]; /**< Table of big-endian indices from HUFF record data1 */
    uint32_t mincode_table[33]; /**< Table of big-endian mincodes from HUFF record data2 */
    uint32_t maxcode_table[33]; /**< Table of big-endian maxcodes from HUFF record data2 */
    uint16_t *symbol_offsets; /**< Index of symbol offsets parsed from CDIC records (index_count entries) */
    unsigned char **symbols; /**< Array of pointers to start of symbols data in each CDIC record (index = number of CDIC record) */
} MOBIHuffCdic;

@@ -589,7 +589,7 @@ MOBI_RET mobi_parse_huff(MOBIHuffCdic *huffcdic, const MOBIPdbRecord *record) {
    /* read 32 mincode-maxcode pairs from data2 big-endian */
    huffcdic->mincode_table[0] = 0;
    huffcdic->maxcode_table[0] = 0xFFFFFFFF;
    for (int i = 1; i < 33; i++) {
        const uint32_t mincode = mobi_buffer_get32(buf);
        const uint32_t maxcode = mobi_buffer_get32(buf);
        huffcdic->mincode_table[i] =  mincode << (32 - i);

","5
src/compression.c
@@ -141,7 +141,10 @@ static MOBI_RET mobi_decompress_huffman_internal(MOBIBuffer *buf_out, MOBIBuffer
        if (!(t1 & 0x80)) {
            /* get offset from mincode, maxcode tables */
            while (code < huffcdic->mincode_table[code_length]) {
                code_length++;
                if (++code_length >= HUFF_CODETABLE_SIZE) {
                    debug_print(""Wrong offset to mincode table: %hhu\n"", code_length);
                    return MOBI_DATA_CORRUPT;
                }
            }
            maxcode = huffcdic->maxcode_table[code_length];
        }
5
src/compression.h
@@ -20,6 +20,7 @@

/* FIXME: what is the reasonable value? */
#define MOBI_HUFFMAN_MAXDEPTH 20 /**< Maximal recursion level for huffman decompression routine */
#define HUFF_CODETABLE_SIZE 33 /**< Size of min- and maxcode tables */


/**
@@ -30,8 +31,8 @@ typedef struct {
    size_t index_read; /**< Number of indices parsed, used by parser */
    size_t code_length; /**< Code length value stored in CDIC record header */
    uint32_t table1[256]; /**< Table of big-endian indices from HUFF record data1 */
    uint32_t mincode_table[33]; /**< Table of big-endian mincodes from HUFF record data2 */
    uint32_t maxcode_table[33]; /**< Table of big-endian maxcodes from HUFF record data2 */
    uint32_t mincode_table[HUFF_CODETABLE_SIZE]; /**< Table of big-endian mincodes from HUFF record data2 */
    uint32_t maxcode_table[HUFF_CODETABLE_SIZE]; /**< Table of big-endian maxcodes from HUFF record data2 */
    uint16_t *symbol_offsets; /**< Index of symbol offsets parsed from CDIC records (index_count entries) */
    unsigned char **symbols; /**< Array of pointers to start of symbols data in each CDIC record (index = number of CDIC record) */
} MOBIHuffCdic;
2
src/read.c
@@ -589,7 +589,7 @@ MOBI_RET mobi_parse_huff(MOBIHuffCdic *huffcdic, const MOBIPdbRecord *record) {
    /* read 32 mincode-maxcode pairs from data2 big-endian */
    huffcdic->mincode_table[0] = 0;
    huffcdic->maxcode_table[0] = 0xFFFFFFFF;
    for (int i = 1; i < 33; i++) {
    for (int i = 1; i < HUFF_CODETABLE_SIZE; i++) {
        const uint32_t mincode = mobi_buffer_get32(buf);
        const uint32_t maxcode = mobi_buffer_get32(buf);
        huffcdic->mincode_table[i] =  mincode << (32 - i);"
https://huntr.dev/bounties/540fd115-7de4-4e19-a918-5ee61f5157c1/,Out-of-bounds Read in bfabiszewski/libmobi,Overview,CVE-2021-3881,CWE-125: Out-of-bounds Read,https://www.github.com/bfabiszewski/libmobi/commit/bec783e6212439a335ba6e8df7ab8ed610ca9a21,"@@ -141,7 +141,10 @@ static MOBI_RET mobi_decompress_huffman_internal(MOBIBuffer *buf_out, MOBIBuffer
        if (!(t1 & 0x80)) {
            /* get offset from mincode, maxcode tables */
            while (code < huffcdic->mincode_table[code_length]) {
                code_length++;



            }
            maxcode = huffcdic->maxcode_table[code_length];
        }

@@ -20,6 +20,7 @@

/* FIXME: what is the reasonable value? */
#define MOBI_HUFFMAN_MAXDEPTH 20 /**< Maximal recursion level for huffman decompression routine */



/**
@@ -30,8 +31,8 @@ typedef struct {
    size_t index_read; /**< Number of indices parsed, used by parser */
    size_t code_length; /**< Code length value stored in CDIC record header */
    uint32_t table1[256]; /**< Table of big-endian indices from HUFF record data1 */
    uint32_t mincode_table[33]; /**< Table of big-endian mincodes from HUFF record data2 */
    uint32_t maxcode_table[33]; /**< Table of big-endian maxcodes from HUFF record data2 */
    uint16_t *symbol_offsets; /**< Index of symbol offsets parsed from CDIC records (index_count entries) */
    unsigned char **symbols; /**< Array of pointers to start of symbols data in each CDIC record (index = number of CDIC record) */
} MOBIHuffCdic;

@@ -589,7 +589,7 @@ MOBI_RET mobi_parse_huff(MOBIHuffCdic *huffcdic, const MOBIPdbRecord *record) {
    /* read 32 mincode-maxcode pairs from data2 big-endian */
    huffcdic->mincode_table[0] = 0;
    huffcdic->maxcode_table[0] = 0xFFFFFFFF;
    for (int i = 1; i < 33; i++) {
        const uint32_t mincode = mobi_buffer_get32(buf);
        const uint32_t maxcode = mobi_buffer_get32(buf);
        huffcdic->mincode_table[i] =  mincode << (32 - i);

","5
src/compression.c
@@ -141,7 +141,10 @@ static MOBI_RET mobi_decompress_huffman_internal(MOBIBuffer *buf_out, MOBIBuffer
        if (!(t1 & 0x80)) {
            /* get offset from mincode, maxcode tables */
            while (code < huffcdic->mincode_table[code_length]) {
                code_length++;
                if (++code_length >= HUFF_CODETABLE_SIZE) {
                    debug_print(""Wrong offset to mincode table: %hhu\n"", code_length);
                    return MOBI_DATA_CORRUPT;
                }
            }
            maxcode = huffcdic->maxcode_table[code_length];
        }
5
src/compression.h
@@ -20,6 +20,7 @@

/* FIXME: what is the reasonable value? */
#define MOBI_HUFFMAN_MAXDEPTH 20 /**< Maximal recursion level for huffman decompression routine */
#define HUFF_CODETABLE_SIZE 33 /**< Size of min- and maxcode tables */


/**
@@ -30,8 +31,8 @@ typedef struct {
    size_t index_read; /**< Number of indices parsed, used by parser */
    size_t code_length; /**< Code length value stored in CDIC record header */
    uint32_t table1[256]; /**< Table of big-endian indices from HUFF record data1 */
    uint32_t mincode_table[33]; /**< Table of big-endian mincodes from HUFF record data2 */
    uint32_t maxcode_table[33]; /**< Table of big-endian maxcodes from HUFF record data2 */
    uint32_t mincode_table[HUFF_CODETABLE_SIZE]; /**< Table of big-endian mincodes from HUFF record data2 */
    uint32_t maxcode_table[HUFF_CODETABLE_SIZE]; /**< Table of big-endian maxcodes from HUFF record data2 */
    uint16_t *symbol_offsets; /**< Index of symbol offsets parsed from CDIC records (index_count entries) */
    unsigned char **symbols; /**< Array of pointers to start of symbols data in each CDIC record (index = number of CDIC record) */
} MOBIHuffCdic;
2
src/read.c
@@ -589,7 +589,7 @@ MOBI_RET mobi_parse_huff(MOBIHuffCdic *huffcdic, const MOBIPdbRecord *record) {
    /* read 32 mincode-maxcode pairs from data2 big-endian */
    huffcdic->mincode_table[0] = 0;
    huffcdic->maxcode_table[0] = 0xFFFFFFFF;
    for (int i = 1; i < 33; i++) {
    for (int i = 1; i < HUFF_CODETABLE_SIZE; i++) {
        const uint32_t mincode = mobi_buffer_get32(buf);
        const uint32_t maxcode = mobi_buffer_get32(buf);
        huffcdic->mincode_table[i] =  mincode << (32 - i);"
https://huntr.dev/bounties/722b3acb-792b-4429-a98d-bb80efb8938d/,Use of Out-of-range Pointer Offset in bfabiszewski/libmobi,Overview,CVE-2021-3888,CWE-823: Use of Out-of-range Pointer Offset,https://www.github.com/bfabiszewski/libmobi/commit/c78e186739b50d156cb3da5d08d70294f0490853,"@@ -752,6 +752,10 @@ MOBI_RET mobi_parse_huffdic(const MOBIData *m, MOBIHuffCdic *huffcdic) {
        }
        curr = curr->next;
    }




    return MOBI_SUCCESS;
}


","4
src/read.c
@@ -752,6 +752,10 @@ MOBI_RET mobi_parse_huffdic(const MOBIData *m, MOBIHuffCdic *huffcdic) {
        }
        curr = curr->next;
    }
    if (huffcdic->index_count != huffcdic->index_read) {
        debug_print(""CDIC: wrong read index count: %zu, total: %zu\n"", huffcdic->index_read, huffcdic->index_count);
        return MOBI_DATA_CORRUPT;
    }
    return MOBI_SUCCESS;
}"
https://huntr.dev/bounties/fcb4383c-bc27-4b89-bfce-6b041f0cb769/,Out-of-bounds Write in bfabiszewski/libmobi,Overview,CVE-2021-3751,CWE-787: Out-of-bounds Write,https://www.github.com/bfabiszewski/libmobi/commit/ab5bf0e37e540eac682a14e628853b918626e72b,"@@ -510,8 +510,8 @@ void mobi_buffer_move(MOBIBuffer *buf, const int offset, const size_t len) {
        }
        source += aoffset;
    } else {
        if (buf->offset < aoffset) {
            debug_print(""%s"", ""End of buffer\n"");
            buf->error = MOBI_BUFFER_END;
            return;
        }

","4
src/buffer.c
@@ -510,8 +510,8 @@ void mobi_buffer_move(MOBIBuffer *buf, const int offset, const size_t len) {
        }
        source += aoffset;
    } else {
        if (buf->offset < aoffset) {
            debug_print(""%s"", ""End of buffer\n"");
        if ( (buf->offset < aoffset) || (buf->offset + len > buf->maxlen) ) {
            debug_print(""%s"", ""Beyond start/end of buffer\n"");
            buf->error = MOBI_BUFFER_END;
            return;
        }"
https://huntr.dev/bounties/6-Rup0rt/pcapfix/,Stack-based Buffer Overflow in rup0rt/pcapfix,A stack over flow was found in pcapfix in function fix_pcap_packets() in pcap.c at line 550,,CWE-121: Stack-based Buffer Overflow,https://www.github.com/rup0rt/pcapfix/commit/3364cb7d66f5eaae01405b809fa8e7b403c93f70,"@@ -350,7 +350,7 @@ int fix_pcap(FILE *pcap, FILE *pcap_fix) {
  /* END OF GLOBAL HEADER CHECK */

  /* start checking packets now */
  res = fix_pcap_packets(pcap, pcap_fix, filesize, global_hdr, hdr_integ, writebuffer, writepos);
  free(writebuffer);
  return(res);
}
@@ -375,10 +375,11 @@ int fix_pcap(FILE *pcap, FILE *pcap_fix) {
 *          -3   error (EOF reached while reading input file)
 *
 */
int fix_pcap_packets(FILE *pcap, FILE *pcap_fix, off_t filesize, struct global_hdr_s global_hdr, unsigned short hdr_integ, char *writebuffer, off_t writepos) {
  struct packet_hdr_s packet_hdr;  /* packet header data */
  struct packet_hdr_s next_packet_hdr;  /* next packet header data to look forward */
  char hdrbuffer[sizeof(packet_hdr)*2];  /* the buffer that will be used to find a proper packet */


  char buffer[PCAP_MAX_SNAPLEN];  /* the packet body */
  off_t bytes;     /* read/written bytes counter */
@@ -467,6 +468,9 @@ int fix_pcap_packets(FILE *pcap, FILE *pcap_fix, off_t filesize, struct global_h
        /* the original length must not be smaller than the included length */
        if (conint(packet_hdr.incl_len) > conint(packet_hdr.orig_len)) packet_hdr.orig_len = packet_hdr.incl_len;




        /* print out information */
        printf(""[+] CORRECTED Packet #%u at position %"" FMT_OFF_T "" (%u | %u | %u | %u).\n"", count, pos, conint(packet_hdr.ts_sec), conint(packet_hdr.ts_usec), conint(packet_hdr.incl_len), conint(packet_hdr.orig_len));
        corrupted++;
@@ -545,16 +549,24 @@ int fix_pcap_packets(FILE *pcap, FILE *pcap_fix, off_t filesize, struct global_h
      /* write this packet */

      // check if there is enough space in buffer
      int totalsize = sizeof(packet_hdr) + conint(packet_hdr.incl_len);
      if (writepos+totalsize > 1024000) {
        bytes = fwrite(writebuffer, writepos, 1, pcap_fix);
        writepos = 0;
      }









      // put new bytes into write buffer
      memcpy(writebuffer+writepos, &packet_hdr, sizeof(packet_hdr));
      writepos += sizeof(packet_hdr);
      memcpy(writebuffer+writepos, buffer, conint(packet_hdr.incl_len));
      writepos += conint(packet_hdr.incl_len);

      /* remember that this packets timestamp to evaluate futher timestamps */
@@ -617,14 +629,14 @@ int fix_pcap_packets(FILE *pcap, FILE *pcap_fix, off_t filesize, struct global_h
          // check if there is enough space in buffer
          int totalsize = sizeof(packet_hdr) + conint(packet_hdr.incl_len);
          if (writepos+totalsize > 1024000) {
            bytes = fwrite(writebuffer, writepos, 1, pcap_fix);
            writepos = 0;
          }

          // put new bytes into write buffer
          memcpy(writebuffer+writepos, &packet_hdr, sizeof(packet_hdr));
          writepos += sizeof(packet_hdr);
          memcpy(writebuffer+writepos, buffer, conint(packet_hdr.incl_len));
          writepos += conint(packet_hdr.incl_len);

          /* remember that this packets timestamp to evaluate futher timestamps */
@@ -698,14 +710,14 @@ int fix_pcap_packets(FILE *pcap, FILE *pcap_fix, off_t filesize, struct global_h
              // check if there is enough space in buffer
              int totalsize = sizeof(packet_hdr) + conint(packet_hdr.incl_len);
              if (writepos+totalsize > 1024000) {
                bytes = fwrite(writebuffer, writepos, 1, pcap_fix);
                writepos = 0;
              }

              // put new bytes into write buffer
              memcpy(writebuffer+writepos, &packet_hdr, sizeof(packet_hdr));
              writepos += sizeof(packet_hdr);
              memcpy(writebuffer+writepos, buffer, conint(packet_hdr.incl_len));
              writepos += conint(packet_hdr.incl_len);

              /* remember that this packets timestamp to evaluate futher timestamps */
@@ -759,7 +771,7 @@ int fix_pcap_packets(FILE *pcap, FILE *pcap_fix, off_t filesize, struct global_h
  }

  // write remaining data into buffer
  bytes = fwrite(writebuffer, writepos, 1, pcap_fix);
  writepos = 0;

  if (verbose == 0) { print_progress(pos, filesize); }

@@ -119,6 +119,6 @@ int fix_pcap(FILE *pcap, FILE *pcap_fix);
 *          -3   error (EOF reached while reading input file)
 *
 */
int fix_pcap_packets(FILE *pcap, FILE *pcap_fix, off_t filesize, struct global_hdr_s global_hdr, unsigned short hdr_integ, char *writebuffer, off_t writepos);

#endif
@@ -454,6 +454,7 @@ int main(int argc, char *argv[]) {

      /* delete output file due to failure */
      if (strcmp(filename, filename_fix) != 0) remove(filename_fix);


      return(res-10);

@@ -471,6 +472,7 @@ int main(int argc, char *argv[]) {

      /* delete output file due to failure */
      if (strcmp(filename, filename_fix) != 0) remove(filename_fix);


      return(res-10);
  }

","38
pcap.c
@@ -350,7 +350,7 @@ int fix_pcap(FILE *pcap, FILE *pcap_fix) {
  /* END OF GLOBAL HEADER CHECK */

  /* start checking packets now */
  res = fix_pcap_packets(pcap, pcap_fix, filesize, global_hdr, hdr_integ, writebuffer, writepos);
  res = fix_pcap_packets(pcap, pcap_fix, filesize, global_hdr, hdr_integ, &writebuffer, writepos);
  free(writebuffer);
  return(res);
}
@@ -375,10 +375,11 @@ int fix_pcap(FILE *pcap, FILE *pcap_fix) {
 *          -3   error (EOF reached while reading input file)
 *
 */
int fix_pcap_packets(FILE *pcap, FILE *pcap_fix, off_t filesize, struct global_hdr_s global_hdr, unsigned short hdr_integ, char *writebuffer, off_t writepos) {
int fix_pcap_packets(FILE *pcap, FILE *pcap_fix, off_t filesize, struct global_hdr_s global_hdr, unsigned short hdr_integ, char **writebuffer, off_t writepos) {
  struct packet_hdr_s packet_hdr;  /* packet header data */
  struct packet_hdr_s next_packet_hdr;  /* next packet header data to look forward */
  char hdrbuffer[sizeof(packet_hdr)*2];  /* the buffer that will be used to find a proper packet */
  char *tmpbuf;     /* temp write buffer */

  char buffer[PCAP_MAX_SNAPLEN];  /* the packet body */
  off_t bytes;     /* read/written bytes counter */
@@ -467,6 +468,9 @@ int fix_pcap_packets(FILE *pcap, FILE *pcap_fix, off_t filesize, struct global_h
        /* the original length must not be smaller than the included length */
        if (conint(packet_hdr.incl_len) > conint(packet_hdr.orig_len)) packet_hdr.orig_len = packet_hdr.incl_len;

        /* the included length must not be greater than filesize */
        if (conint(packet_hdr.incl_len) > filesize-pos) packet_hdr.incl_len = filesize-pos;

        /* print out information */
        printf(""[+] CORRECTED Packet #%u at position %"" FMT_OFF_T "" (%u | %u | %u | %u).\n"", count, pos, conint(packet_hdr.ts_sec), conint(packet_hdr.ts_usec), conint(packet_hdr.incl_len), conint(packet_hdr.orig_len));
        corrupted++;
@@ -545,16 +549,24 @@ int fix_pcap_packets(FILE *pcap, FILE *pcap_fix, off_t filesize, struct global_h
      /* write this packet */

      // check if there is enough space in buffer
      int totalsize = sizeof(packet_hdr) + conint(packet_hdr.incl_len);
      off_t totalsize = sizeof(packet_hdr) + conint(packet_hdr.incl_len);
      if (writepos+totalsize > 1024000) {
        bytes = fwrite(writebuffer, writepos, 1, pcap_fix);
        bytes = fwrite(*writebuffer, writepos, 1, pcap_fix);
        writepos = 0;
      }

      /* check if writebuffer is large enough */
      if (sizeof(packet_hdr) + conint(packet_hdr.incl_len) > 1024000) {
        tmpbuf = malloc(sizeof(packet_hdr) + conint(packet_hdr.incl_len));
        memcpy(tmpbuf, *writebuffer, 1024000);
        free(*writebuffer);
        writebuffer = &tmpbuf;
      }

      // put new bytes into write buffer
      memcpy(writebuffer+writepos, &packet_hdr, sizeof(packet_hdr));
      memcpy(*writebuffer+writepos, &packet_hdr, sizeof(packet_hdr));
      writepos += sizeof(packet_hdr);
      memcpy(writebuffer+writepos, buffer, conint(packet_hdr.incl_len));
      memcpy(*writebuffer+writepos, buffer, conint(packet_hdr.incl_len));
      writepos += conint(packet_hdr.incl_len);

      /* remember that this packets timestamp to evaluate futher timestamps */
@@ -617,14 +629,14 @@ int fix_pcap_packets(FILE *pcap, FILE *pcap_fix, off_t filesize, struct global_h
          // check if there is enough space in buffer
          int totalsize = sizeof(packet_hdr) + conint(packet_hdr.incl_len);
          if (writepos+totalsize > 1024000) {
            bytes = fwrite(writebuffer, writepos, 1, pcap_fix);
            bytes = fwrite(*writebuffer, writepos, 1, pcap_fix);
            writepos = 0;
          }

          // put new bytes into write buffer
          memcpy(writebuffer+writepos, &packet_hdr, sizeof(packet_hdr));
          memcpy(*writebuffer+writepos, &packet_hdr, sizeof(packet_hdr));
          writepos += sizeof(packet_hdr);
          memcpy(writebuffer+writepos, buffer, conint(packet_hdr.incl_len));
          memcpy(*writebuffer+writepos, buffer, conint(packet_hdr.incl_len));
          writepos += conint(packet_hdr.incl_len);

          /* remember that this packets timestamp to evaluate futher timestamps */
@@ -698,14 +710,14 @@ int fix_pcap_packets(FILE *pcap, FILE *pcap_fix, off_t filesize, struct global_h
              // check if there is enough space in buffer
              int totalsize = sizeof(packet_hdr) + conint(packet_hdr.incl_len);
              if (writepos+totalsize > 1024000) {
                bytes = fwrite(writebuffer, writepos, 1, pcap_fix);
                bytes = fwrite(*writebuffer, writepos, 1, pcap_fix);
                writepos = 0;
              }

              // put new bytes into write buffer
              memcpy(writebuffer+writepos, &packet_hdr, sizeof(packet_hdr));
              memcpy(*writebuffer+writepos, &packet_hdr, sizeof(packet_hdr));
              writepos += sizeof(packet_hdr);
              memcpy(writebuffer+writepos, buffer, conint(packet_hdr.incl_len));
              memcpy(*writebuffer+writepos, buffer, conint(packet_hdr.incl_len));
              writepos += conint(packet_hdr.incl_len);

              /* remember that this packets timestamp to evaluate futher timestamps */
@@ -759,7 +771,7 @@ int fix_pcap_packets(FILE *pcap, FILE *pcap_fix, off_t filesize, struct global_h
  }

  // write remaining data into buffer
  bytes = fwrite(writebuffer, writepos, 1, pcap_fix);
  bytes = fwrite(*writebuffer, writepos, 1, pcap_fix);
  writepos = 0;

  if (verbose == 0) { print_progress(pos, filesize); }
2
pcap.h
@@ -119,6 +119,6 @@ int fix_pcap(FILE *pcap, FILE *pcap_fix);
 *          -3   error (EOF reached while reading input file)
 *
 */
int fix_pcap_packets(FILE *pcap, FILE *pcap_fix, off_t filesize, struct global_hdr_s global_hdr, unsigned short hdr_integ, char *writebuffer, off_t writepos);
int fix_pcap_packets(FILE *pcap, FILE *pcap_fix, off_t filesize, struct global_hdr_s global_hdr, unsigned short hdr_integ, char **writebuffer, off_t writepos);

#endif
2
pcapfix.c
@@ -454,6 +454,7 @@ int main(int argc, char *argv[]) {

      /* delete output file due to failure */
      if (strcmp(filename, filename_fix) != 0) remove(filename_fix);
      free(filename_fix);

      return(res-10);

@@ -471,6 +472,7 @@ int main(int argc, char *argv[]) {

      /* delete output file due to failure */
      if (strcmp(filename, filename_fix) != 0) remove(filename_fix);
      free(filename_fix);

      return(res-10);
  }"
https://huntr.dev/bounties/5-Rup0rt/pcapfix/,Heap-based Buffer Overflow in rup0rt/pcapfix,A heap over flow was found in pcapfix in function fix_pcapng() in pcapng.c at line 1571,,CWE-122: Heap-based Buffer Overflow,https://www.github.com/rup0rt/pcapfix/commit/09053eca651b4c199e1518d5316e17b63439228a,"@@ -115,7 +115,7 @@ int fix_pcapng(FILE *pcap, FILE *pcap_fix) {

  // we use a buffer to cache 1mb of writing... this way writing is faster and
  // we can read and write the file at the same time
  char *writebuffer;
  off_t writepos = 0;

  off_t bytes;                              /* written bytes/blocks counter */
@@ -197,7 +197,7 @@ int fix_pcapng(FILE *pcap, FILE *pcap_fix) {
      }

      if (bh.total_length < 12) {
        printf(""[-] Block too small ==> SKIPPING\n"");

        /* reset input file pointer to next block */
        fseeko(pcap, pos+bh.total_length, SEEK_SET);
@@ -1569,13 +1569,21 @@ int fix_pcapng(FILE *pcap, FILE *pcap_fix) {
      /* write repaired block into output file */
      if (verbose >= 2) printf(""[*] Writing block to buffer (%u bytes).\n"", block_pos);

      // do we need to write the buffer to the file?
      if (writepos + block_pos > 1024000) {
        bytes = fwrite(writebuffer, writepos, 1, pcap_fix);
        writepos = 0;
      }

      // put new bytes into write buffer








      memcpy(writebuffer+writepos, new_block, block_pos);
      writepos += block_pos;

@@ -1642,7 +1650,7 @@ int fix_pcapng(FILE *pcap, FILE *pcap_fix) {

  }

  // write remaining data into buffer
  bytes = fwrite(writebuffer, writepos, 1, pcap_fix);
  writepos = 0;


","18
pcapng.c
@@ -115,7 +115,7 @@ int fix_pcapng(FILE *pcap, FILE *pcap_fix) {

  // we use a buffer to cache 1mb of writing... this way writing is faster and
  // we can read and write the file at the same time
  char *writebuffer;
  char *writebuffer, *tmpbuf;
  off_t writepos = 0;

  off_t bytes;                              /* written bytes/blocks counter */
@@ -197,7 +197,7 @@ int fix_pcapng(FILE *pcap, FILE *pcap_fix) {
      }

      if (bh.total_length < 12) {
        printf(""[-] Block too small ==> SKIPPING\n"");
        printf(""[-] Block too small ==> SKIPPING.\n"");

        /* reset input file pointer to next block */
        fseeko(pcap, pos+bh.total_length, SEEK_SET);
@@ -1569,13 +1569,21 @@ int fix_pcapng(FILE *pcap, FILE *pcap_fix) {
      /* write repaired block into output file */
      if (verbose >= 2) printf(""[*] Writing block to buffer (%u bytes).\n"", block_pos);

      // do we need to write the buffer to the file?
      /* do we need to write the buffer to the file? */
      if (writepos + block_pos > 1024000) {
        bytes = fwrite(writebuffer, writepos, 1, pcap_fix);
        writepos = 0;
      }

      // put new bytes into write buffer
      /* check if writebuffer is large enough */
      if (block_pos > 1024000) {
        tmpbuf = malloc(block_pos);
        memcpy(tmpbuf, writebuffer, 1024000);
        free(writebuffer);
        writebuffer = tmpbuf;
      }

      /* put new bytes into write buffer */
      memcpy(writebuffer+writepos, new_block, block_pos);
      writepos += block_pos;

@@ -1642,7 +1650,7 @@ int fix_pcapng(FILE *pcap, FILE *pcap_fix) {

  }

  // write remaining data into buffer
  /* write remaining data into buffer */
  bytes = fwrite(writebuffer, writepos, 1, pcap_fix);
  writepos = 0;"
https://huntr.dev/bounties/4-Rup0rt/pcapfix/,Heap-based Buffer Overflow in rup0rt/pcapfix,A heap over flow was found in pcapfix in function fix_pcapng() in pcapng.c at line 216,,CWE-122: Heap-based Buffer Overflow,https://www.github.com/rup0rt/pcapfix/commit/c3f12cce88df492e263c950c00df2d57a401acba,"@@ -196,6 +196,15 @@ int fix_pcapng(FILE *pcap, FILE *pcap_fix) {

      }










      if (verbose >= 1) printf(""[*] Assuming this blocks size as %"" PRIu32 "" bytes.\n"", bh.total_length);
      else printf(""[-] Invalid Block size => CORRECTED.\n"");

@@ -1733,7 +1742,7 @@ int find_valid_block(FILE *pcap, off_t filesize) {
      if (check == bh.total_length) {
        /* also the second block size value is correct! */

        if (verbose >= 1) printf(""[+] FOUND: Block (Type: 0x%08"" PRIx32 "") at Position %"" FMT_OFF_T ""\n"", bh.block_type, i);

        /* set pointer to next block position */
        fseeko(pcap, i, SEEK_SET);

","11
pcapng.c
@@ -196,6 +196,15 @@ int fix_pcapng(FILE *pcap, FILE *pcap_fix) {

      }

      if (bh.total_length < 12) {
        printf(""[-] Block too small ==> SKIPPING\n"");

        /* reset input file pointer to next block */
        fseeko(pcap, pos+bh.total_length, SEEK_SET);

        continue;
      }

      if (verbose >= 1) printf(""[*] Assuming this blocks size as %"" PRIu32 "" bytes.\n"", bh.total_length);
      else printf(""[-] Invalid Block size => CORRECTED.\n"");

@@ -1733,7 +1742,7 @@ int find_valid_block(FILE *pcap, off_t filesize) {
      if (check == bh.total_length) {
        /* also the second block size value is correct! */

        if (verbose >= 1) printf(""[+] FOUND: Block (Type: 0x%08"" PRIx32 "") at Position %"" FMT_OFF_T ""\n"", bh.block_type, i);
        if (verbose >= 1) printf(""[+] FOUND: Block (Type: 0x%08"" PRIx32 "", Length: %u) at Position %"" FMT_OFF_T ""\n"", bh.block_type, bh.total_length, i);

        /* set pointer to next block position */
        fseeko(pcap, i, SEEK_SET);"
https://huntr.dev/bounties/2-Rup0rt/pcapfix/,Heap-based Buffer Overflow in rup0rt/pcapfix,"Whilst testing the 'devel' branch of pcapfix, specifically commit fb723ccompiled with clang-13 and -fsanitize=address on Ubuntu 20.04.2 LTS, we discovered a POC which triggers a heap-buffer-overflow.",,CWE-122: Heap-based Buffer Overflow,https://www.github.com/rup0rt/pcapfix/commit/b169178630739d9e011bf40c83215976346e9465,"@@ -1556,6 +1556,17 @@ int fix_pcapng(FILE *pcap, FILE *pcap_fix) {

      /* write sizes of block header to correct positions */
      block_pos += sizeof(bh.total_length);











      memcpy(new_block+4, &block_pos, sizeof(bh.total_length));
      memcpy(new_block+block_pos-4, &block_pos, sizeof(bh.total_length));


","11
pcapng.c
@@ -1556,6 +1556,17 @@ int fix_pcapng(FILE *pcap, FILE *pcap_fix) {

      /* write sizes of block header to correct positions */
      block_pos += sizeof(bh.total_length);

      /* check size of block */
      if (bh.total_length < block_pos) {
        if (verbose >= 2) printf(""[*] Increasing block buffer to %u\n"", block_pos);
        tmpbuf = malloc(block_pos);
        memcpy(tmpbuf, new_block, bh.total_length);
        free(new_block);
        new_block = tmpbuf;
        bh.total_length = block_pos;
      }

      memcpy(new_block+4, &block_pos, sizeof(bh.total_length));
      memcpy(new_block+block_pos-4, &block_pos, sizeof(bh.total_length));"
https://huntr.dev/bounties/1-Rup0rt/pcapfix/,Heap-based Buffer Overflow in rup0rt/pcapfix,"Whilst testing pcapfix built from commit 5c2965 with Clang 13 (+ASan) on Ubuntu 20.04.2 LTS, we discovered a PCAPNG file which triggers a heap-buffer-overflow during a memcpy operation.",,CWE-122: Heap-based Buffer Overflow,https://www.github.com/rup0rt/pcapfix/commit/fb723c8374db2f0e8b394570e433e4cc70f07b75,"@@ -164,11 +164,14 @@ int fix_pcapng(FILE *pcap, FILE *pcap_fix) {
    bytes = fread(&bh, sizeof(bh), 1, pcap);
    if (bytes != 1) return -3;

    /* check for invalid block length / file cut off */
    if (bh.total_length > filesize-pos) {
      /* block size is larger than bytes in input file */

      if (verbose >= 1) printf(""[-] Block Length (%"" PRIu16 "") exceeds file size (%"" FMT_OFF_T "").\n"", bh.total_length, filesize);




      /* search for next valid block */
      if (verbose >= 1) printf(""[*] Trying to align next block...\n"");
@@ -1429,7 +1432,8 @@ int fix_pcapng(FILE *pcap, FILE *pcap_fix) {
  writepos = 0;

  /* FILE HAS BEEN COMPLETELY CHECKED */


  /* did we write any SHB blocks at all?
   * if not this seems to be no pcapng file! */
  if (shb_num == 0) return(-1);

","14
pcapng.c
@@ -164,11 +164,14 @@ int fix_pcapng(FILE *pcap, FILE *pcap_fix) {
    bytes = fread(&bh, sizeof(bh), 1, pcap);
    if (bytes != 1) return -3;

    /* check for invalid block length / file cut off */
    if (bh.total_length > filesize-pos) {
      /* block size is larger than bytes in input file */
    /* check for invalid block length / file cut off OR block size < 12 bytes */
    if (bh.total_length > filesize-pos || bh.total_length < 12) {
      /* block size is invalid (too small / larger than bytes in input file) */

      if (verbose >= 1) printf(""[-] Block Length (%"" PRIu16 "") exceeds file size (%"" FMT_OFF_T "").\n"", bh.total_length, filesize);
      if (verbose >= 1) {
        if (bh.total_length > filesize-pos) printf(""[-] Block Length (%"" PRIu16 "") exceeds file size (%"" FMT_OFF_T "").\n"", bh.total_length, filesize);
        else printf(""[-] Block Length (%"" PRIu16 "") is too small.\n"", bh.total_length);
      }

      /* search for next valid block */
      if (verbose >= 1) printf(""[*] Trying to align next block...\n"");
@@ -1429,7 +1432,8 @@ int fix_pcapng(FILE *pcap, FILE *pcap_fix) {
  writepos = 0;

  /* FILE HAS BEEN COMPLETELY CHECKED */

  free(writebuffer);

  /* did we write any SHB blocks at all?
   * if not this seems to be no pcapng file! */
  if (shb_num == 0) return(-1);"
https://huntr.dev/bounties/2-other-mcfriend99/Bird/,Denial of Service in mcfriend99/bird,The Bird interpreter is vulnerable to memory leaks. This occurs due to memory being allocated but never freed during the compilation/interpretation process.,,CWE-400: Denial of Service,https://www.github.com/mcfriend99/bird/commit/bac3f304715db9b743458676292a0024bb3ce1e6,"@@ -96,8 +96,8 @@ endif











","4
birdy.mk
@@ -96,8 +96,8 @@ endif

# Mode configuration.
ifeq ($(MODE),debug)
# CFLAGS += -O0 -DDEBUG -g
 CFLAGS += -O0 -DDEBUG -g -fsanitize=address
 CFLAGS += -O0 -DDEBUG -g
# CFLAGS += -O0 -DDEBUG -g -fsanitize=address
 BUILD_DIR := build/debug
else
 CFLAGS += -O3 -flto"
https://huntr.dev/bounties/1-other-rockcarry/ffjpeg/,Integer Overflow or Wraparound in rockcarry/ffjpeg,An exploitable heap overflow vulnerability exists in function bmp_load() in bmp.c.,,CWE-190: Integer Overflow or Wraparound,https://www.github.com/rockcarry/ffjpeg/commit/0fa4cf8a86d7f23a3e8336343c1895aa634fdc76,"@@ -41,6 +41,10 @@ int bmp_load(BMP *pb, char *file)
    pb->width  = (int)header.biWidth  > 0 ? (int)header.biWidth  : 0;
    pb->height = (int)header.biHeight > 0 ? (int)header.biHeight : 0;
    pb->stride = ALIGN(pb->width * 3, 4);




    pb->pdata  = malloc((size_t)pb->stride * pb->height);
    if (pb->pdata) {
        pdata  = (BYTE*)pb->pdata + pb->stride * pb->height;
@@ -50,7 +54,8 @@ int bmp_load(BMP *pb, char *file)
        }
    }

    fclose(fp);

    return pb->pdata ? 0 : -1;
}


","7
src/bmp.c
@@ -41,6 +41,10 @@ int bmp_load(BMP *pb, char *file)
    pb->width  = (int)header.biWidth  > 0 ? (int)header.biWidth  : 0;
    pb->height = (int)header.biHeight > 0 ? (int)header.biHeight : 0;
    pb->stride = ALIGN(pb->width * 3, 4);
    if ((long long)pb->stride * pb->height >= 0x80000000) {
        printf(""bmp's width * height is out of range !\n"");
        goto done;
    }
    pb->pdata  = malloc((size_t)pb->stride * pb->height);
    if (pb->pdata) {
        pdata  = (BYTE*)pb->pdata + pb->stride * pb->height;
@@ -50,7 +54,8 @@ int bmp_load(BMP *pb, char *file)
        }
    }

    fclose(fp);
done:
    if (fp) fclose(fp);
    return pb->pdata ? 0 : -1;
}"
